From wli@holomorphy.com Fri Apr  5 13:32:54 2002
Date: Fri, 5 Apr 2002 02:36:43 -0800
From: William Lee Irwin III <wli@holomorphy.com>
To: bochs-developers@lists.sourceforge.net
Subject: [Bochs-developers] 05_8_cpus

These are all fairly trivial patches; essentially aside from minor
#defined limitations and some table setup for interacting with the
OS this works pretty much out of the box. keyboard.cc changes
reverted as usual for Linux compatibility.

A few minor things came up while testing the thing, which are addressed
along with the defines and table setups in the following patch.

configure.in:
	Add a case for 8 cpu's.
rombios.c:
	Add an MP table for 8 cpu's.
apic.cc:
	Handle a strange boundary case tripped by setting something
	to an APIC ID it already possesses.
cpu.cc:
	Assign either 0 or 1 to is_32, which is a Bool. The value
	appeared to resemble a stack address, which is probably a
	sign of a deeper problem and interacted poorly with
	fetchdecode.cc's array index arithmetic (in fact raising
	an exception within the simulator itself).
cpu.h:
	(A) make as_32 and os_32 booleans, to (hopefully) prevent
	similar problems as with is_32.
	(B) #define APIC_MAX_ID to 32. Any higher than this and
	poor interactions with 32-bit APIC ID bitmasks begin to
	occur; larger bitmasks may well be in order esp. if these
	are considered physical or clustered APIC ID's.
ioapic.cc:
	Avoid truncation of ioapic's physical APIC ID so as to
	prevent clashes of I/O APIC ID's with local APIC ID's
	This is compatible with flat logical destination modes
	of APICs because I/O apics are never worthwhile destinations
	for IPI's, so its non-addressibility in flat logical mode
	is inconsequential. It's unclear with which version of the
	I/O APIC this is compatible given the usual limitations on
	the number(s) of bits involved, but essentially this appears
	to work around some problems I've seen arising when the I/O
	APIC's ID clashes with a CPU's local APIC ID by assigning the
	I/O APIC an ID distinct from all cpus' while leaving all APIC
	ID's addressible in flat logical mode available for local APICs.

Index: configure.in
===================================================================
RCS file: /cvsroot/bochs/bochs/configure.in,v
retrieving revision 1.78
diff -u -r1.78 configure.in
--- configure.in	28 Mar 2002 09:43:07 -0000	1.78
+++ configure.in	5 Apr 2002 10:17:15 -0000
@@ -236,6 +236,13 @@
        AC_DEFINE(BX_IOAPIC_DEFAULT_ID, 4)
        AC_DEFINE(BX_USE_CPU_SMF, 0)
        ;;
+     8)
+       AC_MSG_RESULT(8)
+       AC_DEFINE(BX_SMP_PROCESSORS, 8)
+       AC_DEFINE(BX_BOOTSTRAP_PROCESSOR, 0)
+       AC_DEFINE(BX_IOAPIC_DEFAULT_ID, 0x11)
+       AC_DEFINE(BX_USE_CPU_SMF, 0)
+       ;;
      *)
        echo " "
        echo "WARNING: processors != [1,2,4] can work, but you need to modify rombios.c manually"
Index: bios/rombios.c
===================================================================
RCS file: /cvsroot/bochs/bochs/bios/rombios.c,v
retrieving revision 1.44
diff -u -r1.44 rombios.c
--- bios/rombios.c	4 Apr 2002 16:57:45 -0000	1.44
+++ bios/rombios.c	5 Apr 2002 10:17:18 -0000
@@ -9966,6 +9966,132 @@
   db 3,0,0,0,0,13,4,13
   db 3,0,0,0,0,14,4,14
   db 3,0,0,0,0,15,4,15
+#elif (BX_SMP_PROCESSORS==8)
+// define the Intel MP Configuration Structure for 4 processors at
+// APIC ID 0,1,2,3.  I/O APIC at ID=4.
+.align 16
+mp_config_table:
+  db 0x50, 0x43, 0x4d, 0x50  ;; "PCMP" signature
+  dw (mp_config_end-mp_config_table)  ;; table length
+  db 4 ;; spec rev
+  db 0x2e ;; checksum
+  .ascii "BOCHSCPU"     ;; OEM id = "BOCHSCPU"
+  db 0x30, 0x2e, 0x31, 0x20 ;; vendor id = "0.1         "
+  db 0x20, 0x20, 0x20, 0x20 
+  db 0x20, 0x20, 0x20, 0x20
+  dw 0,0 ;; oem table ptr
+  dw 0 ;; oem table size
+  dw 22 ;; entry count
+  dw 0x0000, 0xfee0 ;; memory mapped address of local APIC
+  dw 0 ;; extended table length
+  db 0 ;; extended table checksum
+  db 0 ;; reserved
+mp_config_proc0:
+  db 0 ;; entry type=processor
+  db 0 ;; local APIC id
+  db 0x11 ;; local APIC version number
+  db 3 ;; cpu flags: bootstrap cpu
+  db 0,6,0,0 ;; cpu signature
+  dw 0x201,0 ;; feature flags
+  dw 0,0 ;; reserved
+  dw 0,0 ;; reserved
+mp_config_proc1:
+  db 0 ;; entry type=processor
+  db 1 ;; local APIC id
+  db 0x11 ;; local APIC version number
+  db 1 ;; cpu flags: enabled
+  db 0,6,0,0 ;; cpu signature
+  dw 0x201,0 ;; feature flags
+  dw 0,0 ;; reserved
+  dw 0,0 ;; reserved
+mp_config_proc2:
+  db 0 ;; entry type=processor
+  db 2 ;; local APIC id
+  db 0x11 ;; local APIC version number
+  db 1 ;; cpu flags: enabled
+  db 0,6,0,0 ;; cpu signature
+  dw 0x201,0 ;; feature flags
+  dw 0,0 ;; reserved
+  dw 0,0 ;; reserved
+mp_config_proc3:
+  db 0 ;; entry type=processor
+  db 3 ;; local APIC id
+  db 0x11 ;; local APIC version number
+  db 1 ;; cpu flags: enabled
+  db 0,6,0,0 ;; cpu signature
+  dw 0x201,0 ;; feature flags
+  dw 0,0 ;; reserved
+  dw 0,0 ;; reserved
+mp_config_proc4:
+  db 0 ;; entry type=processor
+  db 4 ;; local APIC id
+  db 0x11 ;; local APIC version number
+  db 1 ;; cpu flags: enabled
+  db 0,6,0,0 ;; cpu signature
+  dw 0x201,0 ;; feature flags
+  dw 0,0 ;; reserved
+  dw 0,0 ;; reserved
+mp_config_proc5:
+  db 0 ;; entry type=processor
+  db 5 ;; local APIC id
+  db 0x11 ;; local APIC version number
+  db 1 ;; cpu flags: enabled
+  db 0,6,0,0 ;; cpu signature
+  dw 0x201,0 ;; feature flags
+  dw 0,0 ;; reserved
+  dw 0,0 ;; reserved
+mp_config_proc6:
+  db 0 ;; entry type=processor
+  db 6 ;; local APIC id
+  db 0x11 ;; local APIC version number
+  db 1 ;; cpu flags: enabled
+  db 0,6,0,0 ;; cpu signature
+  dw 0x201,0 ;; feature flags
+  dw 0,0 ;; reserved
+  dw 0,0 ;; reserved
+mp_config_proc7:
+  db 0 ;; entry type=processor
+  db 7 ;; local APIC id
+  db 0x11 ;; local APIC version number
+  db 1 ;; cpu flags: enabled
+  db 0,6,0,0 ;; cpu signature
+  dw 0x201,0 ;; feature flags
+  dw 0,0 ;; reserved
+  dw 0,0 ;; reserved
+mp_config_isa_bus:
+  db 1 ;; entry type=bus
+  db 0 ;; bus ID
+  db 0x49, 0x53, 0x41, 0x20, 0x20, 0x20  ;; bus type="ISA   "
+mp_config_ioapic:
+  db 2 ;; entry type=I/O APIC
+  db 0x11 ;; apic id=2. linux will set.
+  db 0x11 ;; I/O APIC version number
+  db 1 ;; flags=1=enabled
+  dw 0x0000, 0xfec0 ;; memory mapped address of I/O APIC
+mp_config_irqs:
+  db 3 ;; entry type=I/O interrupt
+  db 0 ;; interrupt type=vectored interrupt
+  db 0,0 ;; flags po=0, el=0 (linux uses as default)
+  db 0 ;; source bus ID is ISA
+  db 0 ;; source bus IRQ
+  db 0x11 ;; destination I/O APIC ID, Linux can't address it but won't need to
+  db 0 ;; destination I/O APIC interrrupt in
+  ;; repeat pattern for interrupts 0-15
+  db 3,0,0,0,0,1,0x11,1
+  db 3,0,0,0,0,2,0x11,2
+  db 3,0,0,0,0,3,0x11,3
+  db 3,0,0,0,0,4,0x11,4
+  db 3,0,0,0,0,5,0x11,5
+  db 3,0,0,0,0,6,0x11,6
+  db 3,0,0,0,0,7,0x11,7
+  db 3,0,0,0,0,8,0x11,8
+  db 3,0,0,0,0,9,0x11,9
+  db 3,0,0,0,0,10,0x11,10
+  db 3,0,0,0,0,11,0x11,11
+  db 3,0,0,0,0,12,0x11,12
+  db 3,0,0,0,0,13,0x11,13
+  db 3,0,0,0,0,14,0x11,14
+  db 3,0,0,0,0,15,0x11,15
 #else
 #  error Sorry, rombios only has configurations for 1, 2, or 4 processors.
 #endif  // if (BX_SMP_PROCESSORS==...)
Index: cpu/apic.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/cpu/apic.cc,v
retrieving revision 1.14
diff -u -r1.14 apic.cc
--- cpu/apic.cc	27 Mar 2002 16:04:04 -0000	1.14
+++ cpu/apic.cc	5 Apr 2002 10:17:18 -0000
@@ -56,9 +56,12 @@
       BX_PANIC(("inconsistent APIC id table"));
     apic_index[id] = NULL;
   }
+  if (id == newid && (apic_index[id] == this || apic_index[id] == NULL))
+    goto set_ok;
+  if (apic_index[newid] != NULL)
+    BX_PANIC(("duplicate APIC id assigned, id=%lx, newid=%lx, this=%p, apic_index[id]=%p", id, newid, this, apic_index[newid]));
+set_ok:
   id = newid;
-  if (apic_index[id] != NULL)
-    BX_PANIC(("duplicate APIC id assigned"));
   apic_index[id] = this;
 }
 
Index: cpu/cpu.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/cpu/cpu.cc,v
retrieving revision 1.27
diff -u -r1.27 cpu.cc
--- cpu/cpu.cc	1 Apr 2002 13:14:37 -0000	1.27
+++ cpu/cpu.cc	5 Apr 2002 10:17:18 -0000
@@ -207,7 +207,10 @@
   }
 #endif
 
-  is_32 = BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].cache.u.segment.d_b;
+  if (BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].cache.u.segment.d_b)
+    is_32 = 1;
+  else
+    is_32 = 0;
 
   if (BX_CPU_THIS_PTR bytesleft == 0) {
     prefetch();
Index: cpu/cpu.h
===================================================================
RCS file: /cvsroot/bochs/bochs/cpu/cpu.h,v
retrieving revision 1.18
diff -u -r1.18 cpu.h
--- cpu/cpu.h	1 Apr 2002 04:42:43 -0000	1.18
+++ cpu/cpu.h	5 Apr 2002 10:17:19 -0000
@@ -457,7 +457,7 @@
   Bit8u    Ib2; // for ENTER_IwIb
   Bit16u   Iw2; // for JMP_Ap
   unsigned ilen; // instruction length
-  unsigned os_32, as_32; // OperandSize/AddressSize is 32bit
+  bool os_32, as_32; // OperandSize/AddressSize is 32bit
   unsigned flags_in, flags_out; // flags needed, flags modified
 
 #if BX_USE_CPU_SMF
@@ -669,7 +669,7 @@
   virtual void set_arb_id (int newid);
   };
 
-#define APIC_MAX_ID 16
+#define APIC_MAX_ID 32
 extern bx_generic_apic_c *apic_index[APIC_MAX_ID];
 #endif // if BX_SUPPORT_APIC
 
Index: iodev/ioapic.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/iodev/ioapic.cc,v
retrieving revision 1.7
diff -u -r1.7 ioapic.cc
--- iodev/ioapic.cc	20 Mar 2002 02:41:19 -0000	1.7
+++ iodev/ioapic.cc	5 Apr 2002 10:17:19 -0000
@@ -106,7 +106,7 @@
   switch (ioregsel) {
     case 0x00: // set APIC ID
       {
-	Bit8u newid = (*value >> 24) & 0xf;
+	Bit8u newid = (*value >> 24);
 	BX_INFO(("IOAPIC: setting id to 0x%x", newid));
 	set_id (newid);
 	return;

_______________________________________________
bochs-developers mailing list
bochs-developers@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bochs-developers
