*** gui/win32.cc	24 Feb 2002 17:20:19 -0000	1.23
--- gui/win32.cc	9 Mar 2002 13:40:28 -0000
@@ -386,7 +386,7 @@
     cursorWarped();
 
     hdc = GetDC(stInfo.hwnd);
-    MemoryBitmap = CreateCompatibleBitmap(hdc, dimension_x, dimension_y);
+    MemoryBitmap = CreateCompatibleBitmap(hdc, BX_MAX_XRES, BX_MAX_YRES);
     MemoryDC = CreateCompatibleDC(hdc);
     ReleaseDC(stInfo.hwnd, hdc);
 


*** iodev/vga.cc	7 Feb 2002 19:04:30 -0000	1.23
--- iodev/vga.cc	9 Mar 2002 13:40:32 -0000
@@ -201,6 +201,26 @@
 
   BX_VGA_THIS s.horiz_tick = 0;
   BX_VGA_THIS s.vert_tick = 0;
+  
+#if BX_SUPPORT_VBE  
+  // The following is for the vbe display extension
+  // FIXME: change 0xff80 & 0xff81 into some nice constants
+  
+  for (addr=0xff80; addr<=0xff81; addr++) {
+    BX_VGA_THIS devices->register_io_read_handler(this, vbe_read_handler,
+                                        addr, "vga video");
+    BX_VGA_THIS devices->register_io_write_handler(this, vbe_write_handler,
+                                        addr, "vga video");
+  }    
+  BX_VGA_THIS s.vbe_xres=640;
+  BX_VGA_THIS s.vbe_yres=400;
+  BX_VGA_THIS s.vbe_bpp=8;
+  BX_VGA_THIS s.vbe_bank=0;
+  BX_VGA_THIS s.vbe_enabled=0;
+  BX_VGA_THIS s.vbe_curindex=0;
+  
+  BX_INFO(("VBE Bochs Display Extension Enabled"));
+#endif  
 }
 
 
@@ -962,14 +982,26 @@
         case 2:
           BX_VGA_THIS s.pel.data[BX_VGA_THIS s.pel.write_data_register].blue = value;
           {
-          unsigned iHeight, iWidth;
-          determine_screen_dimensions(&iHeight, &iWidth);
-	  if( (iWidth != old_iWidth) || (iHeight != old_iHeight) )
-	  {
-	    bx_gui.dimension_update(iWidth, iHeight);
-	    old_iWidth = iWidth;
-	    old_iHeight = iHeight;
-	  }
+            unsigned iHeight, iWidth;
+#if BX_SUPPORT_VBE          
+            // when we are in a vbe enabled mode, better get the width/height from the vbe settings
+            if (BX_VGA_THIS s.vbe_enabled)
+            {
+              old_iWidth = iWidth = BX_VGA_THIS s.vbe_xres;
+              old_iHeight = iHeight = BX_VGA_THIS s.vbe_yres;
+            }
+            else
+#endif            
+            {
+              // 'normal vga' operation
+              determine_screen_dimensions(&iHeight, &iWidth);
+        	    if( (iWidth != old_iWidth) || (iHeight != old_iHeight) )
+	            {
+	              bx_gui.dimension_update(iWidth, iHeight);
+	              old_iWidth = iWidth;
+	              old_iHeight = iHeight;
+	            }
+	          }
           }
 
           needs_update = bx_gui.palette_change(BX_VGA_THIS s.pel.write_data_register,
@@ -1150,6 +1182,54 @@
 bx_vga_c::update(void)
 {
   unsigned iHeight, iWidth;
+
+  if (BX_VGA_THIS s.vga_mem_updated==0) {
+    /* BX_DEBUG(("update(): updated=%u enabled=%u", (unsigned) BX_VGA_THIS s.vga_mem_updated, (unsigned) BX_VGA_THIS s.attribute_ctrl.video_enabled)); */
+    return;
+    }
+  BX_VGA_THIS s.vga_mem_updated = 0;
+
+#if BX_SUPPORT_VBE  
+  if (BX_VGA_THIS s.vbe_enabled)
+  {
+    // specific VBE code display update code
+    // this is partly copied/modified from the 320x200x8 update more below
+    unsigned xti, yti;
+    Bit8u color;
+    unsigned r, c;
+    unsigned long byte_offset;
+    unsigned long pixely, pixelx;
+    
+    iWidth=BX_VGA_THIS s.vbe_xres;
+    iHeight=BX_VGA_THIS s.vbe_yres;
+    
+    for (yti=0; yti<iHeight/Y_TILESIZE; yti++)
+      for (xti=0; xti<iWidth/X_TILESIZE; xti++) 
+      {
+        if (BX_VGA_THIS s.vga_tile_updated[xti][yti]) 
+        { 
+          for (r=0; r<Y_TILESIZE; r++) 
+          {
+            for (c=0; c<X_TILESIZE; c++) 
+            {
+              pixely = ((yti*Y_TILESIZE) + r);
+              pixelx = ((xti*X_TILESIZE) + c);    
+              
+              byte_offset = (pixely*iWidth) + (pixelx);
+              color = BX_VGA_THIS s.vbe_memory[byte_offset];
+              BX_VGA_THIS s.tile[r*X_TILESIZE + c] = color;
+            }
+          }
+          bx_gui.graphics_tile_update(BX_VGA_THIS s.tile,
+            xti*X_TILESIZE, yti*Y_TILESIZE);
+          BX_VGA_THIS s.vga_tile_updated[xti][yti] = 0;
+        }
+      }
+    
+    // after a vbe display update, don't try to do any 'normal vga' updates anymore
+    return;
+  }
+#endif  
   // fields that effect the way video memory is serialized into screen output:
   // GRAPHICS CONTROLLER:
   //   BX_VGA_THIS s.graphics_ctrl.shift_reg:
@@ -1161,11 +1241,6 @@
 //fprintf(stderr, "# update()");
 
   // if (BX_VGA_THIS s.vga_mem_updated==0 || BX_VGA_THIS s.attribute_ctrl.video_enabled == 0)
-  if (BX_VGA_THIS s.vga_mem_updated==0) {
-    /* BX_DEBUG(("update(): updated=%u enabled=%u", (unsigned) BX_VGA_THIS s.vga_mem_updated, (unsigned) BX_VGA_THIS s.attribute_ctrl.video_enabled)); */
-    return;
-    }
-  BX_VGA_THIS s.vga_mem_updated = 0;
 
   if (BX_VGA_THIS s.graphics_ctrl.graphics_alpha) {
     Bit8u color;
@@ -1458,6 +1533,13 @@
 {
   Bit32u offset;
 
+#if BX_SUPPORT_VBE  
+  // if in a vbe enabled mode, read from the vbe_memory
+  if (BX_VGA_THIS s.vbe_enabled)
+  {
+        return vbe_mem_read(addr);
+  }
+#endif  
 
 #if defined(VGA_TRACE_FEATURE)
 //	BX_DEBUG(("8-bit memory read from %08x", addr));
@@ -1578,6 +1660,15 @@
   Bit32u offset;
   Bit8u new_bit, new_val[4], cpu_data_b[4];
 
+#if BX_SUPPORT_VBE
+  // if in a vbe enabled mode, write to the vbe_memory
+  if (BX_VGA_THIS s.vbe_enabled)
+  {
+        vbe_mem_write(addr,value);
+        return;
+  }
+#endif
+
 #if defined(VGA_TRACE_FEATURE)
 //	BX_DEBUG(("8-bit memory write to %08x = %02x", addr, value));
 #endif
@@ -1983,3 +2074,156 @@
     BX_VGA_THIS s.vga_mem_updated = 1;
     }
 }
+
+
+#if BX_SUPPORT_VBE
+  Bit8u
+bx_vga_c::vbe_mem_read(Bit32u addr)
+{
+  Bit32u offset;        
+  offset = addr - 0xA0000;
+
+  return (BX_VGA_THIS s.vbe_memory[BX_VGA_THIS s.vbe_bank*65536 + offset]);
+}
+
+  void
+bx_vga_c::vbe_mem_write(Bit32u addr, Bit8u value)
+{
+  Bit32u offset;        
+  unsigned x_tileno, y_tileno;
+  offset = BX_VGA_THIS s.vbe_bank*65536 + (addr - 0xA0000);
+
+  y_tileno = (offset / BX_VGA_THIS s.vbe_xres) / Y_TILESIZE;
+  x_tileno = (offset % BX_VGA_THIS s.vbe_xres) / X_TILESIZE;
+  BX_VGA_THIS s.vga_mem_updated = 1;
+  BX_VGA_THIS s.vga_tile_updated[x_tileno][y_tileno] = 1;
+        
+  BX_VGA_THIS s.vbe_memory[offset]=value;
+}
+
+  Bit32u
+bx_vga_c::vbe_read_handler(void *this_ptr, Bit32u address, unsigned io_len)
+{
+#if !BX_USE_VGA_SMF
+  bx_vga_c *class_ptr = (bx_vga_c *) this_ptr;
+
+  return( class_ptr->vbe_read(address, io_len) );
+}
+
+
+  Bit32u
+bx_vga_c::vbe_read(Bit32u address, unsigned io_len)
+{
+#else
+  UNUSED(this_ptr);
+#endif  // !BX_USE_VGA_SMF
+
+//  BX_INFO(("VBE_read %x (len %x)", address, io_len));
+
+  if (address==VBE_DISPI_IOPORT_INDEX)
+  {
+    // index register
+    return (Bit32u) BX_VGA_THIS s.vbe_curindex;
+  }
+  else
+  {
+    // data register      
+    // FIXME: read from the data registers
+    switch (BX_VGA_THIS s.vbe_curindex)
+    {
+      case VBE_DISPI_INDEX_ID: // Display Interface ID check
+      {
+        return VBE_DISPI_ID0;
+      } break;
+
+      default:
+      {
+        BX_PANIC(("VBE unknown data read index 0x%x",BX_VGA_THIS s.vbe_curindex));
+      } break;
+    }      
+  }
+  BX_PANIC(("VBE_read shouldn't reach this"));
+}
+
+  void
+bx_vga_c::vbe_write_handler(void *this_ptr, Bit32u address, Bit32u value, unsigned io_len)
+{
+#if !BX_USE_VGA_SMF
+  bx_vga_c *class_ptr = (bx_vga_c *) this_ptr;
+
+  class_ptr->vbe_write(address, value, io_len);
+}
+
+  Bit32u
+bx_vga_c::vbe_write(Bit32u address, Bit32u value, unsigned io_len)
+{ 
+#else
+  UNUSED(this_ptr);
+#endif  
+
+//  BX_INFO(("VBE_write %x = %x (len %x)", address, value, io_len));
+  
+  if (address==VBE_DISPI_IOPORT_INDEX)
+  {
+    // index register
+    
+    BX_VGA_THIS s.vbe_curindex = (Bit16u) value;
+  }
+  else
+  {
+    // data register
+    // FIXME: maybe do some 'sanity' checks on received data?
+    
+    switch (BX_VGA_THIS s.vbe_curindex)
+    {
+      case VBE_DISPI_INDEX_ID: // Display Interface ID check
+      {
+        if (value != VBE_DISPI_ID0)
+        {
+          BX_PANIC(("VBE unknown Display Interface %x",value));
+        }
+        else
+        {
+          BX_INFO(("VBE known Display Interface %x",value));
+        }
+      } break;
+      
+      case VBE_DISPI_INDEX_XRES: // set xres
+      {
+        BX_VGA_THIS s.vbe_xres=(Bit16u) value;
+      } break;
+      
+      case VBE_DISPI_INDEX_YRES: // set yres
+      {
+        BX_VGA_THIS s.vbe_yres=(Bit16u) value;
+      } break;
+      
+      case VBE_DISPI_INDEX_BANK: // set bank
+      {
+        BX_INFO(("VBE set bank to %d", BX_VGA_THIS s.vbe_bank));
+        BX_VGA_THIS s.vbe_bank=(Bit16u) value & 0xff; // FIXME lobyte = vbe bank A?
+      } break;
+      
+      case VBE_DISPI_INDEX_ENABLE: // enable video
+      {
+        if (value)
+        {
+          BX_INFO(("VBE enabling x %d, y %d, bpp %d", BX_VGA_THIS s.vbe_xres, BX_VGA_THIS s.vbe_yres, BX_VGA_THIS s.vbe_bpp));
+          bx_gui.dimension_update(BX_VGA_THIS s.vbe_xres, BX_VGA_THIS s.vbe_yres);
+        }
+        else
+        {
+          BX_INFO(("VBE disabling"));
+        }     
+        BX_VGA_THIS s.vbe_enabled=(Boolean) value;
+      } break;
+
+      default:
+      {
+        BX_PANIC(("VBE unknown data write index 0x%x",BX_VGA_THIS s.vbe_curindex));
+      } break;      
+    }        
+  }
+}
+
+#endif
\ No newline at end of file


*** iodev/vga.h	4 Feb 2002 20:31:35 -0000	1.7
--- iodev/vga.h	9 Mar 2002 13:40:39 -0000
@@ -24,14 +24,48 @@
 //  License along with this library; if not, write to the Free Software
 //  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 
+#if BX_SUPPORT_VBE
+  #define VBE_DISPI_BANK_ADDRESS          0xA0000
+  #define VBE_DISPI_BANK_SIZE_KB          64
+  
+  #define VBE_DISPI_MAX_XRES              1024
+  #define VBE_DISPI_MAX_YRES              768
+  
+  #define VBE_DISPI_IOPORT_INDEX          0xFF80
+  #define VBE_DISPI_IOPORT_DATA           0xFF81
+  
+  #define VBE_DISPI_INDEX_ID              0x0
+  #define VBE_DISPI_INDEX_XRES            0x1
+  #define VBE_DISPI_INDEX_YRES            0x2
+  #define VBE_DISPI_INDEX_BPP             0x3
+  #define VBE_DISPI_INDEX_ENABLE          0x4
+  #define VBE_DISPI_INDEX_BANK            0x5
+  
+  #define VBE_DISPI_ID0                   0xB0C0
+  
+  #define VBE_DISPI_BPP_8                 0x0
+// The following is not support yet, but just for reference available.  
+//  #define VBE_DISPI_BPP_RGB565            0x1
+//  #define VBE_DISPI_BPP_RGB555            0x2
 
+  #define VBE_DISPI_DISABLED              0x00
+  #define VBE_DISPI_ENABLED               0x01
+
+#define BX_MAX_XRES VBE_DISPI_MAX_XRES
+#define BX_MAX_YRES VBE_DISPI_MAX_YRES
+
+#else
+
+#define BX_MAX_XRES 640
+#define BX_MAX_YRES 480
+
+#endif //BX_SUPPORT_VBE
 #define CGA_TEXT_ADDR(row, column) (0x18000 + ((row)*80 + (column))*2)
 
 #define X_TILESIZE 16
 #define Y_TILESIZE 16
-#define BX_NUM_X_TILES (640/X_TILESIZE)
-#define BX_NUM_Y_TILES (((65536 / (640/8)) / Y_TILESIZE) + 1)
-// #define BX_NUM_Y_TILES (480/Y_TILESIZE)
+#define BX_NUM_X_TILES (BX_MAX_XRES /X_TILESIZE)
+#define BX_NUM_Y_TILES (BX_MAX_YRES /Y_TILESIZE)
 
 // Support varying number of rows of text.  This used to
 // be limited to only 25 lines.
@@ -45,6 +79,7 @@
 #  define BX_VGA_THIS this->
 #endif
 
+
 class bx_vga_c : public logfunctions {
 public:
 
@@ -55,6 +90,12 @@
   // Note: either leave value of type Bit8u, or mask it when
   //       used to 8 bits, in memory.cc
   BX_VGA_SMF void   mem_write(Bit32u addr, Bit8u value);
+
+#if BX_SUPPORT_VBE 
+  BX_VGA_SMF Bit8u  vbe_mem_read(Bit32u addr);
+  BX_VGA_SMF void   vbe_mem_write(Bit32u addr, Bit8u value);  
+#endif
+  
   BX_VGA_SMF void   redraw_area(unsigned x0, unsigned y0,
                                 unsigned width, unsigned height);
 
@@ -64,6 +105,11 @@
   static void   write_handler(void *this_ptr, Bit32u address, Bit32u value, unsigned io_len);
   static void   write_handler_no_log(void *this_ptr, Bit32u address, Bit32u value, unsigned io_len);
 
+#if BX_SUPPORT_VBE
+  static Bit32u vbe_read_handler(void *this_ptr, Bit32u address, unsigned io_len);
+  static void   vbe_write_handler(void *this_ptr, Bit32u address, Bit32u value, unsigned io_len);
+#endif
+
   struct {
     struct {
       Boolean color_emulation;  // 1=color emulation, base address = 3Dx
@@ -168,6 +214,16 @@
     unsigned vert_tick;
     Bit8u rgb[3 * 256];
     Bit8u tile[X_TILESIZE * Y_TILESIZE];
+
+#if BX_SUPPORT_VBE    
+    Bit8u vbe_memory[1024 * 1024];
+    Bit16u  vbe_xres;
+    Bit16u  vbe_yres;
+    Bit16u  vbe_bpp;
+    Bit16u  vbe_bank;
+    Boolean vbe_enabled;
+    Bit16u  vbe_curindex;
+#endif    
     } s;  // state information
 
 
@@ -179,6 +235,16 @@
 #else
   void write(Bit32u address, Bit32u value, unsigned io_len, Boolean no_log);
 #endif
+
+#if BX_SUPPORT_VBE
+#if !BX_USE_VGA_SMF
+  Bit32u vbe_read(Bit32u address, unsigned io_len);
+  void   vbe_write(Bit32u address, Bit32u value, unsigned io_len, Boolean no_log);
+#else
+  void vbe_write(Bit32u address, Bit32u value, unsigned io_len, Boolean no_log);
+#endif
+#endif
+
   int timer_id;
 
   public:


