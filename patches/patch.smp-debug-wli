? debug/Makefile
? debug/.dbg_main.cc.swp
Index: debug/dbg_main.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/debug/dbg_main.cc,v
retrieving revision 1.38
diff -u -r1.38 dbg_main.cc
--- debug/dbg_main.cc	12 Mar 2002 09:16:40 -0000	1.38
+++ debug/dbg_main.cc	20 Mar 2002 02:47:18 -0000
@@ -416,14 +416,17 @@
   // Print disassembly of the first instruction...  you wouldn't think it
   // would have to be so hard.  First initialize guard_found, since it is used
   // in the disassembly code to decide what instruction to print.
-  BX_CPU_THIS_PTR guard_found.cs =
-    BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value;
-  BX_CPU_THIS_PTR guard_found.eip =
-    BX_CPU_THIS_PTR prev_eip;
-  BX_CPU_THIS_PTR guard_found.laddr =
-    BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].cache.u.segment.base + BX_CPU_THIS_PTR prev_eip;
-  BX_CPU_THIS_PTR guard_found.is_32bit_code =
-    BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].cache.u.segment.d_b;
+  for (i=0; i<BX_SMP_PROCESSORS; i++) {
+    BX_CPU(i)->guard_found.cs =
+      BX_CPU(i)->sregs[BX_SEG_REG_CS].selector.value;
+    BX_CPU(i)->guard_found.eip =
+      BX_CPU(i)->prev_eip;
+    BX_CPU(i)->guard_found.laddr =
+      BX_CPU(i)->sregs[BX_SEG_REG_CS].cache.u.segment.base
+        + BX_CPU(i)->prev_eip;
+    BX_CPU(i)->guard_found.is_32bit_code =
+      BX_CPU(i)->sregs[BX_SEG_REG_CS].cache.u.segment.d_b;
+  }
   // finally, call the usual function to print the disassembly
   fprintf (stderr, "Next at t=%lld\n", bx_pc_system.time_ticks ());
   bx_dbg_disassemble_current (-1, 0);  // all cpus, don't print time
