----------------------------------------------------------------------
Patch name: patch.triple-fault-recover
Author: Bryce Denney
Date: Tue Mar 12 01:10:48 EST 2002

Detailed description:
See SF bug [ #526484 ] simulator dumps core

When a triple fault occurs, Bochs panics.  If you continue through the panic,
it will generally produce another exception and panic again at an even deeper
stack level.  To recover from this potentially infinite recursion, I set
a boolean variable called special_unwind_stack to true.  This variable causes
the interrupt() and exception() functions to return immediately instead of
creating more exception conditions, and allows the user to reenter the debugger
after the triple fault.  Note that special_unwind_stack causes bochs to NOT
emulate the hardware behavior correctly.  The correct behavior would be to
reboot.  (Rebooting, if it is ever implemented, will need some kind of
unwinding too.)

Patch was created with:
  cvs diff -u
Apply patch to what version:
  current cvs
Instructions:
  To patch, go to main bochs directory.
  Type "patch -p0 < THIS_PATCH_FILE".
----------------------------------------------------------------------
? debug/Makefile
? debug/.debug.h.swp
? cpu/Makefile
Index: debug/dbg_main.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/debug/dbg_main.cc,v
retrieving revision 1.37
diff -u -r1.37 dbg_main.cc
--- debug/dbg_main.cc	15 Feb 2002 22:58:06 -0000	1.37
+++ debug/dbg_main.cc	12 Mar 2002 09:11:00 -0000
@@ -1520,6 +1520,7 @@
 
 #if BX_NUM_SIMULATORS >= 2
   bx_guard.interrupt_requested = 0;
+  bx_guard.special_unwind_stack = 0;
   while (1) {
     if ( !bx_dbg_cosimulateN(bx_debugger.icount_quantum) )
       break;
@@ -1533,6 +1534,7 @@
 
 
   bx_guard.interrupt_requested = 0;
+  bx_guard.special_unwind_stack = 0;
 	int stop = 0;
 	int which = -1;
 	while (!stop) {
@@ -1608,6 +1610,7 @@
 
 #if BX_NUM_SIMULATORS >= 2
   bx_guard.interrupt_requested = 0;
+  bx_guard.special_unwind_stack = 0;
   bx_dbg_cosimulateN(count);
 #else
   // single CPU
Index: debug/debug.h
===================================================================
RCS file: /cvsroot/bochs/bochs/debug/debug.h,v
retrieving revision 1.10
diff -u -r1.10 debug.h
--- debug/debug.h	28 Nov 2001 18:37:12 -0000	1.10
+++ debug/debug.h	12 Mar 2002 09:11:00 -0000
@@ -257,6 +257,18 @@
   // user typed Ctrl-C, requesting simulator stop at next convient spot
   volatile Boolean interrupt_requested;
 
+  // when a triple fault occurs, Bochs panics.  If you continue through
+  // the panic, it will generally produce another exception and panic
+  // again at an even deeper stack level.  To recover from this potentially
+  // infinite recursion, I set special_unwind_stack to true.  This causes
+  // the interrupt() and exception() functions to return immediately instead
+  // of creating more exception conditions, and allows the user to reenter the
+  // debugger after the triple fault.  Note that special_unwind_stack causes
+  // bochs to NOT emulate the hardware behavior correctly.  The correct
+  // behavior would be to reboot.  (Rebooting, if it is ever implemented,
+  // will need some kind of unwinding too.)
+  Boolean special_unwind_stack;
+
   // booleans to control whether simulator should report events
   // to debug controller
   struct {
Index: cpu/exception.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/cpu/exception.cc,v
retrieving revision 1.9
diff -u -r1.9 exception.cc
--- cpu/exception.cc	3 Oct 2001 13:10:37 -0000	1.9
+++ cpu/exception.cc	12 Mar 2002 09:11:01 -0000
@@ -63,6 +63,10 @@
 #endif
 #endif
 
+  if (bx_guard.special_unwind_stack) {
+    BX_INFO (("interrupt() returning early because special_unwind_stack is set"));
+    return;
+  }
 //BX_DEBUG(( "::interrupt(%u)", vector ));
 
   BX_INSTR_INTERRUPT(vector);
@@ -572,6 +576,11 @@
   Bit8u    exception_type;
   unsigned prev_errno;
 
+  if (bx_guard.special_unwind_stack) {
+    BX_INFO (("exception() returning early because special_unwind_stack is set"));
+    return;
+  }
+
 //BX_DEBUG(( "::exception(%u)", vector ));
 
   BX_INSTR_EXCEPTION(vector);
@@ -593,6 +602,9 @@
   BX_CPU_THIS_PTR errorno++;
   if (BX_CPU_THIS_PTR errorno >= 3) {
     BX_PANIC(("exception(): 3rd exception with no resolution"));
+    BX_ERROR(("WARNING: Any simulation after this point is completely bogus."));
+    bx_guard.special_unwind_stack = true;
+    return;
     }
 
   /* careful not to get here with curr_exception[1]==DOUBLE_FAULT */
@@ -600,7 +612,10 @@
 
   /* if 1st was a double fault (software INT?), then shutdown */
   if ( (BX_CPU_THIS_PTR errorno==2) && (BX_CPU_THIS_PTR curr_exception[0]==BX_ET_DOUBLE_FAULT) ) {
-    BX_PANIC(("exception(): tripple fault encountered"));
+    BX_PANIC(("exception(): triple fault encountered"));
+    BX_ERROR(("WARNING: Any simulation after this point is completely bogus."));
+    bx_guard.special_unwind_stack = true;
+    return;
     }
 
   /* ??? this is not totally correct, should be done depending on
