----------------------------------------------------------------------
Patch name: patch.win32-toolbar
Author: Volker Ruppert
Date: August 10th 2002

Detailed description:
  This patch replaces the standard headerbar by a real win32 toolbar using
  the existing bitmaps. The bochs window now consists of 3 windows: the main
  window and it's child windows simulation window and toolbar window.


  Here is the list of changes:

  - new windows "mainWnd" and "simWnd" replace the old "hwnd"
  - moved the functions of the old window procedure to the new ones
  - toolbar functions added in create_bitmap(), headerbar_bitmap() and
    replace_bitmap()
  - function show_headerbar() no longer needed (must be present for
    compatibility)
  - a few variables for the headerbar changed or removed
  - bitmap and headerbar variables now initialized in specific_init()

Patch was created with:
  diff -u
Apply patch to what version:
  cvs checked out on DATE
Instructions:
  To patch, go to main bochs directory.
  Type "patch -p0 < THIS_PATCH_FILE".
----------------------------------------------------------------------
--- ../bochs/gui/win32.cc	Fri Aug  9 22:25:02 2002
+++ gui/win32.cc	Sat Aug 10 10:21:49 2002
@@ -32,6 +32,7 @@
 #include "icon_bochs.h"
 #include "font/vga.bitmap.h"
 #include <windows.h>
+#include <commctrl.h>
 #include <process.h>
 
 #define LOG_THIS bx_gui.
@@ -70,7 +71,7 @@
 static int ms_xdelta=0, ms_ydelta=0;
 static int ms_lastx=0, ms_lasty=0;
 static int ms_savedx=0, ms_savedy=0;
-static BOOL mouseCaptureMode = FALSE;
+static BOOL mouseCaptureMode;
 static unsigned long workerThread = NULL;
 static DWORD workerThreadID = 0;
 
@@ -88,7 +89,8 @@
 HBITMAP cursorBmp;
 
 // Headerbar stuff
-unsigned bx_bitmap_entries = 0;
+HWND hwndTB;
+unsigned bx_bitmap_entries;
 struct {
   HBITMAP bmap;
   unsigned xdim;
@@ -96,20 +98,13 @@
 } bx_bitmaps[BX_MAX_PIXMAPS];
 
 static struct {
-  HBITMAP bitmap;
-  unsigned xdim;
-  unsigned ydim;
-  unsigned xorigin;
-  unsigned yorigin;
-  unsigned alignment;
+  unsigned bmap_id;
   void (*f)(void);
 } bx_headerbar_entry[BX_MAX_HEADERBAR_ENTRIES];
 
 static unsigned bx_headerbar_y = 0;
-static unsigned bx_headerbar_entries = 0;
-static unsigned bx_bitmap_left_xorigin = 0;   // pixels from left
-static unsigned bx_bitmap_right_xorigin = 0;  // pixels from right
-static BOOL headerbar_changed = FALSE;
+static unsigned bx_headerbar_entries;
+static unsigned bx_hb_separator;
 
 // Misc stuff
 static unsigned dimension_x, dimension_y;
@@ -135,12 +130,14 @@
 
   int kill;  // reason for terminateEmul(int)
   BOOL UIinited;
-  HWND hwnd;
+  HWND mainWnd;
+  HWND simWnd;
 } sharedThreadInfo;
 
 sharedThreadInfo stInfo;
 
-LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM);
+LRESULT CALLBACK mainWndProc (HWND, UINT, WPARAM, LPARAM);
+LRESULT CALLBACK simWndProc (HWND, UINT, WPARAM, LPARAM);
 VOID UIThread(PVOID);
 void terminateEmul(int);
 void create_vga_font(void);
@@ -225,6 +222,7 @@
     DeleteCriticalSection (&stInfo.keyCS);
     DeleteCriticalSection (&stInfo.mouseCS);
   }
+  x_tilesize = 0;
 
   if (MemoryDC) DeleteDC (MemoryDC);
   if (MemoryBitmap) DeleteObject (MemoryBitmap);
@@ -290,11 +288,16 @@
   x_tilesize = tilewidth;
   y_tilesize = tileheight;
 
+  bx_bitmap_entries = 0;
+  bx_headerbar_entries = 0;
+  bx_hb_separator = 0;
+  mouseCaptureMode = FALSE;
+
   stInfo.hInstance = GetModuleHandle(NULL);
 
-  bx_headerbar_y = headerbar_y;
+  UNUSED(headerbar_y);
   dimension_x = 640;
-  dimension_y = 800 + bx_headerbar_y;
+  dimension_y = 480;
   stretched_x = dimension_x;
   stretched_y = dimension_y;
   stretch_factor = 1;
@@ -358,53 +361,95 @@
   MSG msg;
   HDC hdc;
   WNDCLASSEX wndclass;
-  RECT wndRect;
+  RECT wndRect, wndRect2;
 
   workerThreadID = GetCurrentThreadId();
 
   wndclass.cbSize = sizeof (wndclass);
   wndclass.style = CS_HREDRAW | CS_VREDRAW;
-  wndclass.lpfnWndProc = WndProc;
+  wndclass.lpfnWndProc = mainWndProc;
   wndclass.cbClsExtra = 0;
   wndclass.cbWndExtra = 0;
   wndclass.hInstance = stInfo.hInstance;
   wndclass.hIcon = LoadIcon (NULL, IDI_APPLICATION);
   wndclass.hCursor = LoadCursor (NULL, IDC_ARROW);
-  wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH);
+  wndclass.hbrBackground = (HBRUSH) GetStockObject (BLACK_BRUSH);
   wndclass.lpszMenuName = NULL;
   wndclass.lpszClassName = szAppName;
   wndclass.hIconSm = LoadIcon (NULL, IDI_APPLICATION);
 
   RegisterClassEx (&wndclass);
 
-  stInfo.hwnd = CreateWindow (szAppName,
-			      szWindowName,
-			      WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX,
-			      CW_USEDEFAULT,
-			      CW_USEDEFAULT,
-			      dimension_x + x_edge * 2,
-			      dimension_y + y_edge * 2 + y_caption,
-			      NULL,
-			      NULL,
-			      stInfo.hInstance,
-			      NULL);
-
-  if (stInfo.hwnd) {
-    ShowWindow (stInfo.hwnd, SW_SHOW);
-    SetWindowPos (stInfo.hwnd, NULL, 0, 0, stretched_x + x_edge * 2,
-                  480 + y_edge * 2 + y_caption, SWP_NOMOVE|SWP_NOZORDER);
-    UpdateWindow (stInfo.hwnd);
+  wndclass.cbSize = sizeof (wndclass);
+  wndclass.style = CS_HREDRAW | CS_VREDRAW;
+  wndclass.lpfnWndProc = simWndProc;
+  wndclass.cbClsExtra = 0;
+  wndclass.cbWndExtra = 0;
+  wndclass.hInstance = stInfo.hInstance;
+  wndclass.hIcon = LoadIcon (NULL, IDI_APPLICATION);
+  wndclass.hCursor = LoadCursor (NULL, IDC_ARROW);
+  wndclass.hbrBackground = (HBRUSH) GetStockObject (BLACK_BRUSH);
+  wndclass.lpszMenuName = NULL;
+  wndclass.lpszClassName = "SIMWINDOW";
+  wndclass.hIconSm = NULL;
+
+  RegisterClassEx (&wndclass);
+
+  stInfo.mainWnd = CreateWindow (szAppName,
+                     szWindowName,
+                     WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX,
+                     CW_USEDEFAULT,
+                     CW_USEDEFAULT,
+                     dimension_x + x_edge * 2,
+                     dimension_y + y_edge * 2 + y_caption,
+                     NULL,
+                     NULL,
+                     stInfo.hInstance,
+                     NULL);
+
+  if (stInfo.mainWnd) {
+    ShowWindow (stInfo.mainWnd, SW_SHOW);
+
+    hwndTB = CreateWindowEx(0, TOOLBARCLASSNAME, (LPSTR) NULL,
+               WS_CHILD | CCS_ADJUSTABLE, 0, 0, 0, 0, stInfo.mainWnd,
+               (HMENU) 100, stInfo.hInstance, NULL);
+    SendMessage(hwndTB, TB_BUTTONSTRUCTSIZE, (WPARAM) sizeof(TBBUTTON), 0);
+    SendMessage(hwndTB, TB_SETBITMAPSIZE, 0, (LPARAM)MAKELONG(32, 32));
+    ShowWindow(hwndTB, SW_SHOW);
+    GetClientRect(stInfo.mainWnd, &wndRect);
+    GetClientRect(hwndTB, &wndRect2);
+    bx_headerbar_y = wndRect2.bottom - wndRect2.top;
+    SetWindowPos(stInfo.mainWnd, NULL, 0, 0, stretched_x + x_edge * 2,
+                  stretched_y + bx_headerbar_y + y_edge * 2 + y_caption,
+                  SWP_NOMOVE|SWP_NOZORDER);
+    UpdateWindow (stInfo.mainWnd);
+
+    stInfo.simWnd = CreateWindow("SIMWINDOW",
+                      "",
+                      WS_CHILD,
+                      0,
+                      bx_headerbar_y,
+                      wndRect.right - wndRect.left,
+                      wndRect.bottom - wndRect.top - bx_headerbar_y,
+                      stInfo.mainWnd,
+                      NULL,
+                      stInfo.hInstance,
+                      NULL);
+
+    ShowWindow(stInfo.simWnd, SW_SHOW);
+    UpdateWindow (stInfo.simWnd);
+    SetFocus(stInfo.simWnd);
 
     ShowCursor(!mouseCaptureMode);
-    GetWindowRect(stInfo.hwnd, &wndRect);
+    GetWindowRect(stInfo.mainWnd, &wndRect);
     SetCursorPos(wndRect.left + stretched_x/2 + x_edge,
       wndRect.top + stretched_y/2 + y_edge + y_caption);
     cursorWarped();
 
-    hdc = GetDC(stInfo.hwnd);
+    hdc = GetDC(stInfo.simWnd);
     MemoryBitmap = CreateCompatibleBitmap(hdc, BX_MAX_XRES, BX_MAX_YRES);
     MemoryDC = CreateCompatibleDC(hdc);
-    ReleaseDC(stInfo.hwnd, hdc);
+    ReleaseDC(stInfo.simWnd, hdc);
 
     if (MemoryBitmap && MemoryDC) {
       stInfo.UIinited = TRUE;
@@ -422,7 +467,43 @@
 }
 
 
-LRESULT CALLBACK WndProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam) {
+LRESULT CALLBACK mainWndProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam) {
+
+  switch (iMsg) {
+  case WM_CREATE:
+    bx_options.Omouse_enabled->set (mouseCaptureMode);
+    if (mouseCaptureMode)
+      SetWindowText(hwnd, "Bochs for Windows      [F12 to release mouse]");
+    else
+      SetWindowText(hwnd, "Bochs for Windows      [F12 enables mouse]");
+    return 0;
+
+  case WM_COMMAND:
+    if (LOWORD(wParam) >= 101) {
+      EnterCriticalSection(&stInfo.keyCS);
+      enq_key_event(LOWORD(wParam)-101, HEADERBAR_CLICKED);
+      LeaveCriticalSection(&stInfo.keyCS);
+    }
+    break;
+
+  case WM_SETFOCUS:
+    SetFocus(stInfo.simWnd);
+    return 0;
+
+  case WM_CLOSE:
+    SendMessage(stInfo.simWnd, WM_CLOSE, 0, 0);
+    break;
+
+  case WM_DESTROY:
+    PostQuitMessage (0);
+    return 0;
+
+  }
+  return DefWindowProc (hwnd, iMsg, wParam, lParam);
+}
+
+
+LRESULT CALLBACK simWndProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam) {
   HDC hdc, hdcMem;
   PAINTSTRUCT ps;
   RECT wndRect;
@@ -432,11 +513,6 @@
   case WM_CREATE:
     InitFont();
     SetTimer (hwnd, 1, 330, NULL);
-    bx_options.Omouse_enabled->set (mouseCaptureMode);
-    if (mouseCaptureMode)
-      SetWindowText(hwnd, "Bochs for Windows      [F12 to release mouse]");
-    else
-      SetWindowText(hwnd, "Bochs for Windows      [F12 enables mouse]");
     return 0;
 
   case WM_TIMER:
@@ -449,7 +525,7 @@
       cursorWarped();
     }
     bx_options.Omouse_enabled->set (mouseCaptureMode);
-    
+
     return 0;
 
   case WM_PAINT:
@@ -476,15 +552,6 @@
 
   case WM_LBUTTONDOWN:
   case WM_LBUTTONDBLCLK:
-    if (HIWORD(lParam) < BX_HEADER_BAR_Y * stretch_factor) {
-      EnterCriticalSection(&stInfo.keyCS);
-      enq_key_event(LOWORD(lParam)/stretch_factor, HEADERBAR_CLICKED);
-      LeaveCriticalSection(&stInfo.keyCS);
-    }
-    processMouseXY( LOWORD(lParam), HIWORD(lParam), wParam, 1);
-
-    return 0;
-
   case WM_LBUTTONUP:
     processMouseXY( LOWORD(lParam), HIWORD(lParam), wParam, 1);
     return 0;
@@ -501,8 +568,6 @@
     KillTimer (hwnd, 1);
     stInfo.UIinited = FALSE;
     DestroyFont();
-
-    PostQuitMessage (0);
     return 0;
 
   case WM_KEYDOWN:
@@ -517,9 +582,9 @@
                    wndRect.top + stretched_y/2 + y_edge + y_caption);
       cursorWarped();
       if (mouseCaptureMode)
-	SetWindowText(hwnd, "Bochs for Windows      [Press F12 to release mouse capture]");
+        SetWindowText(stInfo.mainWnd, "Bochs for Windows      [Press F12 to release mouse capture]");
       else
-	SetWindowText(hwnd, "Bochs for Windows      [F12 enables the mouse in Bochs]");
+        SetWindowText(stInfo.mainWnd, "Bochs for Windows      [F12 enables the mouse in Bochs]");
     } else {
       EnterCriticalSection(&stInfo.keyCS);
       enq_key_event(HIWORD (lParam) & 0x01FF, BX_KEY_PRESSED);
@@ -545,7 +610,7 @@
 }
 
 
-void enq_key_event(Bit32u key, Bit32u press_release) {	
+void enq_key_event(Bit32u key, Bit32u press_release) {
   if (((tail+1) % SCANCODE_BUFSIZE) == head) {
     BX_ERROR(( "enq_scancode: buffer full"));
     return;
@@ -663,7 +728,7 @@
     // slight bugfix
 	updated_area.right++;
 	updated_area.bottom++;
-	InvalidateRect( stInfo.hwnd, &updated_area, FALSE);
+	InvalidateRect( stInfo.simWnd, &updated_area, FALSE);
 	updated_area_valid = FALSE;
   }
   LeaveCriticalSection( &stInfo.drawCS);
@@ -683,11 +748,10 @@
   EnterCriticalSection(&stInfo.drawCS);
 
   oldObj = SelectObject(MemoryDC, MemoryBitmap);
-  PatBlt(MemoryDC, 0, bx_headerbar_y, stretched_x, stretched_y -
-         bx_headerbar_y, BLACKNESS);
+  PatBlt(MemoryDC, 0, 0, stretched_x, stretched_y, BLACKNESS);
   SelectObject(MemoryDC, oldObj);
 
-  updateUpdated(0, bx_headerbar_y, dimension_x-1, dimension_y-1);
+  updateUpdated(0, 0, dimension_x-1, dimension_y-1);
 
   LeaveCriticalSection(&stInfo.drawCS);
 }
@@ -729,7 +793,7 @@
 
   EnterCriticalSection(&stInfo.drawCS);
 
-  hdc = GetDC(stInfo.hwnd);
+  hdc = GetDC(stInfo.simWnd);
 
   ncols = dimension_x/8;
 
@@ -740,11 +804,11 @@
     cChar = new_text[(prev_block_cursor_y*ncols + prev_block_cursor_x)*2];
     if (yChar >= 16) {
       DrawBitmap(hdc, vgafont[cChar], prev_block_cursor_x*8,
-	              prev_block_cursor_y*16 + bx_headerbar_y, SRCCOPY,
+	              prev_block_cursor_y*16, SRCCOPY,
 				  new_text[((prev_block_cursor_y*ncols + prev_block_cursor_x)*2)+1]);
     } else {
       DrawChar(hdc, cChar, prev_block_cursor_x*8,
-               prev_block_cursor_y*yChar + bx_headerbar_y,
+               prev_block_cursor_y*yChar,
                new_text[((prev_block_cursor_y*ncols + prev_block_cursor_x)*2)+1], 1, 0);
     }
   }
@@ -758,9 +822,9 @@
       x = (i/2) % ncols;
       y = (i/2) / ncols;
       if(yChar>=16) {
-        DrawBitmap(hdc, vgafont[cChar], x*8, y*16 + bx_headerbar_y, SRCCOPY, new_text[i+1]);
+        DrawBitmap(hdc, vgafont[cChar], x*8, y*16, SRCCOPY, new_text[i+1]);
       } else {
-        DrawChar(hdc, cChar, x*8, y*yChar + bx_headerbar_y, new_text[i+1], 1, 0);
+        DrawChar(hdc, cChar, x*8, y*yChar, new_text[i+1], 1, 0);
       }
     }
   }
@@ -780,15 +844,15 @@
           data[i*2] = 255 - data[i*2];
       }
       SetBitmapBits(cursorBmp, 32, data);
-      DrawBitmap(hdc, cursorBmp, cursor_x*8, cursor_y*16 + bx_headerbar_y,
+      DrawBitmap(hdc, cursorBmp, cursor_x*8, cursor_y*16,
 	         SRCCOPY, new_text[((cursor_y*ncols + cursor_x)*2)+1]);
     } else {
       char cAttr = new_text[((cursor_y*ncols + cursor_x)*2)+1];
-      DrawChar(hdc, cChar, cursor_x*8, cursor_y*yChar + bx_headerbar_y, cAttr, cs_start, cs_end);
+      DrawChar(hdc, cChar, cursor_x*8, cursor_y*yChar, cAttr, cs_start, cs_end);
     }
   }
 
-  ReleaseDC(stInfo.hwnd, hdc);
+  ReleaseDC(stInfo.simWnd, hdc);
 
   LeaveCriticalSection(&stInfo.drawCS);
 }
@@ -796,7 +860,7 @@
   int
 bx_gui_c::get_clipboard_text(Bit8u **bytes, Bit32s *nbytes)
 {
-  if (OpenClipboard(stInfo.hwnd)) {
+  if (OpenClipboard(stInfo.simWnd)) {
     HGLOBAL hg = GetClipboardData(CF_TEXT);
     char *data = (char *)GlobalLock(hg);
     *nbytes = strlen(data);
@@ -816,7 +880,7 @@
   int
 bx_gui_c::set_clipboard_text(char *text_snapshot, Bit32u len)
 {
-  if (OpenClipboard(stInfo.hwnd)) {
+  if (OpenClipboard(stInfo.simWnd)) {
     HANDLE hMem = GlobalAlloc(GMEM_ZEROINIT, len);
     EmptyClipboard();
     lstrcpy((char *)hMem, text_snapshot);
@@ -865,23 +929,20 @@
 void bx_gui_c::graphics_tile_update(Bit8u *tile, unsigned x0, unsigned y0) {
   HDC hdc;
   HGDIOBJ oldObj;
-  unsigned true_y0;
-
-  true_y0 = y0 + bx_headerbar_y;
 
   EnterCriticalSection(&stInfo.drawCS);
-  hdc = GetDC(stInfo.hwnd);
+  hdc = GetDC(stInfo.simWnd);
 
   oldObj = SelectObject(MemoryDC, MemoryBitmap);
 
-  StretchDIBits( MemoryDC, x0, true_y0, x_tilesize, y_tilesize, 0, 0,
+  StretchDIBits( MemoryDC, x0, y0, x_tilesize, y_tilesize, 0, 0,
     x_tilesize, y_tilesize, tile, bitmap_info, DIB_RGB_COLORS, SRCCOPY);
 
   SelectObject(MemoryDC, oldObj);
 
-  updateUpdated(x0, true_y0, x0 + x_tilesize - 1, true_y0 + y_tilesize - 1);
+  updateUpdated(x0, y0, x0 + x_tilesize - 1, y0 + y_tilesize - 1);
 
-  ReleaseDC(stInfo.hwnd, hdc);
+  ReleaseDC(stInfo.simWnd, hdc);
   LeaveCriticalSection(&stInfo.drawCS);
 }
 
@@ -912,10 +973,10 @@
     y = y * yChar / fheight;
   }
 
-  if ( x==dimension_x && y+bx_headerbar_y==dimension_y)
+  if ( x==dimension_x && y==dimension_y)
     return;
   dimension_x = x;
-  dimension_y = y + bx_headerbar_y;
+  dimension_y = y;
   stretched_x = dimension_x;
   stretched_y = dimension_y;
   stretch_factor = 1;
@@ -926,11 +987,10 @@
     stretch_factor *= 2;
   }
 
-  SetWindowPos(stInfo.hwnd, HWND_TOP, 0, 0, stretched_x + x_edge * 2,
-              stretched_y+ y_edge * 2 + y_caption,
+  SetWindowPos(stInfo.mainWnd, HWND_TOP, 0, 0, stretched_x + x_edge * 2,
+              stretched_y + bx_headerbar_y + y_edge * 2 + y_caption,
                SWP_NOMOVE | SWP_NOZORDER);
-  headerbar_changed = TRUE;
-  show_headerbar();
+  MoveWindow(stInfo.simWnd, 0, bx_headerbar_y, stretched_x, stretched_y, TRUE);
 }
 
 
@@ -948,6 +1008,7 @@
 unsigned bx_gui_c::create_bitmap(const unsigned char *bmap, unsigned xdim,
 				 unsigned ydim) {
   unsigned char *data;
+  TBADDBITMAP tbab;
 
   if (bx_bitmap_entries >= BX_MAX_PIXMAPS)
     terminateEmul(EXIT_HEADER_BITMAP_ERROR);
@@ -958,7 +1019,7 @@
 
   data = new unsigned char[ydim * xdim/8];
   for (unsigned i=0; i<ydim * xdim/8; i++)
-    data[i] = reverse_bitorder(bmap[i]);
+    data[i] = 255 - reverse_bitorder(bmap[i]);
   SetBitmapBits(bx_bitmaps[bx_bitmap_entries].bmap, ydim * xdim/8, data);
   delete [] data;
   data = NULL;
@@ -966,6 +1027,10 @@
   bx_bitmaps[bx_bitmap_entries].xdim = xdim;
   bx_bitmaps[bx_bitmap_entries].ydim = ydim;
 
+  tbab.hInst = NULL;
+  tbab.nID = (UINT)bx_bitmaps[bx_bitmap_entries].bmap;
+  SendMessage(hwndTB, TB_ADDBITMAP, 1, (LPARAM)&tbab);
+
   bx_bitmap_entries++;
   return(bx_bitmap_entries-1); // return index as handle
 }
@@ -988,6 +1053,8 @@
 unsigned bx_gui_c::headerbar_bitmap(unsigned bmap_id, unsigned alignment,
 				    void (*f)(void)) {
   unsigned hb_index;
+  TBBUTTON tbb[1];
+  RECT R;
 
   if ( (bx_headerbar_entries+1) > BX_MAX_HEADERBAR_ENTRIES )
     terminateEmul(EXIT_HEADER_BITMAP_ERROR);
@@ -995,22 +1062,32 @@
   bx_headerbar_entries++;
   hb_index = bx_headerbar_entries - 1;
 
-  bx_headerbar_entry[hb_index].bitmap = bx_bitmaps[bmap_id].bmap;
-  bx_headerbar_entry[hb_index].xdim   = bx_bitmaps[bmap_id].xdim;
-  bx_headerbar_entry[hb_index].ydim   = bx_bitmaps[bmap_id].ydim;
-  bx_headerbar_entry[hb_index].alignment = alignment;
-  bx_headerbar_entry[hb_index].f = f;
+  memset(tbb,0,sizeof(tbb));
+  if (bx_hb_separator==0) {
+    tbb[0].iBitmap = 0;
+    tbb[0].idCommand = 0;
+    tbb[0].fsState = 0;
+    tbb[0].fsStyle = TBSTYLE_SEP;
+    SendMessage(hwndTB, TB_ADDBUTTONS, 1,(LPARAM)(LPTBBUTTON)&tbb);
+  }
+  tbb[0].iBitmap = bmap_id;
+  tbb[0].idCommand = hb_index + 101;
+  tbb[0].fsState = TBSTATE_ENABLED;
+  tbb[0].fsStyle = TBSTYLE_BUTTON;
   if (alignment == BX_GRAVITY_LEFT) {
-    bx_headerbar_entry[hb_index].xorigin = bx_bitmap_left_xorigin;
-    bx_headerbar_entry[hb_index].yorigin = 0;
-    bx_bitmap_left_xorigin += bx_bitmaps[bmap_id].xdim;
+    SendMessage(hwndTB, TB_INSERTBUTTON, bx_hb_separator,(LPARAM)(LPTBBUTTON)&tbb);
+    bx_hb_separator++;
   } else { // BX_GRAVITY_RIGHT
-    bx_bitmap_right_xorigin += bx_bitmaps[bmap_id].xdim;
-    bx_headerbar_entry[hb_index].xorigin = bx_bitmap_right_xorigin;
-    bx_headerbar_entry[hb_index].yorigin = 0;
+    SendMessage(hwndTB, TB_INSERTBUTTON, bx_hb_separator+1, (LPARAM)(LPTBBUTTON)&tbb);
+  }
+  if (hb_index==0) {
+    SendMessage(hwndTB, TB_AUTOSIZE, 0, 0);
+    GetWindowRect(hwndTB, &R);
+    bx_headerbar_y = R.bottom - R.top + 1;
   }
 
-  headerbar_changed = TRUE;
+  bx_headerbar_entry[hb_index].bmap_id = bmap_id;
+  bx_headerbar_entry[hb_index].f = f;
 
   return(hb_index);
 }
@@ -1021,32 +1098,8 @@
 // Show (redraw) the current headerbar, which is composed of
 // currently installed bitmaps.
 
-void bx_gui_c::show_headerbar(void) {
-  unsigned xorigin;
-  HGDIOBJ oldObj;
-
-  if (!headerbar_changed || !stInfo.UIinited) return;
-	
-  EnterCriticalSection(&stInfo.drawCS);
-	
-  oldObj = SelectObject(MemoryDC, MemoryBitmap);
-  PatBlt (MemoryDC, 0, 0, dimension_x, bx_headerbar_y, BLACKNESS);
-	
-  for (unsigned i=0; i<bx_headerbar_entries; i++) {
-    if (bx_headerbar_entry[i].alignment == BX_GRAVITY_LEFT)
-      xorigin = bx_headerbar_entry[i].xorigin;
-    else
-      xorigin = dimension_x - bx_headerbar_entry[i].xorigin;
-    DrawBitmap(MemoryDC, bx_headerbar_entry[i].bitmap, xorigin, 0, SRCCOPY, 0x7);
-  }
-
-  SelectObject(MemoryDC, oldObj);
-
-  updateUpdated(0, 0, dimension_x-1, bx_headerbar_y-1);
-
-  LeaveCriticalSection(&stInfo.drawCS);
-
-  headerbar_changed = FALSE;
+void bx_gui_c::show_headerbar(void)
+{
 }
 
 
@@ -1063,10 +1116,13 @@
 // hbar_id: headerbar slot ID
 // bmap_id: bitmap ID
 
-void bx_gui_c::replace_bitmap(unsigned hbar_id, unsigned bmap_id) {
-  headerbar_changed = TRUE;
-  bx_headerbar_entry[hbar_id].bitmap = bx_bitmaps[bmap_id].bmap;
-  show_headerbar();
+void bx_gui_c::replace_bitmap(unsigned hbar_id, unsigned bmap_id)
+{
+  if (bmap_id != bx_headerbar_entry[hbar_id].bmap_id) {
+    bx_headerbar_entry[hbar_id].bmap_id = bmap_id;
+    SendMessage(hwndTB, TB_CHANGEBITMAP, (WPARAM)hbar_id+101, (LPARAM)
+                MAKELPARAM(bmap_id, 0));
+  }
 }
 
 
@@ -1078,7 +1134,7 @@
   printf("# In bx_gui_c::exit(void)!\n");
 
   // kill thread first...
-  PostMessage(stInfo.hwnd, WM_CLOSE, 0, 0);
+  PostMessage(stInfo.mainWnd, WM_CLOSE, 0, 0);
 
   // Wait until it dies
   while ((stInfo.kill == 0) && (workerThreadID != 0)) Sleep(500);
@@ -1092,7 +1148,7 @@
   unsigned char data[32];
 
   // VGA font is 8wide x 16high
-  hdc = GetDC(stInfo.hwnd);
+  hdc = GetDC(stInfo.simWnd);
   for (unsigned c = 0; c<256; c++) {
     vgafont[c] = CreateBitmap(8,16,1,1,NULL);
     if (!vgafont[c]) terminateEmul(EXIT_FONT_BITMAP_ERROR);
@@ -1145,29 +1201,29 @@
 //	BitBlt(MemoryDC, xStart, yStart, ptSize.x, ptSize.y, hdcMem, ptOrg.x,
 //		  ptOrg.y, dwRop);
 //Colors taken from Ralf Browns interrupt list.
-//(0=black, 1=blue, 2=red, 3=purple, 4=green, 5=cyan, 6=yellow, 7=white)	  
+//(0=black, 1=blue, 2=red, 3=purple, 4=green, 5=cyan, 6=yellow, 7=white)
 //The highest background bit usually means blinking characters. No idea
 //how to implement that so for now it's just implemented as color.
 //Note: it is also possible to program the VGA controller to have the
 //high bit for the foreground color enable blinking characters.
 
 	const COLORREF crPal[16] = {
-	RGB(0 ,0 ,0 ), //0 black 
-	RGB(0 ,0 ,0xA8 ), //1 dark blue 
-	RGB(0 ,0xA8 ,0 ), //2 dark green 
-	RGB(0 ,0xA8 ,0xA8 ), //3 dark cyan 
-	RGB(0xA8 ,0 ,0 ), //4 dark red 
-	RGB(0xA8 ,0 ,0xA8 ), //5 dark magenta 
-	RGB(0xA8 ,0x54 ,0 ), //6 brown 
-	RGB(0xA8 ,0xA8 ,0xA8 ), //7 light gray 
-	RGB(0x54 ,0x54 ,0x54 ), //8 dark gray 
-	RGB(0x54 ,0x54 ,0xFC ), //9 light blue 
-	RGB(0x54 ,0xFC ,0x54 ), //10 green 
-	RGB(0x54 ,0xFC ,0xFC ), //11 cyan 
-	RGB(0xFC ,0x54 ,0x54 ), //12 light red 
-	RGB(0xFC ,0x54 ,0xFC ), //13 magenta 
-	RGB(0xFC ,0xFC ,0x54 ), //14 yellow 
-	RGB(0xFC ,0xFC ,0xFC ) //15 white 
+	RGB(0 ,0 ,0 ), //0 black
+	RGB(0 ,0 ,0xA8 ), //1 dark blue
+	RGB(0 ,0xA8 ,0 ), //2 dark green
+	RGB(0 ,0xA8 ,0xA8 ), //3 dark cyan
+	RGB(0xA8 ,0 ,0 ), //4 dark red
+	RGB(0xA8 ,0 ,0xA8 ), //5 dark magenta
+	RGB(0xA8 ,0x54 ,0 ), //6 brown
+	RGB(0xA8 ,0xA8 ,0xA8 ), //7 light gray
+	RGB(0x54 ,0x54 ,0x54 ), //8 dark gray
+	RGB(0x54 ,0x54 ,0xFC ), //9 light blue
+	RGB(0x54 ,0xFC ,0x54 ), //10 green
+	RGB(0x54 ,0xFC ,0xFC ), //11 cyan
+	RGB(0xFC ,0x54 ,0x54 ), //12 light red
+	RGB(0xFC ,0x54 ,0xFC ), //13 magenta
+	RGB(0xFC ,0xFC ,0x54 ), //14 yellow
+	RGB(0xFC ,0xFC ,0xFC ) //15 white
 	};
 
 	COLORREF crFore = SetTextColor(MemoryDC, crPal[(cColor>>4)&0xf]);
@@ -1206,18 +1262,10 @@
 }
 
 
-void headerbar_click(int x) {
-  int xorigin;
-
-  for (unsigned i=0; i<bx_headerbar_entries; i++) {
-    if (bx_headerbar_entry[i].alignment == BX_GRAVITY_LEFT)
-      xorigin = bx_headerbar_entry[i].xorigin;
-    else
-      xorigin = dimension_x - bx_headerbar_entry[i].xorigin;
-    if ( (x>=xorigin) && (x<(xorigin+int(bx_headerbar_entry[i].xdim))) ) {
-      bx_headerbar_entry[i].f();
-      return;
-    }
+void headerbar_click(int x)
+{
+  if (x < bx_headerbar_entries) {
+    bx_headerbar_entry[x].f();
   }
 }
 
@@ -1231,7 +1279,7 @@
 void alarm (int time)
 {
   UINT idTimer;
-  SetTimer(stInfo.hwnd,idTimer,time*1000,MyTimer);
+  SetTimer(stInfo.simWnd,idTimer,time*1000,MyTimer);
 }
 #endif
 #endif
