----------------------------------------------------------------------
Patch name: patch.cdrom-blkgetsize
Author: bochs@sigint.cs.purdue.edu
Date: Fri, 22 Jun 2001 10:46:07 -0500

Detailed description:
  The original code for determining the capacity of a disc only worked for
  ATAPI drives, leaving us poor SCSI users in the cold.  The code uses the
  standard Linux CD-ROM driver routines, so it should work on any supported
  drive.  It's basically just a copy of Keith Jones FreeBSD code.

Patch was created with:
  ?
Apply patch to what version:
  ?
Instructions:
  ?
----------------------------------------------------------------------


--- iodev/cdrom.cc.orig	Tue Jun 19 16:36:09 2001
+++ iodev/cdrom.cc	Fri Jun 22 10:40:07 2001
@@ -390,24 +390,6 @@
   
     return(buf.st_size);
   }
-#elif __linux__
-  {
-  // I just looked through the Linux kernel source to see
-  // what it does with the ATAPI capacity command, and reversed
-  // that process here.
-  uint32 nr_sects;
-
-  if (fd < 0) {
-    BX_PANIC(("cdrom: capacity: file not open."));
-    }
-  if (ioctl(fd, BLKGETSIZE, &nr_sects) != 0) {
-    BX_PANIC(("cdrom: ioctl(BLKGETSIZE) failed"));
-    }
-  nr_sects /= (CD_FRAMESIZE / 512);
-
-  BX_DEBUG(( "capacity: %u", nr_sects));
-  return(nr_sects);
-  }
 #elif defined(__OpenBSD__)
   {
   // We just read the disklabel, imagine that...
@@ -421,6 +403,57 @@
 
   BX_DEBUG(( "capacity: %u", lp.d_secperunit ));
   return(lp.d_secperunit);
+  }
+#elif defined(__linux__)
+  {
+  // Read the TOC to get the data size, since BLKGETSIZE doesn't work on
+  // non-ATAPI drives.  This is based on Keith Jones code below.
+  // <splite@purdue.edu> 21 June 2001
+
+  int i, dtrk, dtrk_lba, num_sectors;
+  struct cdrom_tochdr td;
+  struct cdrom_tocentry te;
+
+  if (fd < 0)
+    BX_PANIC(("cdrom: capacity: file not open."));
+
+  if (ioctl(fd, CDROMREADTOCHDR, &td) < 0)
+    BX_PANIC(("cdrom: ioctl(CDROMREADTOCHDR) failed"));
+
+  num_sectors = -1;
+  dtrk_lba = -1;
+
+  for (i = td.cdth_trk0; i <= td.cdth_trk1; i++) {
+    te.cdte_track = i;
+    te.cdte_format = CDROM_LBA;
+    if (ioctl(fd, CDROMREADTOCENTRY, &te) < 0)
+      BX_PANIC(("cdrom: ioctl(CDROMREADTOCENTRY) failed"));
+
+    if (dtrk_lba != -1) {
+      num_sectors = te.cdte_addr.lba - dtrk_lba;
+      break;
+    }
+    if (te.cdte_ctrl & CDROM_DATA_TRACK) {
+      dtrk = i;
+      dtrk_lba = te.cdte_addr.lba;
+    }
+  }
+
+  if (num_sectors < 0) {
+    if (dtrk_lba != -1) {
+      te.cdte_track = CDROM_LEADOUT;
+      te.cdte_format = CDROM_LBA;
+      if (ioctl(fd, CDROMREADTOCENTRY, &te) < 0)
+        BX_PANIC(("cdrom: ioctl(CDROMREADTOCENTRY) failed"));
+      num_sectors = te.cdte_addr.lba - dtrk_lba;
+    } else
+      BX_PANIC(("cdrom: no data track found"));
+  }
+
+  BX_INFO(("cdrom: Data track %d, length %d", dtrk, num_sectors));
+
+  return(num_sectors);
+
   }
 #elif defined(__FreeBSD__)
   {

