----------------------------------------------------------------------
Patch name: patch.tun-tap
Author: renzo davoli <renzo@cs.unibo.it>
Date: Mon, 1 Apr 2002 19:13:53 -0500 (EST)

Detailed description (from Renzo's message):

I have ported the ne2k emulation from ethertap to tun-tap
interface.  ethertap in fact will not be supported in kernel 2.5
and tuntap allows the dynamic creation of interfaces at user
level.

I have patched the file iodev/eth_tap.cc

Patch was created with:
  cvs diff -u
Apply patch to what version:
  cvs checked out on DATE, release version VER
Instructions:
  To patch, go to main bochs directory.
  Type "patch -p0 < THIS_PATCH_FILE".
----------------------------------------------------------------------
Index: iodev/eth_tap.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/iodev/eth_tap.cc,v
retrieving revision 1.5
diff -u -r1.5 eth_tap.cc
--- iodev/eth_tap.cc	11 Mar 2002 13:59:38 -0000	1.5
+++ iodev/eth_tap.cc	2 Apr 2002 15:51:19 -0000
@@ -1,4 +1,3 @@
-/////////////////////////////////////////////////////////////////////////
 // $Id: patch.tun-tap,v 1.1 2002-04-02 15:54:35 bdenney Exp $
 /////////////////////////////////////////////////////////////////////////
 //
@@ -99,9 +98,11 @@
 #include <errno.h>
 
 #define TAP_VIRTUAL_HW_ADDR             0xDEADBEEF
-#define BX_ETH_TAP_LOGGING 1
+#define BX_ETH_TAP_LOGGING 0
 #define BX_PACKET_BUFSIZ 2048	// Enough for an ether frame
 
+int tun_alloc(char *dev);
+
 //
 //  Define the class. This is private to this module
 //
@@ -151,6 +152,7 @@
   if (strncmp (netif, "tap", 3) != 0) {
     BX_PANIC (("eth_tap: interface name (%s) must be tap0..tap15", netif));
   }
+#ifdef NEVERDEF
   sprintf (filename, "/dev/%s", netif);
 
   // check if the TAP devices is running, and turn on ARP.  This is based
@@ -185,6 +187,10 @@
   close(sock);
 
   fd = open (filename, O_RDWR);
+#endif 
+  char intname[IFNAMSIZ];
+  strcpy(intname,netif);
+  fd=tun_alloc(intname);
   if (fd < 0) {
     BX_PANIC (("open failed on %s: %s", netif, strerror (errno)));
     return;
@@ -201,13 +207,13 @@
 
   BX_INFO (("eth_tap: opened %s device", netif));
 
-#if BX_ETH_TAP_LOGGING
   // Start the rx poll 
   this->rx_timer_index = 
     bx_pc_system.register_timer(this, this->rx_timer_handler, 1000,
 				1, 1); // continuous, active
   this->rxh   = rxh;
   this->rxarg = rxarg;
+#if BX_ETH_TAP_LOGGING
   // eventually Bryce wants txlog to dump in pcap format so that
   // tcpdump -r FILE can read it and interpret packets.
   txlog = fopen ("ne2k-tx.log", "wb");
@@ -240,6 +246,7 @@
 void
 bx_tap_pktmover_c::sendpkt(void *buf, unsigned io_len)
 {
+#ifdef NEVERDEF
   Bit8u txbuf[BX_PACKET_BUFSIZ];
   txbuf[0] = 0;
   txbuf[1] = 0;
@@ -250,6 +257,13 @@
   } else {
     BX_INFO (("wrote %d bytes + 2 byte pad on tap", io_len));
   }
+#endif
+  unsigned int size = write (fd, buf, io_len);
+  if (size != io_len) {
+    BX_PANIC (("write on tap device: %s", strerror (errno)));
+  } else {
+    BX_INFO (("wrote %d bytes on tap", io_len));
+  }
 #if BX_ETH_TAP_LOGGING
   BX_DEBUG (("sendpkt length %u", io_len));
   // dump raw bytes to a file, eventually dump in pcap format so that
@@ -285,10 +299,14 @@
   if (fd<0) return;
   nbytes = read (fd, buf, sizeof(buf));
 
+#ifdef NEVERDEF
   // hack: discard first two bytes
   rxbuf = buf+2;
   nbytes-=2;
-  
+#else
+  rxbuf=buf;
+#endif
+
   // hack: TAP device likes to create an ethernet header which has
   // the same source and destination address FE:FD:00:00:00:00.
   // Change the dest address to FE:FD:00:00:00:01.
@@ -328,3 +346,54 @@
   }
   (*rxh)(rxarg, rxbuf, nbytes);
 }
+
+
+#include <stdio.h>
+#include <signal.h>
+#include <sys/param.h>
+#include <sys/ioctl.h>
+#include <sys/poll.h>
+#include <sys/time.h>
+#include <sys/resource.h>
+#include <asm/types.h>
+#include <sys/socket.h>
+#include <sys/uio.h>
+#include <sys/wait.h>
+#include <linux/netlink.h>
+#include <linux/if.h>
+#include <linux/version.h>
+#include <linux/if_tun.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+  int tun_alloc(char *dev)
+  {
+      struct ifreq ifr;
+      int fd, err;
+
+      if( (fd = open("/dev/net/tun", O_RDWR)) < 0 )
+         return -1;
+
+      memset(&ifr, 0, sizeof(ifr));
+
+      /* Flags: IFF_TUN   - TUN device (no Ethernet headers) 
+       *        IFF_TAP   - TAP device  
+       *
+       *        IFF_NO_PI - Do not provide packet information  
+       */ 
+      //ifr.ifr_flags = IFF_TUN; 
+      ifr.ifr_flags = IFF_TAP | IFF_NO_PI; 
+      if( *dev )
+         strncpy(ifr.ifr_name, dev, IFNAMSIZ);
+
+      if( (err = ioctl(fd, TUNSETIFF, (void *) &ifr)) < 0 ){
+         close(fd);
+         return err;
+      }
+
+      //strcpy(dev, ifr.ifr_name);
+      ioctl( fd, TUNSETNOCSUM, 1 );
+
+      return fd;
+  }              
