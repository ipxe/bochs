Only in gui: Makefile
Common subdirectories: gui_org/bitmaps and gui/bitmaps
Only in gui: gui.o
Only in gui: libgui.a
diff -c -C2 gui_org/x.cc gui/x.cc
*** gui_org/x.cc	Mon Apr  9 21:19:49 2001
--- gui/x.cc	Wed May 30 14:13:52 2001
***************
*** 61,65 ****
  
  // current cursor coordinates
! static int prev_x=-1, prev_y=-1;
  static int current_x=-1, current_y=-1;
  static unsigned mouse_button_state = 0;
--- 61,65 ----
  
  // current cursor coordinates
! static int emulation_x=-1, emulation_y=-1;
  static int current_x=-1, current_y=-1;
  static unsigned mouse_button_state = 0;
***************
*** 592,597 ****
            mouse_update = 0;
            }
-         prev_x = current_x = -1;
-         prev_y = current_y = -1;
          headerbar_click(button_event->x, button_event->y);
          break;
--- 592,595 ----
***************
*** 615,627 ****
  	      if (bx_options.mouse_enabled) {
  		    bx_printf("[x] Mouse enabled\n");
! 		    mouse_enable_x = current_x;
! 		    mouse_enable_y = current_y;
  		    disable_cursor();
  		    // Move the cursor to a 'safe' place
! 		    warp_cursor(warp_home_x-current_x, warp_home_y-current_y);
  	      } else {
  		    bx_printf("[x] Mouse disabled\n");
  		    enable_cursor();
! 		    warp_cursor(mouse_enable_x-current_x, mouse_enable_y-current_y);
  	      }
  
--- 613,625 ----
  	      if (bx_options.mouse_enabled) {
  		    bx_printf("[x] Mouse enabled\n");
! //		    mouse_enable_x = current_x;
! //		    mouse_enable_y = current_y;
  		    disable_cursor();
  		    // Move the cursor to a 'safe' place
! //		    warp_cursor(warp_home_x-current_x, warp_home_y-current_y);
  	      } else {
  		    bx_printf("[x] Mouse disabled\n");
  		    enable_cursor();
! //		    warp_cursor(mouse_enable_x-current_x, mouse_enable_y-current_y);
  	      }
  
***************
*** 649,654 ****
            mouse_update = 0;
            }
-         prev_x = current_x = -1;
-         prev_y = current_y = -1;
          // ignore, in headerbar area
          break;
--- 647,650 ----
***************
*** 696,709 ****
      case MotionNotify:
        pointer_event = (XPointerMovedEvent *) &report;
!       current_x = pointer_event->x;
!       current_y = pointer_event->y;
!       mouse_update = 1;
! //bx_printf("xxx: motionNotify x,y=(%d,%d)\n", current_x, current_y);
        break;
  
      case EnterNotify:
        enter_event = (XEnterWindowEvent *) &report;
!       prev_x = current_x = enter_event->x;
!       prev_y = current_y = enter_event->y;
  //bx_printf("xxx: enterNotify x,y=(%d,%d)\n", current_x, current_y);
        break;
--- 692,729 ----
      case MotionNotify:
        pointer_event = (XPointerMovedEvent *) &report;
!       if (pointer_event->y >= BX_HEADER_BAR_Y) {
!         current_x = pointer_event->x;
!         current_y = pointer_event->y;
!         mouse_update = 1;
! bx_printf("xxx: motionNotify x,y=(%d,%d)\n", current_x, current_y);
!       }
        break;
  
      case EnterNotify:
        enter_event = (XEnterWindowEvent *) &report;
!       current_x = enter_event->x;
!       current_y = enter_event->y - BX_HEADER_BAR_Y;
! /*
!     Hardware-level BIOS interface only provides mouse movements as deltas
!     - never absolute positions.  This causes a problem when the mouse pointer
!     leaves the screen (in an emulated environment), then re-enters the screen.
!     Code in "send_keyboard_mouse_status(void)" below attempts to address
!     this by calculating the delta of the exit point and the entry point, and
!     feeding the appropriate delta move via the BIOS interface, which would
!     work, except:
! 
!      - There is still no way to synchronize the _absolute_ pointer locations
!      in emulated and host environment; and
!      - modern mouse drivers have "balistic" movements, so any "large, rapid"
!      delta is magnified, perpetuating any skew between the host and emulation
!      pointers.
!      
!     What we really need is a function like:
!     bx_devices.keyboard->mouse_moveto(current_x,current_y);
!     , which could resolve to the equivalent of (DOS) INT 33, function 4, which
!     sets an absolute pointer position.  Unfortunately, this would be OS 
!     dependant.
! */
! 
  //bx_printf("xxx: enterNotify x,y=(%d,%d)\n", current_x, current_y);
        break;
***************
*** 711,716 ****
      case LeaveNotify:
        leave_event = (XLeaveWindowEvent *) &report;
!       prev_x = current_x = -1;
!       prev_y = current_y = -1;
  //bx_printf("xxx: LeaveNotify x,y set to -1\n");
        break;
--- 731,736 ----
      case LeaveNotify:
        leave_event = (XLeaveWindowEvent *) &report;
!       current_x = leave_event->x;
!       current_y = leave_event->y - BX_HEADER_BAR_Y;
  //bx_printf("xxx: LeaveNotify x,y set to -1\n");
        break;
***************
*** 734,738 ****
  
    if (mouse_update) {
!     //bx_printf("xxx: bottom, send status\n");
      send_keyboard_mouse_status();
      }
--- 754,758 ----
  
    if (mouse_update) {
!     // bx_printf("xxx: bottom, send status\n");
      send_keyboard_mouse_status();
      }
***************
*** 744,778 ****
  {
  //bx_printf("xxx: prev=(%d,%d) curr=(%d,%d)\n",
! //  prev_x, prev_y, current_x, current_y);
  
!   if ( (prev_x!=-1) && (current_x!=-1) && (prev_y!=-1) && (current_y!=-1)) {
!     int dx, dy;
! 
!     // (mch) consider warping here
!     dx = current_x - prev_x - warp_dx;
!     dy = -(current_y - prev_y - warp_dy);
!     warp_cursor(warp_home_x-current_x, warp_home_y-current_y);
! 
! //bx_printf("xxx: MOUSE_MOTION: dx=%d, dy=%d\n", (int) dx, (int) dy);
!     bx_devices.keyboard->mouse_motion( dx, dy, mouse_button_state);
!     //if (warped) {
!     //  prev_x = current_x = -1;
!     //  prev_y = current_y = -1;
!     //  }
!     //else {
!       prev_x = current_x;
!       prev_y = current_y;
!     //  }
      }
!   else {
!     if ( (current_x!=-1) && (current_y!=-1)) {
!       prev_x = current_x;
!       prev_y = current_y;
!       }
!     else {
!       prev_x = current_x = -1;
!       prev_y = current_y = -1;
!       }
      }
  }
  
--- 764,805 ----
  {
  //bx_printf("xxx: prev=(%d,%d) curr=(%d,%d)\n",
! //  emulation_x, emulation_y, current_x, current_y);
!   int dx, dy;
  
!   do {
!     // Continue to calculate deltas until the emulation pointer coincides
!     // with the XWindows pointer...
!     dx = (current_x - emulation_x);
!     dy = -(current_y - emulation_y);
! 
!     // limit individual delta increments - up to max supported (255).
!     // Increasing these values will provide more rapid tracking,
!     // but if the value is too large, the OS-specific mouse driver
!     // may switch to "balistic" mode, in which a large delta causes
!     // a larger-than-normal motion of the pointer. This will cause a
!     // offset between the emulation pointer location and the host pointer
!     // location.
!     
! #define LIMIT_DX	30	// Must be less than 255
! #define	LIMIT_DY	30	// Must be less than 255
! 
!     if (dx > LIMIT_DX) {
! 	dx = LIMIT_DX;
!     } else if (dx < -LIMIT_DX) {
! 	dx = -LIMIT_DX;
      }
!     if (dy > LIMIT_DY) {
! 	dy = LIMIT_DY;
!     } else if (dy < -LIMIT_DY) {
! 	dy = -LIMIT_DY;
      }
+ 
+ bx_printf("xxx: MOUSE_MOTION: emx=%d, cux=%d, dx=%d\n", emulation_x, current_x, (int) dx);
+ bx_printf("xxx: MOUSE_MOTION: emy=%d, cuy=%d, dy=%d\n", emulation_y, current_y, (int) dy);
+     // Do at least one mouse_motion call, to handle button_state updates
+     bx_devices.keyboard->mouse_motion( dx, dy, mouse_button_state);
+     emulation_x += dx;
+     emulation_y -= dy;
+   } while ( (emulation_x != current_x) || (emulation_y != current_y) );
  }
  
Only in gui: x.o
