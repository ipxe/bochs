----------------------------------------------------------------------
Patch name: patch.2hd-experimental
Author: Bryce Denney
Date: Thu May  3 11:38:16 EDT 2001

Detailed description:

THIS IS EXPERIMENTAL CODE.  Back up your disk images before trying it!
With this version of the patch installed, you should put both diskc and 
diskd lines into your .bochsrc.  Eventually, I'll fix up rombios.c to
behave correctly with either 1 or 2 disks.

  This is a first attempt at allowing "diskd" to work.  This patch
  does the following:
  - remove panic when diskd arg is used.  Only panic if both cdromd and
    diskd are both used.
  - in harddrv.cc, when diskd is present, fill in the CMOS RAM with hard
    disk data for second drive.  
  - Added code that leans toward seconde IDE controller support, but 
    it's still commented out.  (not complete)
  - hacked rombios.c int 0x13 code, get_hd_geometry, and hard_drive_post
    which fills in the EBDA info to allow second drive
  To be done still:
  - make sure it still works with only one HD!  The harddrv.cc code should
    be okay, but the rombios.c code has some hardcoded stuff.
  - my assembly isn't that good, but try to reuse code for EBDA setup
    of hd0 and hd1.
  - test cdrom with these changes, to see if I broke it.

Apply patch to:
  current CVS sources (5/3/2001)
Instructions:
  To patch, go to main bochs directory.
  Type "patch -p0 < THIS_PATCH_FILE".
----------------------------------------------------------------------
===================================================================
RCS file: /cvsroot/bochs/bochs/main.cc,v
retrieving revision 1.4
diff -c -r1.4 main.cc
*** main.cc	2001/05/02 02:39:23	1.4
--- main.cc	2001/05/03 15:42:29
***************
*** 308,314 ****
      va_start(ap, fmt);
      vfprintf(bx_logfd, fmt, ap);
      va_end(ap);
!     }
  
  #if !BX_PANIC_IS_FATAL
    return;
--- 308,321 ----
      va_start(ap, fmt);
      vfprintf(bx_logfd, fmt, ap);
      va_end(ap);
!   } else {
!     /* panic message is critical to knowing what's going on. print to
!        stderr instead */
!     fprintf(stderr, "bochs: panic, ");
!     va_start(ap, fmt);
!     vfprintf(stderr, fmt, ap);
!     va_end(ap);
!   }
  
  #if !BX_PANIC_IS_FATAL
    return;
***************
*** 527,533 ****
      bx_options.diskc.present = 1;
      }
    else if (!strcmp(params[0], "diskd")) {
-     bx_panic("Diskd not implemented. Use cdromd for CD-ROM support.\n");
      if (num_params != 5) {
        fprintf(stderr, ".bochsrc: diskd directive malformed.\n");
        exit(1);
--- 534,539 ----
***************
*** 890,895 ****
--- 896,904 ----
      fprintf(stderr, ".bochsrc: directive '%s' not understood\n", params[0]);
      exit(1);
      }
+ 
+   if (bx_options.diskd.present && bx_options.cdromd.present)
+     bx_panic ("At present, using both diskd and cdromd at once is not supported.");
  }
  #endif // #if BX_PROVIDE_MAIN
  
Index: bios/rombios.c
===================================================================
RCS file: /cvsroot/bochs/bochs/bios/rombios.c,v
retrieving revision 1.2
diff -c -r1.2 rombios.c
*** bios/rombios.c	2001/04/10 02:19:23	1.2
--- bios/rombios.c	2001/05/03 15:42:34
***************
*** 244,250 ****
  static void           debugger_off();
  static void           keyboard_panic();
  
! #if 0
  #  define printf(format, p...) bios_printf(0, format, ##p)
  #  define panic(format, p...)  bios_printf(1, format, ##p)
  #else
--- 244,250 ----
  static void           debugger_off();
  static void           keyboard_panic();
  
! #if 1
  #  define printf(format, p...) bios_printf(0, format, ##p)
  #  define panic(format, p...)  bios_printf(1, format, ##p)
  #else
***************
*** 1656,1662 ****
  
    /* at this point, DL is >= 0x80 to be passed from the floppy int13h
       handler code */
!   if (GET_DL() > 0x80) { /* only handle one disk for now */
      SET_AH(0x01);
      set_disk_ret_status(0x01);
      SET_CF(); /* error occurred */
--- 1656,1662 ----
  
    /* at this point, DL is >= 0x80 to be passed from the floppy int13h
       handler code */
!   if (GET_DL() > 0x81) { /* allow two disks */
      SET_AH(0x01);
      set_disk_ret_status(0x01);
      SET_CF(); /* error occurred */
***************
*** 1667,1673 ****
  
      case 0x00: /* disk controller reset */
  printf("int13_f00\n");
-       drive = GET_DL();
  
        SET_AH(0);
        set_disk_ret_status(0);
--- 1667,1672 ----
***************
*** 1691,1697 ****
  
      case 0x04: // verify disk sectors
      case 0x02: // read disk sectors
!       get_hd_geometry(&hd_cylinders, &hd_heads, &hd_sectors);
  
        num_sectors = GET_AL();
        cylinder    = GET_CH();
--- 1690,1697 ----
  
      case 0x04: // verify disk sectors
      case 0x02: // read disk sectors
!       drive = GET_DL();
!       get_hd_geometry(drive, &hd_cylinders, &hd_heads, &hd_sectors);
  
        num_sectors = GET_AL();
        cylinder    = GET_CH();
***************
*** 1751,1757 ****
        outb(0x01f3, sector);
        outb(0x01f4, cylinder & 0x00ff);
        outb(0x01f5, cylinder >> 8);
!       outb(0x01f6, 0xa0 | ((GET_DL() & 0x01)<<4) | (head & 0x0f));
        outb(0x01f7, 0x20);
  
        while (1) {
--- 1751,1757 ----
        outb(0x01f3, sector);
        outb(0x01f4, cylinder & 0x00ff);
        outb(0x01f5, cylinder >> 8);
!       outb(0x01f6, 0xa0 | ((drive&1)<<4) | (head & 0x0f));
        outb(0x01f7, 0x20);
  
        while (1) {
***************
*** 1828,1834 ****
  
  
      case 0x03: /* write disk sectors */
!       get_hd_geometry(&hd_cylinders, &hd_heads, &hd_sectors);
  
        num_sectors = GET_AL();
        cylinder    = GET_CH();
--- 1828,1836 ----
  
  
      case 0x03: /* write disk sectors */
! printf("int13_f03\n");
!       drive = GET_DL ();
!       get_hd_geometry(drive, &hd_cylinders, &hd_heads, &hd_sectors);
  
        num_sectors = GET_AL();
        cylinder    = GET_CH();
***************
*** 1880,1886 ****
        outb(0x01f3, sector);
        outb(0x01f4, cylinder & 0x00ff);
        outb(0x01f5, cylinder >> 8);
!       outb(0x01f6, 0xa0 | ((GET_DL() & 0x01)<<4) | (head & 0x0f));
        outb(0x01f7, 0x30);
  
        // wait for busy bit to turn off after seeking
--- 1882,1888 ----
        outb(0x01f3, sector);
        outb(0x01f4, cylinder & 0x00ff);
        outb(0x01f5, cylinder >> 8);
!       outb(0x01f6, 0xa0 | ((drive&1)<<4) | (head & 0x0f));
        outb(0x01f7, 0x30);
  
        // wait for busy bit to turn off after seeking
***************
*** 1968,1974 ****
  
      case 0x08: /* read disk drive parameters */
  printf("int13_f08\n");
!       get_hd_geometry(&hd_cylinders, &hd_heads, &hd_sectors);
  
        // translate CHS
        //
--- 1970,1977 ----
  
      case 0x08: /* read disk drive parameters */
  printf("int13_f08\n");
!       // return geom for drive 0x80, they asked for "max" cylinders anyway
!       get_hd_geometry(0x80, &hd_cylinders, &hd_heads, &hd_sectors);
  
        // translate CHS
        //
***************
*** 1998,2004 ****
        SET_CH(max_cylinder & 0xff);
        SET_CL(((max_cylinder >> 2) & 0xc0) | (hd_sectors & 0x3f));
        SET_DH(hd_heads - 1);
!       SET_DL(1); /* one drive for now */
        SET_AH(0);
        set_disk_ret_status(0);
        CLEAR_CF(); /* successful */
--- 2001,2007 ----
        SET_CH(max_cylinder & 0xff);
        SET_CL(((max_cylinder >> 2) & 0xc0) | (hd_sectors & 0x3f));
        SET_DH(hd_heads - 1);
!       SET_DL(2); /* two drives */
        SET_AH(0);
        set_disk_ret_status(0);
        CLEAR_CF(); /* successful */
***************
*** 2080,2087 ****
        break;
  
      case 0x15: /* read disk drive size */
!       // check for driveno in DL here
!       get_hd_geometry(&hd_cylinders, &hd_heads, &hd_sectors);
  #asm
        push bp
        mov  bp, sp
--- 2083,2090 ----
        break;
  
      case 0x15: /* read disk drive size */
!       drive = GET_DL();
!       get_hd_geometry(drive, &hd_cylinders, &hd_heads, &hd_sectors);
  #asm
        push bp
        mov  bp, sp
***************
*** 2967,2998 ****
  
  
    void
! get_hd_geometry(hd_cylinders, hd_heads, hd_sectors)
    Bit16u *hd_cylinders;
    Bit8u  *hd_heads;
    Bit8u  *hd_sectors;
  {
!   Bit8u hd0_type;
    Bit16u ss;
    Bit16u cylinders;
  
    ss = get_SS();
!   hd0_type = inb_cmos(0x12) & 0xf0;
!   if (hd0_type != 0xf0)
!     panic("HD0 cmos reg 12h not type F\n");
!   hd0_type = inb_cmos(0x19); // HD0: extended type
!   if (hd0_type != 47)
!     panic("HD0 cmos reg 19h not user definable type 47\n");
  
    // cylinders
!   cylinders = inb_cmos(0x1b) | (inb_cmos(0x1c) << 8);
    write_word(ss, hd_cylinders, cylinders);
  
    // heads
!   write_byte(ss, hd_heads, inb_cmos(0x1d));
  
    // sectors per track
!   write_byte(ss, hd_sectors, inb_cmos(0x23));
  }
  
    void
--- 2970,3014 ----
  
  
    void
! get_hd_geometry(drive, hd_cylinders, hd_heads, hd_sectors)
!   Bit8u drive;
    Bit16u *hd_cylinders;
    Bit8u  *hd_heads;
    Bit8u  *hd_sectors;
  {
!   Bit8u hd_type;
    Bit16u ss;
    Bit16u cylinders;
+   Bit8u iobase;
  
    ss = get_SS();
!   if (drive == 0x80) {
!     hd_type = inb_cmos(0x12) & 0xf0;
!     if (hd_type != 0xf0)
!       panic("HD0 cmos reg 12h not type F\n");
!     hd_type = inb_cmos(0x19); // HD0: extended type
!     if (hd_type != 47)
!       panic("HD0 cmos reg 19h not user definable type 47\n");
!     iobase = 0x1b;
!   } else {
!     hd_type = inb_cmos(0x12) & 0x0f;
!     if (hd_type != 0x0f)
!       panic("HD1 cmos reg 12h not type F\n");
!     hd_type = inb_cmos(0x1a); // HD0: extended type
!     if (hd_type != 47)
!       panic("HD1 cmos reg 1ah not user definable type 47\n");
!     iobase = 0x24;
!   }
  
    // cylinders
!   cylinders = inb_cmos(iobase) | (inb_cmos(iobase+1) << 8);
    write_word(ss, hd_cylinders, cylinders);
  
    // heads
!   write_byte(ss, hd_heads, inb_cmos(iobase+2));
  
    // sectors per track
!   write_byte(ss, hd_sectors, inb_cmos(iobase+8));
  }
  
    void
***************
*** 3465,3470 ****
--- 3481,3487 ----
    mov  ax, #EBDA_SEG
    mov  ds, ax
  
+ ;;; Filling EBDA table for hard disk 0.
    mov  al, #0x1f
    out  #0x70, al
    in   al, #0x71
***************
*** 3508,3524 ****
    mov  dl, al      ;; DL = sectors
  
    cmp  bx, #1024
!   jnbe post_logical_chs ;; if cylinders > 1024, use translated style CHS
  
! post_physical_chs:
    ;; no logical CHS mapping used, just physical CHS
    ;; use Standard Fixed Disk Parameter Table (FDPT)
    mov   (0x003d + 0x00), bx ;; number of physical cylinders
    mov   (0x003d + 0x02), cl ;; number of physical heads
    mov   (0x003d + 0x0E), dl ;; number of physical sectors
!   ret
  
! post_logical_chs:
    ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
    mov   (0x003d + 0x09), bx ;; number of physical cylinders
    mov   (0x003d + 0x0b), cl ;; number of physical heads
--- 3525,3541 ----
    mov  dl, al      ;; DL = sectors
  
    cmp  bx, #1024
!   jnbe hd0_post_logical_chs ;; if cylinders > 1024, use translated style CHS
  
! hd0_post_physical_chs:
    ;; no logical CHS mapping used, just physical CHS
    ;; use Standard Fixed Disk Parameter Table (FDPT)
    mov   (0x003d + 0x00), bx ;; number of physical cylinders
    mov   (0x003d + 0x02), cl ;; number of physical heads
    mov   (0x003d + 0x0E), dl ;; number of physical sectors
!   jmp hd1_setup
  
! hd0_post_logical_chs:
    ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
    mov   (0x003d + 0x09), bx ;; number of physical cylinders
    mov   (0x003d + 0x0b), cl ;; number of physical heads
***************
*** 3528,3575 ****
    mov   (0x003d + 0x03), al ;; A0h signature, indicates translated table
  
    cmp bx, #2048
!   jnbe post_above_2048
    ;; 1024 < c <= 2048 cylinders
    shr bx, #0x01
    shl cl, #0x01
!   jmp post_store_logical
  
! post_above_2048:
    cmp bx, #4096
!   jnbe post_above_4096
    ;; 2048 < c <= 4096 cylinders
    shr bx, #0x02
    shl cl, #0x02
!   jmp post_store_logical
  
! post_above_4096:
    cmp bx, #8192
!   jnbe post_above_8192
    ;; 4096 < c <= 8192 cylinders
    shr bx, #0x03
    shl cl, #0x03
!   jmp post_store_logical
  
! post_above_8192:
    ;; 8192 < c <= 16384 cylinders
    shr bx, #0x04
    shl cl, #0x04
  
! post_store_logical:
    mov   (0x003d + 0x00), bx ;; number of physical cylinders
    mov   (0x003d + 0x02), cl ;; number of physical heads
    ;; checksum
    mov   cl, #0x0f     ;; repeat count
    mov   si, #0x003d   ;; offset to disk0 FDPT
    mov   al, #0x00     ;; sum
! post_checksum_loop:
    add   al, [si]
    inc   si
    dec   cl
!   jnz post_checksum_loop
    not   al  ;; now take 2s complement
    inc   al
    mov   [si], al
    ret
  
  
--- 3545,3703 ----
    mov   (0x003d + 0x03), al ;; A0h signature, indicates translated table
  
    cmp bx, #2048
!   jnbe hd0_post_above_2048
    ;; 1024 < c <= 2048 cylinders
    shr bx, #0x01
    shl cl, #0x01
!   jmp hd0_post_store_logical
  
! hd0_post_above_2048:
    cmp bx, #4096
!   jnbe hd0_post_above_4096
    ;; 2048 < c <= 4096 cylinders
    shr bx, #0x02
    shl cl, #0x02
!   jmp hd0_post_store_logical
  
! hd0_post_above_4096:
    cmp bx, #8192
!   jnbe hd0_post_above_8192
    ;; 4096 < c <= 8192 cylinders
    shr bx, #0x03
    shl cl, #0x03
!   jmp hd0_post_store_logical
  
! hd0_post_above_8192:
    ;; 8192 < c <= 16384 cylinders
    shr bx, #0x04
    shl cl, #0x04
  
! hd0_post_store_logical:
    mov   (0x003d + 0x00), bx ;; number of physical cylinders
    mov   (0x003d + 0x02), cl ;; number of physical heads
    ;; checksum
    mov   cl, #0x0f     ;; repeat count
    mov   si, #0x003d   ;; offset to disk0 FDPT
    mov   al, #0x00     ;; sum
! hd0_post_checksum_loop:
    add   al, [si]
    inc   si
    dec   cl
!   jnz hd0_post_checksum_loop
    not   al  ;; now take 2s complement
    inc   al
    mov   [si], al
+ ;;; Done filling EBDA table for hard disk 0.
+ 
+ hd1_setup:
+ ;;; Filling EBDA table for hard disk 1.
+   mov  al, #0x28
+   out  #0x70, al
+   in   al, #0x71
+   mov  ah, al
+   mov  al, #0x27
+   out  #0x70, al
+   in   al, #0x71
+   mov   (0x004d + 0x05), ax ;; write precomp word
+ 
+   mov  al, #0x29
+   out  #0x70, al
+   in   al, #0x71
+   mov   (0x004d + 0x08), al ;; drive control byte
+ 
+   mov  al, #0x2b
+   out  #0x70, al
+   in   al, #0x71
+   mov  ah, al
+   mov  al, #0x2a
+   out  #0x70, al
+   in   al, #0x71
+   mov   (0x004d + 0x0C), ax ;; landing zone word
+ 
+   mov  al, #0x25   ;; get cylinders word in AX
+   out  #0x70, al
+   in   al, #0x71   ;; high byte
+   mov  ah, al
+   mov  al, #0x24
+   out  #0x70, al
+   in   al, #0x71   ;; low byte
+   mov  bx, ax      ;; BX = cylinders
+ 
+   mov  al, #0x26
+   out  #0x70, al
+   in   al, #0x71
+   mov  cl, al      ;; CL = heads
+ 
+   mov  al, #0x2c
+   out  #0x70, al
+   in   al, #0x71
+   mov  dl, al      ;; DL = sectors
+ 
+   cmp  bx, #1024
+   jnbe hd1_post_logical_chs ;; if cylinders > 1024, use translated style CHS
+ 
+ hd1_post_physical_chs:
+   ;; no logical CHS mapping used, just physical CHS
+   ;; use Standard Fixed Disk Parameter Table (FDPT)
+   mov   (0x004d + 0x00), bx ;; number of physical cylinders
+   mov   (0x004d + 0x02), cl ;; number of physical heads
+   mov   (0x004d + 0x0E), dl ;; number of physical sectors
+   ret
+ 
+ hd1_post_logical_chs:
+   ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
+   mov   (0x004d + 0x09), bx ;; number of physical cylinders
+   mov   (0x004d + 0x0b), cl ;; number of physical heads
+   mov   (0x004d + 0x04), dl ;; number of physical sectors
+   mov   (0x004d + 0x0e), dl ;; number of logical sectors (same)
+   mov al, #0xa0
+   mov   (0x004d + 0x03), al ;; A0h signature, indicates translated table
+ 
+   cmp bx, #2048
+   jnbe hd1_post_above_2048
+   ;; 1024 < c <= 2048 cylinders
+   shr bx, #0x01
+   shl cl, #0x01
+   jmp hd1_post_store_logical
+ 
+ hd1_post_above_2048:
+   cmp bx, #4096
+   jnbe hd1_post_above_4096
+   ;; 2048 < c <= 4096 cylinders
+   shr bx, #0x02
+   shl cl, #0x02
+   jmp hd1_post_store_logical
+ 
+ hd1_post_above_4096:
+   cmp bx, #8192
+   jnbe hd1_post_above_8192
+   ;; 4096 < c <= 8192 cylinders
+   shr bx, #0x03
+   shl cl, #0x03
+   jmp hd1_post_store_logical
+ 
+ hd1_post_above_8192:
+   ;; 8192 < c <= 16384 cylinders
+   shr bx, #0x04
+   shl cl, #0x04
+ 
+ hd1_post_store_logical:
+   mov   (0x004d + 0x00), bx ;; number of physical cylinders
+   mov   (0x004d + 0x02), cl ;; number of physical heads
+   ;; checksum
+   mov   cl, #0x0f     ;; repeat count
+   mov   si, #0x004d   ;; offset to disk0 FDPT
+   mov   al, #0x00     ;; sum
+ hd1_post_checksum_loop:
+   add   al, [si]
+   inc   si
+   dec   cl
+   jnz hd1_post_checksum_loop
+   not   al  ;; now take 2s complement
+   inc   al
+   mov   [si], al
+ ;;; Done filling EBDA table for hard disk 0.
+ 
    ret
  
  
Index: iodev/harddrv.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/iodev/harddrv.cc,v
retrieving revision 1.5
diff -c -r1.5 harddrv.cc
*** iodev/harddrv.cc	2001/05/03 00:41:36	1.5
--- iodev/harddrv.cc	2001/05/03 15:42:37
***************
*** 93,98 ****
--- 93,111 ----
      BX_HD_THIS devices->register_io_write_handler(this, write_handler,
                                          addr, "Hard Drive 0");
      }
+ #if 0
+   // this would be necessary to make the second HD master on the
+   // second controller, using 0x170-0x177 and irq15.  But it currently
+   // works as second disk on the first IDE controller, so this code
+   // is not needed.
+   BX_HD_THIS devices->register_irq(15, "Hard Drive 1");
+   for (unsigned addr=0x0170; addr<=0x0177; addr++) {
+     BX_HD_THIS devices->register_io_read_handler(this, read_handler,
+                                         addr, "Hard Drive 1");
+     BX_HD_THIS devices->register_io_write_handler(this, write_handler,
+                                         addr, "Hard Drive 1");
+     }
+ #endif
  
    BX_HD_THIS drive_select = 0;
  
***************
*** 180,198 ****
--- 193,248 ----
    if (!bx_options.cmos.cmosImage) {
      cmos->s.reg[0x12] = 0x00; // start out with: no drive 0, no drive 1
  
+ //set up cmos for first hard drive
+ //maybe should be conditional on diskc.present.
      // Flag drive type as Fh, use extended CMOS location as real type
      cmos->s.reg[0x12] = (cmos->s.reg[0x12] & 0x0f) | 0xf0;
      cmos->s.reg[0x19] = 47; // user definable type
+     // AMI BIOS: 1st hard disk #cyl low byte
      cmos->s.reg[0x1b] = (bx_options.diskc.cylinders & 0x00ff);
+     // AMI BIOS: 1st hard disk #cyl high byte
      cmos->s.reg[0x1c] = (bx_options.diskc.cylinders & 0xff00) >> 8;
+     // AMI BIOS: 1st hard disk #heads
      cmos->s.reg[0x1d] = (bx_options.diskc.heads);
+     // AMI BIOS: 1st hard disk write precompensation cylinder, low byte
      cmos->s.reg[0x1e] = 0xff; // -1
+     // AMI BIOS: 1st hard disk write precompensation cylinder, high byte
      cmos->s.reg[0x1f] = 0xff; // -1
+     // AMI BIOS: 1st hard disk control byte
      cmos->s.reg[0x20] = 0xc0 | ((bx_options.diskc.heads > 8) << 3);
+     // AMI BIOS: 1st hard disk landing zone, low byte
      cmos->s.reg[0x21] = cmos->s.reg[0x1b];
+     // AMI BIOS: 1st hard disk landing zone, high byte
      cmos->s.reg[0x22] = cmos->s.reg[0x1c];
+     // AMI BIOS: 1st hard disk sectors/track
      cmos->s.reg[0x23] = bx_options.diskc.spt;
  
+     //set up cmos for second hard drive
+     if (bx_options.diskd.present) {
+       bx_printf ("[diskd] I will put 0xf into the second hard disk field");
+       // fill in lower 4 bits of 0x12 for second HD
+       cmos->s.reg[0x12] = (cmos->s.reg[0x12] & 0xf0) | 0x0f;
+       cmos->s.reg[0x1a] = 47; // user definable type
+       // AMI BIOS: 2nd hard disk #cyl low byte
+       cmos->s.reg[0x24] = (bx_options.diskd.cylinders & 0x00ff);
+       // AMI BIOS: 2nd hard disk #cyl high byte
+       cmos->s.reg[0x25] = (bx_options.diskd.cylinders & 0xff00) >> 8;
+       // AMI BIOS: 2nd hard disk #heads
+       cmos->s.reg[0x26] = (bx_options.diskd.heads);
+       // AMI BIOS: 2nd hard disk write precompensation cylinder, low byte
+       cmos->s.reg[0x27] = 0xff; // -1
+       // AMI BIOS: 2nd hard disk write precompensation cylinder, high byte
+       cmos->s.reg[0x28] = 0xff; // -1
+       // AMI BIOS: 2nd hard disk, 0x80 if heads>8
+       cmos->s.reg[0x29] = (bx_options.diskd.heads > 8) ? 0x80 : 0x00;
+       // AMI BIOS: 2nd hard disk landing zone, low byte
+       cmos->s.reg[0x2a] = cmos->s.reg[0x1b];
+       // AMI BIOS: 2nd hard disk landing zone, high byte
+       cmos->s.reg[0x2b] = cmos->s.reg[0x1c];
+       // AMI BIOS: 2nd hard disk sectors/track
+       cmos->s.reg[0x2c] = bx_options.diskd.spt;
+     }
+ 
  
      if ( bx_options.bootdrive[0] == 'c' ) {
        // system boot sequence C:, A:
***************
*** 555,560 ****
--- 605,623 ----
        goto return_value8;
        break;
  
+ #if 0
+       // you'll need these to support second IDE controller, not needed yet.
+       case 0x170:
+       case 0x171:
+       case 0x172:
+       case 0x173:
+       case 0x174:
+       case 0x175:
+       case 0x176:
+       case 0x177:
+ 	    bx_printf ("[disk] ignoring read from 0x%04x\n", address);
+        break;
+ #endif
      default:
        bx_panic("hard drive: io read to address %x unsupported\n",
          (unsigned) address);
***************
*** 1619,1624 ****
--- 1682,1700 ----
  		}
  	  }
  	  break;
+ #if 0
+       // you'll need these to support second IDE controller, not needed yet.
+     case 0x170:
+     case 0x171:
+     case 0x172:
+     case 0x173:
+     case 0x174:
+     case 0x175:
+     case 0x176:
+     case 0x177:
+ 	  bx_printf ("[disk] ignoring write to 0x%04x\n", address);
+        break;
+ #endif
  
      default:
        bx_panic("hard drive: io write to address %x = %02x\n",
***************
*** 2233,2241 ****
  bx_hard_drive_c::raise_interrupt()
  {
        if (!BX_SELECTED_CONTROLLER.control.disable_irq) {
  	    if (bx_dbg.disk || (CDROM_SELECTED && bx_dbg.cdrom))
! 		  bx_printf("disk: Raising interrupt {%s}\n", DEVICE_TYPE_STRING);
! 	    BX_HD_THIS devices->pic->trigger_irq(14);
        } else {
  	    if (bx_dbg.disk || (CDROM_SELECTED && bx_dbg.cdrom))
  		  bx_printf("disk: Interrupt masked {%s}\n", DEVICE_TYPE_STRING);
--- 2309,2319 ----
  bx_hard_drive_c::raise_interrupt()
  {
        if (!BX_SELECTED_CONTROLLER.control.disable_irq) {
+ 	    Bit32u irq = 14;  // always 1st IDE controller
+ 	    // for second controller, you would want irq 15
  	    if (bx_dbg.disk || (CDROM_SELECTED && bx_dbg.cdrom))
! 		  bx_printf("disk: Raising interrupt %d {%s}\n", irq, DEVICE_TYPE_STRING);
! 	    BX_HD_THIS devices->pic->trigger_irq(irq);
        } else {
  	    if (bx_dbg.disk || (CDROM_SELECTED && bx_dbg.cdrom))
  		  bx_printf("disk: Interrupt masked {%s}\n", DEVICE_TYPE_STRING);
