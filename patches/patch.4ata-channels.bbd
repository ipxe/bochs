----------------------------------------------------------------------
Patch name: patches/patch.4ata-channels.bbd
Author: Bryce Denney
Date: Tue Sep 17 09:44:40 EDT 2002

This patch applies on top of Christophe Bothamy's 4ata-channels patch.
I'm keeping a separate patch in case Christophe wants to make revisions
to his patch without my changes getting in the way.

I have just been working on the configuration interface part, for
example making it so that when you disable the ata[0123] channel, all the
devices controlled by that channel will be disabled as well.  I haven't
gotten around to the wxWindows part, but these changes will make the 
wxWindows work much easier.

- set default I/O address for all ata channels, even the ones which are
  disabled by default.  It's easier to configure from scratch if we have
  reasonable defaults already.  (I know many options default to zero instead
  of reasonable defaults, but I don't like that either.)
- eliminate huge initialization lists atachannel_init_list[][] and
  atadevice_init_list[][] by creating the bx_list_c and calling the add()
  method from inside a loop.
- Also I'm using a trick: since the dependent_list and the menus contain almost
  the same items, I build just one list at first.  Then since I need to add a
  few more items to the dependent list (but I don't want them to show on the
  menu) I call bx_list_c::clone() to make a copy to use as the dependent list.
  Example:
    BXP_ATA0 menu: 
      BXP_ATA0_PRESENT, BXP_ATA0_IOADDR1, BXP_ATA0_IOADDR2, BXP_ATA0_IRQ
    dependent list for BXP_ATA0_PRESENT:
      BXP_ATA0_PRESENT, BXP_ATA0_IOADDR1, BXP_ATA0_IOADDR2, BXP_ATA0_IRQ,
      BXP_ATA0_MASTER, BXP_ATA0_SLAVE
- the ata devices have both a "present" boolean parameter and a "type" enum
  parameter.  I removed the "none" value in the type enum, because it was
  the same as having present=false.  This made the enable/disable logic
  somewhat easier.
- Now the ATA channel present parameters have a dependent_list which includes
  both the ATA channel parameters and also the ATA device parameters that are
  on that channel.  This way, when you disable the ATA channel, the devices on
  the channel will be disabled too.  I am using the dependent_list instead of
  the callback function that calls set_enable because it allows wxWindows to do
  the enable/disables without any special code to handle each case.
- a few changes relating to bx_param_num_c::update_dependents():
  - don't allow a parameter to disable itself.  This allows the "present" param
    to be included in its own dependency list without danger of disabling
    itself forever.
  - before, if a param with dependents had a value of zero, it would disable
    its dependent parameters.  Now it will also disable its dependents
    if the param itself is disabled.
  - when a parameter with dependents is enabled/disabled, it now calls 
    update_dependents() as well.  Before this only happened when the value was
    changed.
- add clone() method of bx_list_c, which makes a copy.

I could not use the dependent_list trick to handle the "type" field of
the ATA devices.  When type=disk, it's supposed to enable cylinders, heads,
and spt, but when type=cdrom, it's supposed to disable C/H/S and enable the
inserted/ejected param instead.  There's currently no way to do this with
dependent_list, so I left this behavior in the bx_param_handler callback 
function.

The problem with using callback functions to handle the enabling of other
parameters (and the reason that I've been moving away from them for this
purpose) is that in a GUI dialog box, you don't want to change any parameter
value until the user presses "Ok".  If callback functions control the enabling
of other parameters, I cannot know which parts of the dialog to enable/disable
without modifying the parameter with set().  

Possible solutions:
1) have the dialog box code remember the old value of every param, to be able
to implement Cancel.
2) in each param structure, remember the new value and the previous value.
Then if the user presses cancel, I can revert each param back to its previous
value.
3) for special cases such as enabling C/H/S when type=disk, duplicate
the enable/disable code in each implementation of the user interface.

Patch was created with:
  diff -ur between two directories
Apply patch to what version:
  current cvs, with Christophe Bothamy's patch.4ata-channels already applied
Instructions:
  To patch, go to main bochs directory.
  Type "patch -p1 < THIS_PATCH_FILE".
----------------------------------------------------------------------

diff -ur -x *CVS* -x .conf* -x .#* fourata-clean/gui/siminterface.cc fourata/gui/siminterface.cc
--- fourata-clean/gui/siminterface.cc	Tue Sep 17 09:21:00 2002
+++ fourata/gui/siminterface.cc	Tue Sep 17 09:35:03 2002
@@ -354,8 +354,8 @@
 int n_loader_os_names = 3;
 char *keyboard_type_names[] = { "xt", "at", "mf", NULL };
 int n_keyboard_type_names = 3;
-char *atadevice_type_names[] = { "none", "disk", "cdrom", NULL };
-int n_atadevice_type_names = 3;
+char *atadevice_type_names[] = { "disk", "cdrom", NULL };
+int n_atadevice_type_names = 2;
 char *atadevice_status_names[] = { "ejected", "inserted", NULL };
 int n_atadevice_status_names = 2;
 char *atadevice_biosdetect_names[] = { "none", "auto", "cmos", NULL };
@@ -692,12 +692,22 @@
 void bx_param_num_c::update_dependents ()
 {
   if (dependent_list) {
-    int en = val.number? 1 : 0;
-    for (int i=0; i<dependent_list->get_size (); i++)
-      dependent_list->get (i)->set_enabled (en);
+    int en = val.number && enabled;
+    for (int i=0; i<dependent_list->get_size (); i++) {
+      bx_param_c *param = dependent_list->get (i);
+      if (param != this)
+	param->set_enabled (en);
+    }
   }
 }
 
+void
+bx_param_num_c::set_enabled (int en)
+{
+  bx_param_c::set_enabled (en);
+  update_dependents ();
+}
+
 bx_shadow_num_c::bx_shadow_num_c (bx_id id,
     char *name,
     char *description,
@@ -1046,6 +1056,17 @@
   this->parent = NULL;
 }
 
+bx_list_c *
+bx_list_c::clone ()
+{
+  bx_list_c *newlist = new bx_list_c (BXP_NULL, name, description, maxsize);
+  for (int i=0; i<get_size (); i++)
+    newlist->add (get(i));
+  newlist->set_options (get_options ());
+  newlist->set_parent (get_parent ());
+  return newlist;
+}
+
 void
 bx_list_c::add (bx_param_c *param)
 {
@@ -1062,8 +1083,3 @@
   return list[index];
 }
 
-void
-bx_list_c::set_parent (bx_param_c *parent)
-{
-  this->parent = parent;
-}
diff -ur -x *CVS* -x .conf* -x .#* fourata-clean/gui/siminterface.h fourata/gui/siminterface.h
--- fourata-clean/gui/siminterface.h	Tue Sep 17 09:21:01 2002
+++ fourata/gui/siminterface.h	Tue Sep 17 09:34:08 2002
@@ -145,7 +145,6 @@
   BXP_FLOPPYB_TYPE,
   BXP_FLOPPYB_STATUS,
   BXP_FLOPPYB,
-  
   BXP_ATA0,
   BXP_ATA1,
   BXP_ATA2,
@@ -254,7 +253,6 @@
   BXP_ATA2_SLAVE_TRANSLATION,
   BXP_ATA3_MASTER_TRANSLATION,
   BXP_ATA3_SLAVE_TRANSLATION,
-
 #define BXP_PARAMS_PER_SERIAL_PORT 2
   BXP_COM1_ENABLED,
   BXP_COM1_PATH,
@@ -760,7 +758,7 @@
   char *get_name () { return name; }
   char *get_description () { return description; }
   int get_enabled () { return enabled; }
-  void set_enabled (int enabled) { this->enabled = enabled; }
+  virtual void set_enabled (int enabled) { this->enabled = enabled; }
   void reset () {}
   int getint () {return -1;}
   static const char* set_default_format (const char *f);
@@ -804,6 +802,7 @@
     dependent_list = l; 
     update_dependents ();
   }
+  virtual void set_enabled (int enabled);
   virtual Bit32s get ();
   virtual void set (Bit32s val);
   void set_base (int base) { this->base = base; }
@@ -988,13 +987,16 @@
   bx_list_c (bx_id id, char *name, char *description, bx_param_c **init_list);
   bx_list_c (bx_id id, char *name, char *description, int maxsize);
   virtual ~bx_list_c();
+  bx_list_c *clone ();
   void add (bx_param_c *param);
   bx_param_c *get (int index);
   int get_size () { return size; }
   bx_param_num_c *get_options () { return options; }
+  void set_options (bx_param_num_c *newopt) { options = newopt; }
   bx_param_num_c *get_choice () { return choice; }
   bx_param_string_c *get_title () { return title; }
-  void set_parent (bx_param_c *parent);
+  void set_parent (bx_param_c *newparent) { parent = newparent; }
+  bx_param_c *get_parent () { return parent; }
 #if BX_UI_TEXT
   virtual void text_print (FILE *);
   virtual int text_ask (FILE *fpin, FILE *fpout);
@@ -1013,10 +1015,9 @@
 #define BX_FLOPPY_LAST   15 // last legal value of floppy type
 #define BX_FLOPPY_GUESS  20 // decide based on image size
 
-#define BX_ATA_DEVICE_NONE      0
-#define BX_ATA_DEVICE_DISK      1
-#define BX_ATA_DEVICE_CDROM     2
-#define BX_ATA_DEVICE_LAST      2
+#define BX_ATA_DEVICE_DISK      0
+#define BX_ATA_DEVICE_CDROM     1
+#define BX_ATA_DEVICE_LAST      1
 
 #define BX_ATA_BIOSDETECT_NONE      0
 #define BX_ATA_BIOSDETECT_AUTO      1
diff -ur -x *CVS* -x .conf* -x .#* fourata-clean/main.cc fourata/main.cc
--- fourata-clean/main.cc	Mon Sep 16 23:23:45 2002
+++ fourata/main.cc	Tue Sep 17 09:37:26 2002
@@ -153,20 +153,6 @@
     case BXP_KBD_PASTE_DELAY:
       if (set) bx_keyboard.paste_delay_changed ();
       break;
-    case BXP_ATA0_PRESENT:
-    case BXP_ATA1_PRESENT:
-    case BXP_ATA2_PRESENT:
-    case BXP_ATA3_PRESENT:
-      if (set) {
-        int channel = id - BXP_ATA0_PRESENT;
-	int enable = (val != 0);
-
-	SIM->get_param ((bx_id)(BXP_ATA0_IOADDR1 + channel))->set_enabled (enable);
-	SIM->get_param ((bx_id)(BXP_ATA0_IOADDR2 + channel))->set_enabled (enable);
-	SIM->get_param ((bx_id)(BXP_ATA0_IRQ + channel))->set_enabled (enable);
-        }
-      break;
-
     case BXP_ATA0_MASTER_TYPE:
     case BXP_ATA0_SLAVE_TYPE:
     case BXP_ATA1_MASTER_TYPE:
@@ -178,17 +164,6 @@
       if (set) {
         int device = id - BXP_ATA0_MASTER_TYPE;
 	switch (val) {
-          case BX_ATA_DEVICE_NONE:
-            SIM->get_param_num ((bx_id)(BXP_ATA0_MASTER_PRESENT + device))->set (0);
-            SIM->get_param ((bx_id)(BXP_ATA0_MASTER_PATH + device))->set_enabled (0);
-            SIM->get_param ((bx_id)(BXP_ATA0_MASTER_CYLINDERS + device))->set_enabled (0);
-            SIM->get_param ((bx_id)(BXP_ATA0_MASTER_HEADS + device))->set_enabled (0);
-            SIM->get_param ((bx_id)(BXP_ATA0_MASTER_SPT + device))->set_enabled (0);
-            SIM->get_param ((bx_id)(BXP_ATA0_MASTER_STATUS + device))->set_enabled (0);
-            SIM->get_param ((bx_id)(BXP_ATA0_MASTER_MODEL + device))->set_enabled (0);
-            SIM->get_param ((bx_id)(BXP_ATA0_MASTER_BIOSDETECT + device))->set_enabled (0);
-            SIM->get_param ((bx_id)(BXP_ATA0_MASTER_TRANSLATION + device))->set_enabled (0);
-            break;
           case BX_ATA_DEVICE_DISK:
             SIM->get_param_num ((bx_id)(BXP_ATA0_MASTER_PRESENT + device))->set (1);
             SIM->get_param ((bx_id)(BXP_ATA0_MASTER_PATH + device))->set_enabled (1);
@@ -445,249 +420,148 @@
   bx_options.floppyb.Ostatus->set_handler (bx_param_handler);
 
   // disk options
+
+  // FIXME use descr and name
+  char *s_atachannel[] = {
+    "ATA channel 0",
+    "ATA channel 1",
+    "ATA channel 2",
+    "ATA channel 3",
+    };
+  char *s_atadevice[4][2] = {
+    { "Master ATA device on channel 0",
+      "Slave ATA device on channel 0" },
+    { "Master ATA device on channel 1",
+    "Slave ATA device on channel 1" },
+    { "Master ATA device on channel 2",
+    "Slave ATA device on channel 2" },
+    { "Master ATA device on channel 3",
+    "Slave ATA device on channel 3" }
+    };
+  Bit16u ata_default_ioaddr1[BX_MAX_ATA_CHANNEL] = {
+    0x1f0, 0x170, 0x1e8, 0x168 
+  };
+  Bit8u ata_default_irq[BX_MAX_ATA_CHANNEL] = { 
+    14, 15, 12, 11 
+  };
+
+  bx_list_c *ata[BX_MAX_ATA_CHANNEL];
+
   for (Bit8u channel=0; channel<BX_MAX_ATA_CHANNEL; channel ++) {
 
-    bx_options.ata[channel].Opresent = new bx_param_bool_c ((bx_id)(BXP_ATA0_PRESENT+channel),
+    ata[channel] = new bx_list_c ((bx_id)(BXP_ATA0+channel), s_atachannel[channel], s_atachannel[channel], 8);
+    ata[channel]->get_options ()->set (ata[channel]->BX_SERIES_ASK);
+
+    ata[channel]->add (bx_options.ata[channel].Opresent = new bx_param_bool_c ((bx_id)(BXP_ATA0_PRESENT+channel),
       "ata:present",                                
       "Controls whether ata channel is installed or not",
-      0);
+      0));
 
-    bx_options.ata[channel].Oioaddr1 = new bx_param_num_c ((bx_id)(BXP_ATA0_IOADDR1+channel),
+    ata[channel]->add (bx_options.ata[channel].Oioaddr1 = new bx_param_num_c ((bx_id)(BXP_ATA0_IOADDR1+channel),
       "ata:ioaddr1",
       "IO adress of ata command block",
       0, 0xffff,
-      0);
+      ata_default_ioaddr1[channel]));
 
-    bx_options.ata[channel].Oioaddr2 = new bx_param_num_c ((bx_id)(BXP_ATA0_IOADDR2+channel),
+    ata[channel]->add (bx_options.ata[channel].Oioaddr2 = new bx_param_num_c ((bx_id)(BXP_ATA0_IOADDR2+channel),
       "ata:ioaddr2",
       "IO adress of ata control block",
       0, 0xffff,
-      0);
+      ata_default_ioaddr1[channel] + 0x200));
 
-    bx_options.ata[channel].Oirq = new bx_param_num_c ((bx_id)(BXP_ATA0_IRQ+channel),
+    ata[channel]->add (bx_options.ata[channel].Oirq = new bx_param_num_c ((bx_id)(BXP_ATA0_IRQ+channel),
       "ata:irq",
       "IRQ of ata ",
       0, 15,
-      0);
+      ata_default_irq[channel]));
+
+    // all items in the ata[channel] menu depend on the present flag.
+    // The menu list is complete, but a few dependent_list items will
+    // be added later.  Use clone() to make a copy of the dependent_list
+    // so that it can be changed without affecting the menu.
+    bx_options.ata[channel].Opresent->set_dependent_list (
+	ata[channel]->clone());
 
     for (Bit8u slave=0; slave<2; slave++) {
 
-      bx_options.atadevice[channel][slave].Otype = new bx_param_enum_c ((bx_id)(BXP_ATA0_MASTER_TYPE+channel*2+slave),
-          "ata-device:type",
-          "Type of ATA device",
-          atadevice_type_names,
-          BX_ATA_DEVICE_NONE,
-          BX_ATA_DEVICE_NONE);
+      menu = new bx_list_c ((bx_id)(BXP_ATA0_MASTER+channel*2+slave), s_atadevice[channel][slave], 
+               s_atadevice[channel][slave], 12);
+      menu->get_options ()->set (menu->BX_SERIES_ASK);
 
-      bx_options.atadevice[channel][slave].Opresent = new bx_param_bool_c ((bx_id)(BXP_ATA0_MASTER_PRESENT+channel*2+slave),
+      menu->add (bx_options.atadevice[channel][slave].Opresent = new bx_param_bool_c ((bx_id)(BXP_ATA0_MASTER_PRESENT+channel*2+slave),
         "ata-device:present",                                
         "Controls whether ata device is installed or not",  
-        0);
+        0));
+
+      menu->add (bx_options.atadevice[channel][slave].Otype = new bx_param_enum_c ((bx_id)(BXP_ATA0_MASTER_TYPE+channel*2+slave),
+          "ata-device:type",
+          "Type of ATA device",
+          atadevice_type_names,
+          BX_ATA_DEVICE_DISK,
+          BX_ATA_DEVICE_DISK));
 
-      bx_options.atadevice[channel][slave].Opath = new bx_param_filename_c ((bx_id)(BXP_ATA0_MASTER_PATH+channel*2+slave),
+      menu->add (bx_options.atadevice[channel][slave].Opath = new bx_param_filename_c ((bx_id)(BXP_ATA0_MASTER_PATH+channel*2+slave),
           "ata-device:path",
           "Pathname of the image",
-          "", BX_PATHNAME_LEN);
+          "", BX_PATHNAME_LEN));
 
-      bx_options.atadevice[channel][slave].Ocylinders = new bx_param_num_c ((bx_id)(BXP_ATA0_MASTER_CYLINDERS+channel*2+slave),
+      menu->add (bx_options.atadevice[channel][slave].Ocylinders = new bx_param_num_c ((bx_id)(BXP_ATA0_MASTER_CYLINDERS+channel*2+slave),
           "ata-device:cylinders",
           "Number of cylinders",
           0, 65535,
-          0);
-      bx_options.atadevice[channel][slave].Oheads = new bx_param_num_c ((bx_id)(BXP_ATA0_MASTER_HEADS+channel*2+slave),
+          0));
+      menu->add (bx_options.atadevice[channel][slave].Oheads = new bx_param_num_c ((bx_id)(BXP_ATA0_MASTER_HEADS+channel*2+slave),
           "ata-device:heads",
           "Number of heads",
           0, 65535,
-          0);
-      bx_options.atadevice[channel][slave].Ospt = new bx_param_num_c ((bx_id)(BXP_ATA0_MASTER_SPT+channel*2+slave),
+          0));
+      menu->add (bx_options.atadevice[channel][slave].Ospt = new bx_param_num_c ((bx_id)(BXP_ATA0_MASTER_SPT+channel*2+slave),
           "ata-device:spt",
           "Number of sectors per track",
           0, 65535,
-          0);
+          0));
       
-      bx_options.atadevice[channel][slave].Ostatus = new bx_param_enum_c ((bx_id)(BXP_ATA0_MASTER_STATUS+channel*2+slave),
+      menu->add (bx_options.atadevice[channel][slave].Ostatus = new bx_param_enum_c ((bx_id)(BXP_ATA0_MASTER_STATUS+channel*2+slave),
        "ata-device:status",
        "Inserted or ejected",
        atadevice_status_names,
        BX_INSERTED,
-       BX_EJECTED);
+       BX_EJECTED));
 
-      bx_options.atadevice[channel][slave].Omodel = new bx_param_string_c ((bx_id)(BXP_ATA0_MASTER_MODEL+channel*2+slave),
+      menu->add (bx_options.atadevice[channel][slave].Omodel = new bx_param_string_c ((bx_id)(BXP_ATA0_MASTER_MODEL+channel*2+slave),
        "ata-device:model",
        "Model name",
-       "Generic 1234", 40);
+       "Generic 1234", 40));
 
-      bx_options.atadevice[channel][slave].Obiosdetect = new bx_param_enum_c ((bx_id)(BXP_ATA0_MASTER_BIOSDETECT+channel*2+slave),
+      menu->add (bx_options.atadevice[channel][slave].Obiosdetect = new bx_param_enum_c ((bx_id)(BXP_ATA0_MASTER_BIOSDETECT+channel*2+slave),
        "ata-device:biosdetect",
        "Type of bios detection",
        atadevice_biosdetect_names,
        BX_ATA_BIOSDETECT_AUTO,
-       BX_ATA_BIOSDETECT_NONE);
+       BX_ATA_BIOSDETECT_NONE));
 
-      bx_options.atadevice[channel][slave].Otranslation = new bx_param_enum_c ((bx_id)(BXP_ATA0_MASTER_TRANSLATION+channel*2+slave),
+      menu->add (bx_options.atadevice[channel][slave].Otranslation = new bx_param_enum_c ((bx_id)(BXP_ATA0_MASTER_TRANSLATION+channel*2+slave),
        "How the ata-disk translation is done by the bios",
        "Type of translation",
        atadevice_translation_names,
        BX_ATA_TRANSLATION_LBA,
-       BX_ATA_TRANSLATION_NONE);
+       BX_ATA_TRANSLATION_NONE));
 
+      bx_options.atadevice[channel][slave].Opresent->set_dependent_list (menu);
+      bx_options.ata[channel].Opresent->get_dependent_list()->add (menu);
+      //bx_options.ata[channel].Opresent->get_dependent_list()->add (
+	  //bx_options.atadevice[channel][slave].Opresent);
       }
     }
 
-  // Set initial values (enabled, std ports & irq) for first ata interface
+  // Enable first ata interface by default, disable the others.
   bx_options.ata[0].Opresent->set_initial_val(1);
-  bx_options.ata[0].Oioaddr1->set_initial_val(0x1f0);
-  bx_options.ata[0].Oioaddr2->set_initial_val(0x3f0);
-  bx_options.ata[0].Oirq->set_initial_val(14);
-
-  // FIXME use descr and name
-  char *s_atachannel[] = {
-    "ATA channel 0",
-    "ATA channel 1",
-    "ATA channel 2",
-    "ATA channel 3",
-    };
-  char *s_atadevice[][2] = {
-    "Master ATA device on channel 0",
-    "Slave ATA device on channel 0",
-    "Master ATA device on channel 1",
-    "Slave ATA device on channel 1",
-    "Master ATA device on channel 2",
-    "Slave ATA device on channel 2",
-    "Master ATA device on channel 3",
-    "Slave ATA device on channel 3",
-    };
 
-  bx_param_c *atachannel_init_list[BX_MAX_ATA_CHANNEL][5] = {
-    { bx_options.ata[0].Opresent,
-      bx_options.ata[0].Oioaddr1,
-      bx_options.ata[0].Oioaddr2,
-      bx_options.ata[0].Oirq,
-      NULL
-    },
-#if BX_MAX_ATA_CHANNEL>1
-    { bx_options.ata[1].Opresent,
-      bx_options.ata[1].Oioaddr1,
-      bx_options.ata[1].Oioaddr2,
-      bx_options.ata[1].Oirq,
-      NULL
-    },
-#endif
-#if BX_MAX_ATA_CHANNEL>2
-    { bx_options.ata[2].Opresent,
-      bx_options.ata[2].Oioaddr1,
-      bx_options.ata[2].Oioaddr2,
-      bx_options.ata[2].Oirq,
-      NULL
-    },
-#endif
-#if BX_MAX_ATA_CHANNEL>3
-    { bx_options.ata[3].Opresent,
-      bx_options.ata[3].Oioaddr1,
-      bx_options.ata[3].Oioaddr2,
-      bx_options.ata[3].Oirq,
-      NULL
-    },
-#endif
-  };
+  // now that the dependence relationships are established, call set() on
+  // the ata device present params to set all enables correctly.
+  for (i=0; i<BX_MAX_ATA_CHANNEL; i++)
+    bx_options.ata[i].Opresent->set (i==0);
 
-  bx_param_c *atadevice_init_list[BX_MAX_ATA_CHANNEL*2][10] = {
-    { bx_options.atadevice[0][0].Otype,
-      bx_options.atadevice[0][0].Opath,
-      bx_options.atadevice[0][0].Ocylinders,
-      bx_options.atadevice[0][0].Oheads,
-      bx_options.atadevice[0][0].Ospt,
-      bx_options.atadevice[0][0].Ostatus,
-      bx_options.atadevice[0][0].Omodel,
-      bx_options.atadevice[0][0].Obiosdetect,
-      bx_options.atadevice[0][0].Otranslation,
-      NULL
-    },
-    { bx_options.atadevice[0][1].Otype,
-      bx_options.atadevice[0][1].Opath,
-      bx_options.atadevice[0][1].Ocylinders,
-      bx_options.atadevice[0][1].Oheads,
-      bx_options.atadevice[0][1].Ospt,
-      bx_options.atadevice[0][1].Ostatus,
-      bx_options.atadevice[0][1].Omodel,
-      bx_options.atadevice[0][1].Obiosdetect,
-      bx_options.atadevice[0][1].Otranslation,
-      NULL
-    },
-#if BX_MAX_ATA_CHANNEL>1
-    { bx_options.atadevice[1][0].Otype,
-      bx_options.atadevice[1][0].Opath,
-      bx_options.atadevice[1][0].Ocylinders,
-      bx_options.atadevice[1][0].Oheads,
-      bx_options.atadevice[1][0].Ospt,
-      bx_options.atadevice[1][0].Ostatus,
-      bx_options.atadevice[1][0].Omodel,
-      bx_options.atadevice[1][0].Obiosdetect,
-      bx_options.atadevice[1][0].Otranslation,
-      NULL
-    },
-    { bx_options.atadevice[1][1].Otype,
-      bx_options.atadevice[1][1].Opath,
-      bx_options.atadevice[1][1].Ocylinders,
-      bx_options.atadevice[1][1].Oheads,
-      bx_options.atadevice[1][1].Ospt,
-      bx_options.atadevice[1][1].Ostatus,
-      bx_options.atadevice[1][1].Omodel,
-      bx_options.atadevice[1][1].Obiosdetect,
-      bx_options.atadevice[1][1].Otranslation,
-      NULL
-    },
-#endif
-#if BX_MAX_ATA_CHANNEL>2
-    { bx_options.atadevice[2][0].Otype,
-      bx_options.atadevice[2][0].Opath,
-      bx_options.atadevice[2][0].Ocylinders,
-      bx_options.atadevice[2][0].Oheads,
-      bx_options.atadevice[2][0].Ospt,
-      bx_options.atadevice[2][0].Ostatus,
-      bx_options.atadevice[2][0].Omodel,
-      bx_options.atadevice[2][0].Obiosdetect,
-      bx_options.atadevice[2][0].Otranslation,
-      NULL
-    },
-    { bx_options.atadevice[2][1].Otype,
-      bx_options.atadevice[2][1].Opath,
-      bx_options.atadevice[2][1].Ocylinders,
-      bx_options.atadevice[2][1].Oheads,
-      bx_options.atadevice[2][1].Ospt,
-      bx_options.atadevice[2][1].Ostatus,
-      bx_options.atadevice[2][1].Omodel,
-      bx_options.atadevice[2][1].Obiosdetect,
-      bx_options.atadevice[2][1].Otranslation,
-      NULL
-    },
-#endif
-#if BX_MAX_ATA_CHANNEL>3
-    { bx_options.atadevice[3][0].Otype,
-      bx_options.atadevice[3][0].Opath,
-      bx_options.atadevice[3][0].Ocylinders,
-      bx_options.atadevice[3][0].Oheads,
-      bx_options.atadevice[3][0].Ospt,
-      bx_options.atadevice[3][0].Ostatus,
-      bx_options.atadevice[3][0].Omodel,
-      bx_options.atadevice[3][0].Obiosdetect,
-      bx_options.atadevice[3][0].Otranslation,
-      NULL
-    },
-    { bx_options.atadevice[3][1].Otype,
-      bx_options.atadevice[3][1].Opath,
-      bx_options.atadevice[3][1].Ocylinders,
-      bx_options.atadevice[3][1].Oheads,
-      bx_options.atadevice[3][1].Ospt,
-      bx_options.atadevice[3][1].Ostatus,
-      bx_options.atadevice[3][1].Omodel,
-      bx_options.atadevice[3][1].Obiosdetect,
-      bx_options.atadevice[3][1].Otranslation,
-      NULL
-    },
-#endif
-  };
-  
   for (Bit8u channel=0; channel<BX_MAX_ATA_CHANNEL; channel ++) {
 
     bx_options.ata[channel].Opresent->set_ask_format ("Channel is enabled: [%s] ");
@@ -701,14 +575,10 @@
     bx_options.ata[channel].Oioaddr1->set_base (16);
     bx_options.ata[channel].Oioaddr2->set_base (16);
 
-    menu = new bx_list_c ((bx_id)(BXP_ATA0+channel), s_atachannel[channel], s_atachannel[channel], atachannel_init_list[channel]);
-    menu->get_options ()->set (menu->BX_SERIES_ASK);
-
-    bx_options.ata[channel].Opresent->set_handler (bx_param_handler);
-
     for (Bit8u slave=0; slave<2; slave++) {
 
-      bx_options.atadevice[channel][slave].Otype->set_ask_format ("Enter type of ATA device or 'none' for no device: [%s] ");
+      bx_options.atadevice[channel][slave].Opresent->set_ask_format ("Device is enabled: [%s] ");
+      bx_options.atadevice[channel][slave].Otype->set_ask_format ("Enter type of ATA device, disk or cdrom: [%s] ");
       bx_options.atadevice[channel][slave].Opath->set_ask_format ("Enter new filename: [%s] ");
       bx_options.atadevice[channel][slave].Ocylinders->set_ask_format ("Enter number of cylinders: [%d] ");
       bx_options.atadevice[channel][slave].Oheads->set_ask_format ("Enter number of heads: [%d] ");
@@ -718,8 +588,9 @@
       bx_options.atadevice[channel][slave].Otranslation->set_ask_format ("Enter translation type: [%s]");
       bx_options.atadevice[channel][slave].Obiosdetect->set_ask_format ("Enter bios detection type: [%s]");
 
-      bx_options.atadevice[channel][slave].Otype->set_format ("%s");
-      bx_options.atadevice[channel][slave].Opath->set_format (" on %s");
+      bx_options.atadevice[channel][slave].Opresent->set_format ("enabled: %s");
+      bx_options.atadevice[channel][slave].Otype->set_format (", %s");
+      bx_options.atadevice[channel][slave].Opath->set_format (" on '%s'");
       bx_options.atadevice[channel][slave].Ocylinders->set_format (", %d cylinders");
       bx_options.atadevice[channel][slave].Oheads->set_format (", %d heads");
       bx_options.atadevice[channel][slave].Ospt->set_format (", %d sectors/track");
@@ -728,12 +599,7 @@
       bx_options.atadevice[channel][slave].Otranslation->set_format (", translation '%s'");
       bx_options.atadevice[channel][slave].Obiosdetect->set_format (", biosdetect '%s'");
 
-      menu = new bx_list_c ((bx_id)(BXP_ATA0_MASTER+channel*2+slave), s_atadevice[channel][slave], 
-               s_atadevice[channel][slave], atadevice_init_list[channel*2+slave]);
-      menu->get_options ()->set (menu->BX_SERIES_ASK);
-
       bx_options.atadevice[channel][slave].Otype->set_handler (bx_param_handler);
-      bx_options.atadevice[channel][slave].Otype->set(BX_ATA_DEVICE_NONE);
       
       bx_options.atadevice[channel][slave].Ostatus->set_handler (bx_param_handler);
       bx_options.atadevice[channel][slave].Opath->set_handler (bx_param_string_handler);
