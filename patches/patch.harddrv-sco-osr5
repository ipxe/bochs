----------------------------------------------------------------------
Patch name: patch.harddrv-sco-osr5
Author: Carl Sopchak
Date: May, 1st 2002

Detailed description:
 The attached patch contains the changes needed to
 harddrv.cc in order to install SCO's Open Server
 Release 5 (unix) O/S within bochs. Also required were
 changes to rombios.c that were made by Christophe
 Bothamy (that he kindly sent me). I believe the
 rombios.c changes were already committed to CVS.

 NOTE: These changes mostly implement functions that
 were not previously implemented. The changes I made
 were specifically to get past stop points during the
 OSR5 install. I do not know if they fully meet any
 requirements of any spec. (For example, the Stop Start
 Disk ATAPI command should read the disk's TOC, but that
 part was NOT implemented.) Also, I do not have any
 good way of throughly testing these mods.

 If there are changes needed to these, I'd be happy to
 make them, and test them to the best of my ability.
 Just let me know.

 Please make these mods part of the standard bochs
 distribution (after testing).

 Thanks,

 Carl 

Patch was created with:
  cvs diff -u
Apply patch to what version:
  cvs checked out on May, 1st 2002
Instructions:
  To patch, go to main bochs directory.
  Type "cd iodev"
  Type "patch -p0 < THIS_PATCH_FILE".
----------------------------------------------------------------------
Index: harddrv.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/iodev/harddrv.cc,v
retrieving revision 1.54
diff -u -r1.54 harddrv.cc
--- harddrv.cc	23 Apr 2002 07:44:34 -0000	1.54
+++ harddrv.cc	1 May 2002 18:16:33 -0000
@@ -1005,7 +1005,10 @@
 				    if (!LoEj && !Start) { // stop the disc
 					  BX_PANIC(("Stop disc not implemented"));
 				    } else if (!LoEj && Start) { // start the disc and read the TOC
-					  BX_PANIC(("Start disc not implemented"));
+					  // BX_PANIC(("Start disc not implemented"));
+					  BX_ERROR(("FIXME: ATAPI start disc not reading TOC"));
+					  atapi_cmd_nop();
+					  raise_interrupt();
 				    } else if (LoEj && !Start) { // Eject the disc
                                           atapi_cmd_nop();
                                           if (BX_HD_THIS s[1].cdrom.ready) {
@@ -1798,6 +1801,7 @@
 		    BX_SELECTED_CONTROLLER.status.busy = 0;
 
 	      } else {
+		BX_DEBUG(("ATAPI Device Reset on non-cd device"));
 		command_aborted(0x08);
 	      }
 	      break;
@@ -1845,6 +1849,35 @@
 	  raise_interrupt();
 	  break;
 
+	case 0x70:  // SEEK (cgs)
+	  if (BX_SELECTED_HD.device_type == IDE_DISK) {
+	    BX_DEBUG(("write cmd 0x70 (SEEK) executing"));
+            if (!calculate_logical_address(&logical_sector)) {
+	      BX_ERROR(("initial seek to sector %u out of bounds, aborting", logical_sector));
+              command_aborted(value);
+	      break;
+	    }
+            BX_SELECTED_CONTROLLER.error_register = 0;
+            BX_SELECTED_CONTROLLER.status.busy  = 0;
+            BX_SELECTED_CONTROLLER.status.drive_ready = 1;
+            BX_SELECTED_CONTROLLER.status.seek_complete = 1;
+            BX_SELECTED_CONTROLLER.status.drq   = 1;
+            BX_SELECTED_CONTROLLER.status.corrected_data = 0;
+            BX_SELECTED_CONTROLLER.status.err   = 0;
+            BX_SELECTED_CONTROLLER.buffer_index = 0;
+  	    BX_DEBUG(("s[0].controller.control.disable_irq = %02x", (BX_HD_THIS s[0]).controller.control.disable_irq));
+  	    BX_DEBUG(("s[1].controller.control.disable_irq = %02x", (BX_HD_THIS s[1]).controller.control.disable_irq));
+  	    BX_DEBUG(("SEEK completed.  error_register = %02x", BX_SELECTED_CONTROLLER.error_register));
+  	    raise_interrupt();
+  	    BX_DEBUG(("SEEK interrupt completed"));
+          } else {
+  	    BX_ERROR(("write cmd 0x70 (SEEK) not supported for non-disk"));
+  	    command_aborted(0x70); 
+  	  }
+          break;
+
+
+
 	// List all the write operations that are defined in the ATA/ATAPI spec
 	// that we don't support.  Commands that are listed here will cause a
 	// BX_ERROR, which is non-fatal, and the command will be aborted.
@@ -1874,7 +1907,6 @@
 	case 0x42: BX_ERROR(("write cmd 0x42 (READ VERIFY SECTORS EXT) not supported"));command_aborted(0x42); break;
 	case 0x50: BX_ERROR(("write cmd 0x50 (FORMAT TRACK) not supported")); command_aborted(0x50); break;
 	case 0x51: BX_ERROR(("write cmd 0x51 (CONFIGURE STREAM) not supported"));command_aborted(0x51); break;
-	case 0x70: BX_ERROR(("write cmd 0x70 (SEEK) not supported"));command_aborted(0x70); break;
 	case 0x87: BX_ERROR(("write cmd 0x87 (CFA TRANSLATE SECTOR) not supported"));command_aborted(0x87); break;
 	case 0x92: BX_ERROR(("write cmd 0x92 (DOWNLOAD MICROCODE) not supported"));command_aborted(0x92); break;
 	case 0x94: BX_ERROR(("write cmd 0x94 (STANDBY IMMEDIATE) not supported")); command_aborted(0x94); break;
@@ -1932,7 +1964,9 @@
 	  prev_control_reset = BX_SELECTED_CONTROLLER.control.reset;
 	  BX_HD_THIS s[0].controller.control.reset         = value & 0x04;
 	  BX_HD_THIS s[1].controller.control.reset         = value & 0x04;
-	  BX_SELECTED_CONTROLLER.control.disable_irq    = value & 0x02;
+	  // CGS: was: BX_SELECTED_CONTROLLER.control.disable_irq    = value & 0x02;
+	  BX_HD_THIS s[0].controller.control.disable_irq = value & 0x02;
+	  BX_HD_THIS s[1].controller.control.disable_irq = value & 0x02;
       //BX_DEBUG(( "adpater control reg: reset controller = %d",
       //  (unsigned) (BX_SELECTED_CONTROLLER.control.reset) ? 1 : 0 ));
       //BX_DEBUG(( "adpater control reg: disable_irq(14) = %d",
@@ -1986,6 +2020,8 @@
 		      }
 		}
 	  }
+	    BX_DEBUG(("s[0].controller.control.disable_irq = %02x", (BX_HD_THIS s[0]).controller.control.disable_irq));
+	    BX_DEBUG(("s[1].controller.control.disable_irq = %02x", (BX_HD_THIS s[1]).controller.control.disable_irq));
 	  break;
 #if 0
       // you'll need these to support second IDE controller, not needed yet.
@@ -2616,6 +2652,8 @@
 void
 bx_hard_drive_c::raise_interrupt()
 {
+	BX_DEBUG(("raise_interrupt called, disable_irq = %02x", BX_SELECTED_CONTROLLER.control.disable_irq));
+	if (!BX_SELECTED_CONTROLLER.control.disable_irq) { BX_DEBUG(("raising interrupt")); } else { BX_DEBUG(("Not raising interrupt")); }
       if (!BX_SELECTED_CONTROLLER.control.disable_irq) {
 	    Bit32u irq = 14;  // always 1st IDE controller
 	    // for second controller, you would want irq 15
