----------------------------------------------------------------------
Patch name: patch.perf-regparm-cclark
Author: Conn Clark
Date: Wed Feb 12 15:21:37 CET 2003
Status: applyable, to be updated

Detailed description:

	Here is the patch for my modifications to source in bochs-2.0.1.tar.gz. 
All my changes were done to this code except I did update the vga.cc and 
vga.h files from the CVS tree in a failed attempt to 8 bit color 
working. The patch was generated by using the command "diff -u" if it 
wasn't done right let me know and I will try again. (I have only created 
a patch once before in my life and I did it wrong)

	Basicly I have found that Bochs, like all other large properly written 
well organized programs (No offense), spends a good portion of its time 
just passing parameters from one function to another. To reduce the 
effect of this I have used the GCC function atribute "regparm(n)" to 
declare that certain functions use the register calling convention. The 
  "n" in "regparm(n)" is the number of variables to pass in registers. 
All other code and logic in bochs were left untouched. Note that as far 
as I know this only works on GCC 3.2.X for X86 processors. Also note 
that there is a trick to using it that is not well documented in the gcc 
man pages. See examples below for implementation details.


/**** Normal code ****/

/* funct declaration */
int	foo(int a, int b, int c, int d);

/* function */
int
  foo( int a, int b, int c, int d)
{
int e;

e = a + b + c + d;

return e;
}



/**** Code using function attribute ****/

/* funct declaration */
int	foo(int a, int b, int c, int d) __attribute__((regparm(3)));

/* function */
int __attribute__((regparm(3)))
  foo( int a, int b, int c, int d)
{
int e;

e = a + b + c;
e -= d;

return e;
}

The trick is you put the function attribute after the function 
declaration and before its terminating semi-colon. However in the 
function you place it after the return type and before the function name.

	The behavior of the above example is as follows varables a, b, and c 
are passed in registers and d is passed on the stack (I think, if I'm 
wrong a is passed on the stack). The best canidates to apply this 
optimization to are functions that make immeadiate use of the registered 
variables. functions that do not use the registered variables right away 
may have to store the variables to the stack temporarily which may(but 
not always) result in slower code for the function. This may still 
create an overall benefit because using the register calling convention 
may speed up the function calling this one offsetting the penalty.

	The one place in Bochs where I think the register calling convention 
may do some real good is the individual functions for each instruction 
and the Resolve??Mod?Rm functions. I did not get this to work succesfuly 
when I attempted it the first time so I gave up and applied the 
optimization to everything else I could. It should be possible though I 
just am not quite familiar with the code to pull it off yet.


Here are the extra compiler flags I used to create my executable with.

-O2 -march=pentium2 -mmmx -fthread-jumps -fexpensive-optimizations 
-frename-registers -fomit-frame-pointer -finline-functions 
-minline-all-stringops

This may effect which functions it pays to use the register calling 
convention with. The only real way to tell is to look at the assembly 
code generated for the function and mabey the calling function or to 
benchmark bochs for each function changed. It tends to help more than 
hinder.

Here are some details on the machine I used.
All the work I did was on an overclocked  416 MHz dual processor ( I 
know the second processor doesn't help) pentium2 with 512MB of 75Mhz 
SDRAM and a PCI Diamond stealth 3D 3000 (Ancient I know, but in its day 
it rocked). The Os is Red hat 8.0 patched up to date as of 1/10/03 . 
Redhat 8.0 uses GCC 3.2.1 .

My IPS was about 4000000 before I tampered with the source and now its 
about 5000000.

I don't know how you think this could be implemented in a way that looks 
nice and works for every one not using Linux on an X86, but good luck. I 
just hope this helps somebody.

If you have any questions let me know,

	Conn

-----------------------------

In reading through this one more time I have noticed that I forgot to 
mention what options I specified  for ./configure . This patch may not 
work with some of the other configurations. Here they are.

--enable-new-pit --enable-ne2000 --enable-pci --enable-4meg-pages 
--enable-pae --enable-guest2host-tlb --enable-repeat-speedups 
--enable-icache --enable-global-pages --enable-host-specific-asms 
--enable-vbe --enable-mmx --enable-fpu --enable-cdrom --enable-sse 
--enable-sb16=linux --with-x11 --enable-all-optimizations --disable-plugins


-----------------------------

Notes from cbothamy :
- add an --enable-regparm option to configure
- enable-regparm if --enable-all-optimizations
- change all __attribute__((regparm(X))) to GCC_ATTRIBUTE_REGPARM(X)
- #define GCC_ATTRIBUTE_REGPARM(X) to  GCC_ATTRIBUTE((GCC_REGPARM(X)))
- #define GCC_REGPARM(X) to regparm(X) only on x86 with gcc > 3.2
or - #define GCC_FASTCALL to __attribute__((regparm(3))) and only use it
or something like that

Patch was created with:
  cvs diff -u
Apply patch to what version:
  cvs checked out on Wed Feb 12 15:21:37 CET 2003
Instructions:
  To patch, go to main bochs directory.
  Type "patch -p0 < THIS_PATCH_FILE".
----------------------------------------------------------------------
Index: pc_system.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/pc_system.cc,v
retrieving revision 1.31
diff -u -r1.31 pc_system.cc
--- pc_system.cc	25 Oct 2002 11:44:33 -0000	1.31
+++ pc_system.cc	12 Feb 2003 14:12:31 -0000
@@ -126,7 +126,7 @@
 // Read from the IO memory address space
 //
 
-  Bit32u
+  Bit32u __attribute__((regparm(2)))
 bx_pc_system_c::inp(Bit16u addr, unsigned io_len)
 {
   Bit32u ret;
@@ -141,13 +141,13 @@
 // Write to the IO memory address space.
 //
 
-  void
+  void __attribute__((regparm(3)))
 bx_pc_system_c::outp(Bit16u addr, Bit32u value, unsigned io_len)
 {
   bx_devices.outp(addr, value, io_len);
 }
 
-  void
+  void __attribute__((regparm(1)))
 bx_pc_system_c::set_enable_a20(Bit8u value)
 {
 #if BX_CPU_LEVEL < 2
Index: pc_system.h
===================================================================
RCS file: /cvsroot/bochs/bochs/pc_system.h,v
retrieving revision 1.23
diff -u -r1.23 pc_system.h
--- pc_system.h	15 Dec 2002 16:00:41 -0000	1.23
+++ pc_system.h	12 Feb 2003 14:12:31 -0000
@@ -187,9 +187,9 @@
 
   bx_pc_system_c(void);
 
-  Bit32u  inp(Bit16u addr, unsigned io_len);
-  void    outp(Bit16u addr, Bit32u value, unsigned io_len);
-  void    set_enable_a20(Bit8u value);
+  Bit32u  inp(Bit16u addr, unsigned io_len) __attribute__((regparm(2)));
+  void    outp(Bit16u addr, Bit32u value, unsigned io_len) __attribute__((regparm(3)));
+  void    set_enable_a20(Bit8u value) __attribute__((regparm(1)));
   bx_bool get_enable_a20(void);
   void    exit(void);
 
Index: cpu/access.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/cpu/access.cc,v
retrieving revision 1.35
diff -u -r1.35 access.cc
--- cpu/access.cc	13 Nov 2002 21:00:03 -0000	1.35
+++ cpu/access.cc	12 Feb 2003 14:12:31 -0000
@@ -46,7 +46,7 @@
 
 
 
-  void
+  void __attribute__((regparm(3)))
 BX_CPU_C::write_virtual_checks(bx_segment_reg_t *seg, bx_address offset,
                                unsigned length)
 {
@@ -139,7 +139,7 @@
     }
 }
 
-  void
+  void __attribute__((regparm(3)))
 BX_CPU_C::read_virtual_checks(bx_segment_reg_t *seg, bx_address offset,
                               unsigned length)
 {
@@ -261,7 +261,7 @@
 
 
 
-  char *
+  char * __attribute__((regparm(1)))
 BX_CPU_C::strseg(bx_segment_reg_t *seg)
 {
   if (seg == &BX_CPU_THIS_PTR sregs[0]) return("ES");
@@ -277,7 +277,7 @@
 }
 
 
-  void
+  void __attribute__((regparm(3)))
 BX_CPU_C::write_virtual_byte(unsigned s, bx_address offset, Bit8u *data)
 {
   bx_address laddr;
@@ -342,7 +342,7 @@
   goto accessOK;
 }
 
-  void
+  void __attribute__((regparm(3)))
 BX_CPU_C::write_virtual_word(unsigned s, bx_address offset, Bit16u *data)
 {
   bx_address laddr;
@@ -409,7 +409,7 @@
   goto accessOK;
 }
 
-  void
+  void __attribute__((regparm(3)))
 BX_CPU_C::write_virtual_dword(unsigned s, bx_address offset, Bit32u *data)
 {
   bx_address laddr;
@@ -477,7 +477,7 @@
 }
 
 
-  void
+  void __attribute__((regparm(3)))
 BX_CPU_C::read_virtual_byte(unsigned s, bx_address offset, Bit8u *data)
 {
   bx_address laddr;
@@ -529,7 +529,7 @@
 }
 
 
-  void
+  void __attribute__((regparm(3)))
 BX_CPU_C::read_virtual_word(unsigned s, bx_address offset, Bit16u *data)
 {
   bx_address laddr;
@@ -583,7 +583,7 @@
 }
 
 
-  void
+  void __attribute__((regparm(3)))
 BX_CPU_C::read_virtual_dword(unsigned s, bx_address offset, Bit32u *data)
 {
   bx_address laddr;
@@ -642,7 +642,7 @@
 // address translation info is kept across read/write calls //
 //////////////////////////////////////////////////////////////
 
-  void
+  void __attribute__((regparm(3)))
 BX_CPU_C::read_RMW_virtual_byte(unsigned s, bx_address offset, Bit8u *data)
 {
   bx_address laddr;
@@ -711,7 +711,7 @@
 }
 
 
-  void
+  void __attribute__((regparm(3)))
 BX_CPU_C::read_RMW_virtual_word(unsigned s, bx_address offset, Bit16u *data)
 {
   bx_address laddr;
@@ -779,7 +779,7 @@
   goto accessOK;
 }
 
-  void
+  void __attribute__((regparm(3)))
 BX_CPU_C::read_RMW_virtual_dword(unsigned s, bx_address offset, Bit32u *data)
 {
   bx_address laddr;
@@ -847,7 +847,7 @@
   goto accessOK;
 }
 
-  void
+  void __attribute__((regparm(1)))
 BX_CPU_C::write_RMW_virtual_byte(Bit8u val8)
 {
   BX_INSTR_MEM_DATA(BX_CPU_ID, BX_CPU_THIS_PTR address_xlation.paddress1, 1, BX_WRITE);
@@ -864,7 +864,7 @@
     }
 }
 
-  void
+  void __attribute__((regparm(1)))
 BX_CPU_C::write_RMW_virtual_word(Bit16u val16)
 {
   BX_INSTR_MEM_DATA(BX_CPU_ID, BX_CPU_THIS_PTR address_xlation.paddress1, 2, BX_WRITE);
@@ -931,7 +931,7 @@
 }
 
 
-  void
+  void __attribute__((regparm(3)))
 BX_CPU_C::write_virtual_qword(unsigned s, bx_address offset, Bit64u *data)
 {
   bx_address laddr;
@@ -999,7 +999,7 @@
 }
 
 
-  void
+  void __attribute__((regparm(3)))
 BX_CPU_C::read_virtual_qword(unsigned s, bx_address offset, Bit64u *data)
 {
   bx_address laddr;
@@ -1089,7 +1089,7 @@
     }
 }
 
-  void
+  void __attribute__((regparm(3)))
 BX_CPU_C::read_RMW_virtual_qword(unsigned s, bx_address offset, Bit64u *data)
 {
   bx_address laddr;
Index: cpu/cpu.h
===================================================================
RCS file: /cvsroot/bochs/bochs/cpu/cpu.h,v
retrieving revision 1.127
diff -u -r1.127 cpu.h
--- cpu/cpu.h	9 Feb 2003 13:30:39 -0000	1.127
+++ cpu/cpu.h	12 Feb 2003 14:12:34 -0000
@@ -2689,23 +2689,23 @@
     BX_CPU_THIS_PTR eipPageWindowSize = 0;
     }
 
-  BX_SMF void write_virtual_checks(bx_segment_reg_t *seg, bx_address offset, unsigned length);
-  BX_SMF void read_virtual_checks(bx_segment_reg_t *seg, bx_address offset, unsigned length);
-  BX_SMF void write_virtual_byte(unsigned seg, bx_address offset, Bit8u *data);
-  BX_SMF void write_virtual_word(unsigned seg, bx_address offset, Bit16u *data);
-  BX_SMF void write_virtual_dword(unsigned seg, bx_address offset, Bit32u *data);
-  BX_SMF void write_virtual_qword(unsigned seg, bx_address offset, Bit64u *data);
-  BX_SMF void read_virtual_byte(unsigned seg, bx_address offset, Bit8u *data);
-  BX_SMF void read_virtual_word(unsigned seg, bx_address offset, Bit16u *data);
-  BX_SMF void read_virtual_dword(unsigned seg, bx_address offset, Bit32u *data);
-  BX_SMF void read_virtual_qword(unsigned seg, bx_address offset, Bit64u *data);
-
-  BX_SMF void read_RMW_virtual_byte(unsigned seg, bx_address offset, Bit8u *data);
-  BX_SMF void read_RMW_virtual_word(unsigned seg, bx_address offset, Bit16u *data);
-  BX_SMF void read_RMW_virtual_dword(unsigned seg, bx_address offset, Bit32u *data);
-  BX_SMF void read_RMW_virtual_qword(unsigned seg, bx_address offset, Bit64u *data);
-  BX_SMF void write_RMW_virtual_byte(Bit8u val8);
-  BX_SMF void write_RMW_virtual_word(Bit16u val16);
+  BX_SMF void write_virtual_checks(bx_segment_reg_t *seg, bx_address offset, unsigned length) __attribute__((regparm(3)));
+  BX_SMF void read_virtual_checks(bx_segment_reg_t *seg, bx_address offset, unsigned length) __attribute__((regparm(3)));
+  BX_SMF void write_virtual_byte(unsigned seg, bx_address offset, Bit8u *data) __attribute__((regparm(3)));
+  BX_SMF void write_virtual_word(unsigned seg, bx_address offset, Bit16u *data) __attribute__((regparm(3)));
+  BX_SMF void write_virtual_dword(unsigned seg, bx_address offset, Bit32u *data) __attribute__((regparm(3)));
+  BX_SMF void write_virtual_qword(unsigned seg, bx_address offset, Bit64u *data) __attribute__((regparm(3)));
+  BX_SMF void read_virtual_byte(unsigned seg, bx_address offset, Bit8u *data) __attribute__((regparm(3)));
+  BX_SMF void read_virtual_word(unsigned seg, bx_address offset, Bit16u *data) __attribute__((regparm(3)));
+  BX_SMF void read_virtual_dword(unsigned seg, bx_address offset, Bit32u *data) __attribute__((regparm(3)));
+  BX_SMF void read_virtual_qword(unsigned seg, bx_address offset, Bit64u *data) __attribute__((regparm(3)));
+
+  BX_SMF void read_RMW_virtual_byte(unsigned seg, bx_address offset, Bit8u *data) __attribute__((regparm(3)));
+  BX_SMF void read_RMW_virtual_word(unsigned seg, bx_address offset, Bit16u *data) __attribute__((regparm(3)));
+  BX_SMF void read_RMW_virtual_dword(unsigned seg, bx_address offset, Bit32u *data) __attribute__((regparm(3)));
+  BX_SMF void read_RMW_virtual_qword(unsigned seg, bx_address offset, Bit64u *data) __attribute__((regparm(3)));
+  BX_SMF void write_RMW_virtual_byte(Bit8u val8) __attribute__((regparm(1)));
+  BX_SMF void write_RMW_virtual_word(Bit16u val16) __attribute__((regparm(1)));
   BX_SMF void write_RMW_virtual_dword(Bit32u val32);
   BX_SMF void write_RMW_virtual_qword(Bit64u val64);
 
@@ -2723,13 +2723,13 @@
 
 
   BX_SMF void access_linear(bx_address address, unsigned length, unsigned pl,
-                     unsigned rw, void *data);
-  BX_SMF Bit32u itranslate_linear(bx_address laddr, unsigned pl);
-  BX_SMF Bit32u dtranslate_linear(bx_address laddr, unsigned pl, unsigned rw);
+                     unsigned rw, void *data) __attribute__((regparm(3)));
+  BX_SMF Bit32u itranslate_linear(bx_address laddr, unsigned pl) __attribute__((regparm(2)));
+  BX_SMF Bit32u dtranslate_linear(bx_address laddr, unsigned pl, unsigned rw) __attribute__((regparm(3)));
   BX_SMF void TLB_flush(bx_bool invalidateGlobal);
   BX_SMF void TLB_init(void);
   BX_SMF void set_INTR(bx_bool value);
-  BX_SMF char *strseg(bx_segment_reg_t *seg);
+  BX_SMF char *strseg(bx_segment_reg_t *seg) __attribute__((regparm(1)));
   BX_SMF void interrupt(Bit8u vector, bx_bool is_INT, bx_bool is_error_code,
                  Bit16u error_code);
 #if BX_CPU_LEVEL >= 2
@@ -2738,17 +2738,17 @@
 #endif
   BX_SMF int  int_number(bx_segment_reg_t *seg);
   BX_SMF void shutdown_cpu(void);
-  BX_SMF void CR3_change(bx_address value);
-  BX_SMF void pagingCR0Changed(Bit32u oldCR0, Bit32u newCR0);
-  BX_SMF void pagingCR4Changed(Bit32u oldCR4, Bit32u newCR4);
+  BX_SMF void CR3_change(bx_address value) __attribute__((regparm(1)));
+  BX_SMF void pagingCR0Changed(Bit32u oldCR0, Bit32u newCR0) __attribute__((regparm(2)));
+  BX_SMF void pagingCR4Changed(Bit32u oldCR4, Bit32u newCR4) __attribute__((regparm(2)));
   BX_SMF void pagingA20Changed(void);
 
   BX_SMF void reset(unsigned source);
 
-  BX_SMF void jump_protected(bxInstruction_c *, Bit16u cs, bx_address disp);
-  BX_SMF void call_protected(bxInstruction_c *, Bit16u cs, bx_address disp);
-  BX_SMF void return_protected(bxInstruction_c *, Bit16u pop_bytes);
-  BX_SMF void iret_protected(bxInstruction_c *);
+  BX_SMF void jump_protected(bxInstruction_c *, Bit16u cs, bx_address disp) __attribute__((regparm(3)));
+  BX_SMF void call_protected(bxInstruction_c *, Bit16u cs, bx_address disp) __attribute__((regparm(3)));
+  BX_SMF void return_protected(bxInstruction_c *, Bit16u pop_bytes) __attribute__((regparm(2)));
+  BX_SMF void iret_protected(bxInstruction_c *) __attribute__((regparm(1)));
   BX_SMF void validate_seg_regs(void);
   BX_SMF void stack_return_to_v86(Bit32u new_eip, Bit32u raw_cs_selector,
                                      Bit32u flags32);
@@ -2763,38 +2763,38 @@
 #if BX_SUPPORT_X86_64
   BX_SMF void get_RSP_from_TSS(unsigned pl, Bit64u *rsp);
 #endif
-  BX_SMF void write_flags(Bit16u flags, bx_bool change_IOPL, bx_bool change_IF);
+  BX_SMF void write_flags(Bit16u flags, bx_bool change_IOPL, bx_bool change_IF) __attribute__((regparm(3)));
   BX_SMF void write_eflags(Bit32u eflags, bx_bool change_IOPL, bx_bool change_IF,
                     bx_bool change_VM, bx_bool change_RF);
-  BX_SMF void writeEFlags(Bit32u eflags, Bit32u changeMask); // Newer variant.
+  BX_SMF void writeEFlags(Bit32u eflags, Bit32u changeMask) __attribute__((regparm(2))); // Newer variant.
   BX_SMF Bit16u read_flags(void);
   BX_SMF Bit32u read_eflags(void);
   BX_SMF Bit32u get_segment_base(unsigned seg);
 
-  BX_SMF Bit8u   inp8(Bit16u addr);
-  BX_SMF void    outp8(Bit16u addr, Bit8u value);
-  BX_SMF Bit16u  inp16(Bit16u addr);
-  BX_SMF void    outp16(Bit16u addr, Bit16u value);
-  BX_SMF Bit32u  inp32(Bit16u addr);
-  BX_SMF void    outp32(Bit16u addr, Bit32u value);
+  BX_SMF Bit8u   inp8(Bit16u addr) __attribute__((regparm(1)));
+  BX_SMF void    outp8(Bit16u addr, Bit8u value) __attribute__((regparm(2)));
+  BX_SMF Bit16u  inp16(Bit16u addr) __attribute__((regparm(1)));
+  BX_SMF void    outp16(Bit16u addr, Bit16u value) __attribute__((regparm(2)));
+  BX_SMF Bit32u  inp32(Bit16u addr) __attribute__((regparm(1)));
+  BX_SMF void    outp32(Bit16u addr, Bit32u value) __attribute__((regparm(2)));
   BX_SMF bx_bool allow_io(Bit16u addr, unsigned len);
   BX_SMF void    enter_protected_mode(void);
   BX_SMF void    enter_real_mode(void);
-  BX_SMF void    parse_selector(Bit16u raw_selector, bx_selector_t *selector);
-  BX_SMF void    parse_descriptor(Bit32u dword1, Bit32u dword2, bx_descriptor_t *temp);
+  BX_SMF void    parse_selector(Bit16u raw_selector, bx_selector_t *selector) __attribute__((regparm(2)));
+  BX_SMF void    parse_descriptor(Bit32u dword1, Bit32u dword2, bx_descriptor_t *temp) __attribute__((regparm(3)));
   BX_SMF void    load_ldtr(bx_selector_t *selector, bx_descriptor_t *descriptor);
-  BX_SMF void    load_cs(bx_selector_t *selector, bx_descriptor_t *descriptor, Bit8u cpl);
-  BX_SMF void    load_ss(bx_selector_t *selector, bx_descriptor_t *descriptor, Bit8u cpl);
+  BX_SMF void    load_cs(bx_selector_t *selector, bx_descriptor_t *descriptor, Bit8u cpl) __attribute__((regparm(3)));
+  BX_SMF void    load_ss(bx_selector_t *selector, bx_descriptor_t *descriptor, Bit8u cpl) __attribute__((regparm(3)));
   BX_SMF void    fetch_raw_descriptor(bx_selector_t *selector,
-                               Bit32u *dword1, Bit32u *dword2, Bit8u exception);
-  BX_SMF void    load_seg_reg(bx_segment_reg_t *seg, Bit16u new_value);
+                               Bit32u *dword1, Bit32u *dword2, Bit8u exception) __attribute__((regparm(3)));
+  BX_SMF void    load_seg_reg(bx_segment_reg_t *seg, Bit16u new_value) __attribute__((regparm(2)));
 #if BX_SUPPORT_X86_64
   BX_SMF void    loadSRegLMNominal(unsigned seg, unsigned selector,
                                    bx_address base, unsigned dpl);
 #endif
   BX_SMF bx_bool fetch_raw_descriptor2(bx_selector_t *selector,
-                                Bit32u *dword1, Bit32u *dword2);
-  BX_SMF void    push_16(Bit16u value16);
+                                Bit32u *dword1, Bit32u *dword2) __attribute__((regparm(3)));
+  BX_SMF void    push_16(Bit16u value16) __attribute__((regparm(1)));
   BX_SMF void    push_32(Bit32u value32);
 #if BX_SUPPORT_X86_64
   BX_SMF void    push_64(Bit64u value64);
@@ -2804,7 +2804,7 @@
 #if BX_SUPPORT_X86_64
   BX_SMF void    pop_64(Bit64u *value64_ptr);
 #endif
-  BX_SMF bx_bool can_push(bx_descriptor_t *descriptor, Bit32u esp, Bit32u bytes);
+  BX_SMF bx_bool can_push(bx_descriptor_t *descriptor, Bit32u esp, Bit32u bytes) __attribute__((regparm(3)));
   BX_SMF bx_bool can_pop(Bit32u bytes);
   BX_SMF void    sanity_checks(void);
 
Index: cpu/ctrl_xfer_pro.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/cpu/ctrl_xfer_pro.cc,v
retrieving revision 1.21
diff -u -r1.21 ctrl_xfer_pro.cc
--- cpu/ctrl_xfer_pro.cc	3 Oct 2002 04:49:47 -0000	1.21
+++ cpu/ctrl_xfer_pro.cc	12 Feb 2003 14:12:35 -0000
@@ -41,7 +41,7 @@
 
 
 #if BX_CPU_LEVEL >= 2
-  void
+  void __attribute__((regparm(3)))
 BX_CPU_C::jump_protected(bxInstruction_c *i, Bit16u cs_raw, bx_address dispBig)
 {
   bx_descriptor_t  descriptor;
@@ -456,7 +456,7 @@
 
 
 #if BX_CPU_LEVEL >= 2
-  void
+  void __attribute__((regparm(3)))
 BX_CPU_C::call_protected(bxInstruction_c *i, Bit16u cs_raw, bx_address dispBig)
 {
   bx_selector_t cs_selector;
@@ -1041,7 +1041,7 @@
 
 
 #if BX_CPU_LEVEL >= 2
-  void
+  void __attribute__((regparm(2)))
 BX_CPU_C::return_protected(bxInstruction_c *i, Bit16u pop_bytes)
 {
   Bit16u raw_cs_selector, raw_ss_selector;
@@ -1379,7 +1379,7 @@
 
 
 #if BX_CPU_LEVEL >= 2
-  void
+  void __attribute__((regparm(1)))
 BX_CPU_C::iret_protected(bxInstruction_c *i)
 {
   Bit16u raw_cs_selector, raw_ss_selector;
Index: cpu/flag_ctrl_pro.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/cpu/flag_ctrl_pro.cc,v
retrieving revision 1.13
diff -u -r1.13 flag_ctrl_pro.cc
--- cpu/flag_ctrl_pro.cc	25 Oct 2002 11:44:35 -0000	1.13
+++ cpu/flag_ctrl_pro.cc	12 Feb 2003 14:12:35 -0000
@@ -32,7 +32,7 @@
 
 
 
-  void
+  void __attribute__((regparm(2)))
 BX_CPU_C::writeEFlags(Bit32u flags, Bit32u changeMask)
 {
   Bit32u supportMask, newEFlags;
@@ -58,7 +58,7 @@
 }
 
 
-  void
+  void __attribute__((regparm(3)))
 BX_CPU_C::write_flags(Bit16u flags, bx_bool change_IOPL, bx_bool change_IF)
 {
   Bit32u changeMask = 0x0dd5;
Index: cpu/io_pro.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/cpu/io_pro.cc,v
retrieving revision 1.11
diff -u -r1.11 io_pro.cc
--- cpu/io_pro.cc	25 Oct 2002 11:44:35 -0000	1.11
+++ cpu/io_pro.cc	12 Feb 2003 14:12:35 -0000
@@ -37,7 +37,7 @@
 
 
 
-  Bit16u
+  Bit16u __attribute__((regparm(1)))
 BX_CPU_C::inp16(Bit16u addr)
 {
   Bit16u ret16;
@@ -54,7 +54,7 @@
   return( ret16 );
 }
 
-  void
+  void __attribute__((regparm(2)))
 BX_CPU_C::outp16(Bit16u addr, Bit16u value)
 {
   /* If CPL <= IOPL, then all IO addresses are accessible.
@@ -72,7 +72,7 @@
   BX_OUTP(addr, value, 2);
 }
 
-  Bit32u
+  Bit32u __attribute__((regparm(1)))
 BX_CPU_C::inp32(Bit16u addr)
 {
   Bit32u ret32;
@@ -89,7 +89,7 @@
   return( ret32 );
 }
 
-  void
+  void __attribute__((regparm(2)))
 BX_CPU_C::outp32(Bit16u addr, Bit32u value)
 {
   /* If CPL <= IOPL, then all IO addresses are accessible.
@@ -107,7 +107,7 @@
   BX_OUTP(addr, value, 4);
 }
 
-  Bit8u
+  Bit8u __attribute__((regparm(1)))
 BX_CPU_C::inp8(Bit16u addr)
 {
   Bit8u ret8;
@@ -125,7 +125,7 @@
 }
 
 
-  void
+  void __attribute__((regparm(2)))
 BX_CPU_C::outp8(Bit16u addr, Bit8u value)
 {
   /* If CPL <= IOPL, then all IO addresses are accessible.
Index: cpu/mmx.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/cpu/mmx.cc,v
retrieving revision 1.28
diff -u -r1.28 mmx.cc
--- cpu/mmx.cc	9 Jan 2003 05:21:22 -0000	1.28
+++ cpu/mmx.cc	12 Feb 2003 14:12:37 -0000
@@ -27,7 +27,8 @@
 
 #if BX_SUPPORT_MMX || BX_SUPPORT_SSE != 0
 
-Bit8s SaturateWordSToByteS(Bit16s value)
+Bit8s  __attribute__((regparm(1)))
+SaturateWordSToByteS(Bit16s value)
 {
 /*
   SaturateWordSToByteS   converts   a signed 16-bit value to a
@@ -40,7 +41,8 @@
   return value;
 }
 
-Bit16s SaturateDwordSToWordS(Bit32s value)
+Bit16s  __attribute__((regparm(1)))
+SaturateDwordSToWordS(Bit32s value)
 {
 /*
   SaturateDwordSToWordS  converts  a  signed 32-bit value to a
@@ -54,7 +56,8 @@
   return value;
 }
 
-Bit8u SaturateWordSToByteU(Bit16s value)
+Bit8u  __attribute__((regparm(1)))
+SaturateWordSToByteU(Bit16s value)
 {
 /*
   SaturateWordSToByteU  converts a signed 16-bit value to an
@@ -67,7 +70,8 @@
   return value;
 }
 
-Bit16u SaturateDwordSToWordU(Bit32s value)
+Bit16u  __attribute__((regparm(1)))
+SaturateDwordSToWordU(Bit32s value)
 {
 /*
   SaturateDwordSToWordU  converts  a signed 32-bit value
Index: cpu/paging.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/cpu/paging.cc,v
retrieving revision 1.38
diff -u -r1.38 paging.cc
--- cpu/paging.cc	4 Nov 2002 05:38:12 -0000	1.38
+++ cpu/paging.cc	12 Feb 2003 14:12:37 -0000
@@ -387,7 +387,7 @@
 // ==============================================================
 
 
-  void
+  void __attribute__((regparm(2)))
 BX_CPU_C::pagingCR0Changed(Bit32u oldCR0, Bit32u newCR0)
 {
   // Modification of PG,PE flushes TLB cache according to docs.
@@ -400,7 +400,7 @@
     BX_INFO(("pagingCR0Changed(0x%x -> 0x%x):", oldCR0, newCR0));
 }
 
-  void
+  void __attribute__((regparm(2)))
 BX_CPU_C::pagingCR4Changed(Bit32u oldCR4, Bit32u newCR4)
 {
   // Modification of PGE,PAE,PSE flushes TLB cache according to docs.
@@ -411,7 +411,7 @@
     BX_INFO(("pagingCR4Changed(0x%x -> 0x%x):", oldCR4, newCR4));
 }
 
-  void
+  void __attribute__((regparm(1)))
 BX_CPU_C::CR3_change(bx_address value)
 {
   if (bx_dbg.paging) {
@@ -570,7 +570,7 @@
 // Translate a linear address to a physical address, for
 // a data access (D)
 
-  Bit32u
+  Bit32u __attribute__((regparm(3)))
 BX_CPU_C::dtranslate_linear(bx_address laddr, unsigned pl, unsigned rw)
 {
   bx_address   lpf;
@@ -991,7 +991,7 @@
 // Translate a linear address to a physical address, for
 // an instruction fetch access (I)
 
-  Bit32u
+  Bit32u __attribute__((regparm(2)))
 BX_CPU_C::itranslate_linear(bx_address laddr, unsigned pl)
 {
   return dtranslate_linear(laddr, pl, BX_READ);
@@ -1066,7 +1066,7 @@
 
 
 
-  void
+  void __attribute__((regparm(3)))
 BX_CPU_C::access_linear(bx_address laddr, unsigned length, unsigned pl,
     unsigned rw, void *data)
 {
Index: cpu/segment_ctrl_pro.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/cpu/segment_ctrl_pro.cc,v
retrieving revision 1.23
diff -u -r1.23 segment_ctrl_pro.cc
--- cpu/segment_ctrl_pro.cc	25 Oct 2002 11:44:35 -0000	1.23
+++ cpu/segment_ctrl_pro.cc	12 Feb 2003 14:12:37 -0000
@@ -37,7 +37,7 @@
 
 
 
-  void
+  void __attribute__((regparm(2)))
 BX_CPU_C::load_seg_reg(bx_segment_reg_t *seg, Bit16u new_value)
 {
 #if BX_CPU_LEVEL >= 3
@@ -376,7 +376,7 @@
 
 
 #if BX_CPU_LEVEL >= 2
-  void
+  void __attribute__((regparm(2)))
 BX_CPU_C::parse_selector(Bit16u raw_selector, bx_selector_t *selector)
 {
   selector->value  = raw_selector;
@@ -386,7 +386,7 @@
 }
 #endif
 
-  void
+  void __attribute__((regparm(3)))
 BX_CPU_C::parse_descriptor(Bit32u dword1, Bit32u dword2, bx_descriptor_t *temp)
 {
   Bit8u AR_byte;
@@ -504,7 +504,7 @@
     }
 }
 
-  void
+  void __attribute__((regparm(2)))
 BX_CPU_C::load_ldtr(bx_selector_t *selector, bx_descriptor_t *descriptor)
 {
   /* check for null selector, if so invalidate LDTR */
@@ -527,7 +527,7 @@
   BX_CPU_THIS_PTR ldtr.cache.valid = 1;
 }
 
-  void
+  void __attribute__((regparm(3)))
 BX_CPU_C::load_cs(bx_selector_t *selector, bx_descriptor_t *descriptor,
            Bit8u cpl)
 {
@@ -559,7 +559,7 @@
 #endif
 }
 
-  void
+  void __attribute__((regparm(3)))
 BX_CPU_C::load_ss(bx_selector_t *selector, bx_descriptor_t *descriptor, Bit8u cpl)
 {
   BX_CPU_THIS_PTR sregs[BX_SEG_REG_SS].selector = *selector;
@@ -581,7 +581,7 @@
 }
 
 #if BX_CPU_LEVEL >= 2
-  void
+  void __attribute__((regparm(3)))
 BX_CPU_C::fetch_raw_descriptor(bx_selector_t *selector,
                         Bit32u *dword1, Bit32u *dword2, Bit8u exception_no)
 {
@@ -624,7 +624,7 @@
 
 
 
-  bx_bool
+  bx_bool __attribute__((regparm(3)))
 BX_CPU_C::fetch_raw_descriptor2(bx_selector_t *selector,
                         Bit32u *dword1, Bit32u *dword2)
 {
Index: cpu/stack_pro.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/cpu/stack_pro.cc,v
retrieving revision 1.12
diff -u -r1.12 stack_pro.cc
--- cpu/stack_pro.cc	7 Nov 2002 15:42:14 -0000	1.12
+++ cpu/stack_pro.cc	12 Feb 2003 14:12:37 -0000
@@ -36,7 +36,7 @@
 
 
 
-  void
+  void __attribute__((regparm(1)))
 BX_CPU_C::push_16(Bit16u value16)
 {
 BailBigRSP("push_16");
@@ -238,7 +238,7 @@
 
 
 #if BX_CPU_LEVEL >= 2
-  bx_bool
+  bx_bool __attribute__((regparm(3)))
 BX_CPU_C::can_push(bx_descriptor_t *descriptor, Bit32u esp, Bit32u bytes)
 {
 #if BX_SUPPORT_X86_64
Index: cpu/xmm.h
===================================================================
RCS file: /cvsroot/bochs/bochs/cpu/xmm.h,v
retrieving revision 1.8
diff -u -r1.8 xmm.h
--- cpu/xmm.h	23 Jan 2003 18:33:35 -0000	1.8
+++ cpu/xmm.h	12 Feb 2003 14:12:38 -0000
@@ -89,7 +89,7 @@
   is  represented  by  the saturated value -128 (0x80). If it is greater
   than 127, it is represented by the saturated value 127 (0x7F).
 */
-Bit8s SaturateWordSToByteS(Bit16s value);
+Bit8s SaturateWordSToByteS(Bit16s value) __attribute__((regparm(1)));
 
 /*
   SaturateDwordSToWordS  converts  a  signed 32-bit value to a
@@ -98,7 +98,7 @@
   greater  than  32767,  it  is represented by the saturated value 32767
   (0x7FFF).
 */
-Bit16s SaturateDwordSToWordS(Bit32s value);
+Bit16s SaturateDwordSToWordS(Bit32s value) __attribute__((regparm(1)));
 
 /*
   SaturateWordSToByteU  converts a signed 16-bit value to an
@@ -106,7 +106,7 @@
   is  represented  by  the  saturated value zero (0x00).If it is greater
   than 255 it is represented by the saturated value 255 (0xFF).
 */
-Bit8u SaturateWordSToByteU(Bit16s value);
+Bit8u SaturateWordSToByteU(Bit16s value) __attribute__((regparm(1)));
 
 /*
   SaturateDwordSToWordU  converts  a signed 32-bit value
@@ -115,6 +115,6 @@
   (0x0000).  If  it  is greater  than  65535,  it  is represented by
   the saturated value 65535 (0xFFFF).
 */
-Bit16u SaturateDwordSToWordU(Bit32s value);
+Bit16u SaturateDwordSToWordU(Bit32s value) __attribute__((regparm(1)));
 
 #endif
Index: fpu/fpu_proto.h
===================================================================
RCS file: /cvsroot/bochs/bochs/fpu/fpu_proto.h,v
retrieving revision 1.4
diff -u -r1.4 fpu_proto.h
--- fpu/fpu_proto.h	6 Oct 2001 04:35:13 -0000	1.4
+++ fpu/fpu_proto.h	12 Feb 2003 14:12:38 -0000
@@ -93,20 +93,20 @@
 extern void FPU_etc(void);
 /* fpu_tags.c */
 extern int FPU_gettag0(void);
-extern int FPU_gettagi(int stnr);
-extern int FPU_gettag(int regnr);
-extern void FPU_settag0(int tag);
-extern void FPU_settagi(int stnr, int tag);
-extern void FPU_settag(int regnr, int tag);
-extern int FPU_Special(FPU_REG const *ptr);
-extern int isNaN(FPU_REG const *ptr);
+extern int FPU_gettagi(int stnr) __attribute__((regparm(1)));
+extern int FPU_gettag(int regnr) __attribute__((regparm(1)));
+extern void FPU_settag0(int tag) __attribute__((regparm(1)));
+extern void FPU_settagi(int stnr, int tag) __attribute__((regparm(2)));
+extern void FPU_settag(int regnr, int tag) __attribute__((regparm(2)));
+extern int FPU_Special(FPU_REG const *ptr) __attribute__((regparm(1)));
+extern int isNaN(FPU_REG const *ptr) __attribute__((regparm(1)));
 extern void FPU_pop(void);
-extern int FPU_empty_i(int stnr);
+extern int FPU_empty_i(int stnr) __attribute__((regparm(1)));
 extern int FPU_stackoverflow(FPU_REG **st_new_ptr);
 extern void FPU_sync_tags(void);
-extern void FPU_copy_to_regi(FPU_REG const *r, u_char tag, int stnr);
-extern void FPU_copy_to_reg1(FPU_REG const *r, u_char tag);
-extern void FPU_copy_to_reg0(FPU_REG const *r, u_char tag);
+extern void FPU_copy_to_regi(FPU_REG const *r, u_char tag, int stnr) __attribute__((regparm(3)));
+extern void FPU_copy_to_reg1(FPU_REG const *r, u_char tag) __attribute__((regparm(2)));
+extern void FPU_copy_to_reg0(FPU_REG const *r, u_char tag) __attribute__((regparm(2)));
 /* fpu_trig.c */
 extern void FPU_triga(void);
 extern void FPU_trigb(void);
@@ -146,32 +146,32 @@
 /* reg_constant.c */
 extern void fconst(void);
 /* reg_ld_str.c */
-extern int FPU_load_extended(long double *s, int stnr);
-extern int FPU_load_double(double *dfloat, FPU_REG *loaded_data);
-extern int FPU_load_single(float *single, FPU_REG *loaded_data);
-extern int FPU_load_int64(s64 *_s);
-extern int FPU_load_int32(s32 *_s, FPU_REG *loaded_data);
-extern int FPU_load_int16(s16 *_s, FPU_REG *loaded_data);
-extern int FPU_load_bcd(u_char *s);
+extern int FPU_load_extended(long double *s, int stnr) __attribute__((regparm(2)));
+extern int FPU_load_double(double *dfloat, FPU_REG *loaded_data) __attribute__((regparm(2)));
+extern int FPU_load_single(float *single, FPU_REG *loaded_data) __attribute__((regparm(2)));
+extern int FPU_load_int64(s64 *_s) __attribute__((regparm(1)));
+extern int FPU_load_int32(s32 *_s, FPU_REG *loaded_data) __attribute__((regparm(2)));
+extern int FPU_load_int16(s16 *_s, FPU_REG *loaded_data) __attribute__((regparm(2)));
+extern int FPU_load_bcd(u_char *s) __attribute__((regparm(1)));
 extern int FPU_store_extended(FPU_REG *st0_ptr, u_char st0_tag,
-			      long double *d);
-extern int FPU_store_double(FPU_REG *st0_ptr, u_char st0_tag, double *dfloat);
-extern int FPU_store_single(FPU_REG *st0_ptr, u_char st0_tag, float *single);
-extern int FPU_store_int64(FPU_REG *st0_ptr, u_char st0_tag, s64 *d);
-extern int FPU_store_int32(FPU_REG *st0_ptr, u_char st0_tag, s32 *d);
-extern int FPU_store_int16(FPU_REG *st0_ptr, u_char st0_tag, s16 *d);
-extern int FPU_store_bcd(FPU_REG *st0_ptr, u_char st0_tag, u_char *d);
-extern int FPU_round_to_int(FPU_REG *r, u_char tag);
-extern u_char *fldenv(fpu_addr_modes addr_modes, u_char *s);
-extern void frstor(fpu_addr_modes addr_modes, u_char *data_address);
-extern u_char *fstenv(fpu_addr_modes addr_modes, u_char *d);
-extern void fsave(fpu_addr_modes addr_modes, u_char *data_address);
-extern int FPU_tagof(FPU_REG *ptr);
+			      long double *d) __attribute__((regparm(3)));
+extern int FPU_store_double(FPU_REG *st0_ptr, u_char st0_tag, double *dfloat) __attribute__((regparm(3)));
+extern int FPU_store_single(FPU_REG *st0_ptr, u_char st0_tag, float *single) __attribute__((regparm(3)));
+extern int FPU_store_int64(FPU_REG *st0_ptr, u_char st0_tag, s64 *d) __attribute__((regparm(3)));
+extern int FPU_store_int32(FPU_REG *st0_ptr, u_char st0_tag, s32 *d) __attribute__((regparm(3)));
+extern int FPU_store_int16(FPU_REG *st0_ptr, u_char st0_tag, s16 *d) __attribute__((regparm(3)));
+extern int FPU_store_bcd(FPU_REG *st0_ptr, u_char st0_tag, u_char *d) __attribute__((regparm(3)));
+extern int FPU_round_to_int(FPU_REG *r, u_char tag) __attribute__((regparm(2)));
+extern u_char *fldenv(fpu_addr_modes addr_modes, u_char *s) __attribute__((regparm(2)));
+extern void frstor(fpu_addr_modes addr_modes, u_char *data_address) __attribute__((regparm(2)));
+extern u_char *fstenv(fpu_addr_modes addr_modes, u_char *d) __attribute__((regparm(2)));
+extern void fsave(fpu_addr_modes addr_modes, u_char *data_address) __attribute__((regparm(2)));
+extern int FPU_tagof(FPU_REG *ptr) __attribute__((regparm(1)));
 /* reg_mul.c */
 extern int FPU_mul(FPU_REG const *b, u_char tagb, int deststnr, int control_w);
 
 extern int FPU_div(int flags, FPU_REG *regrm, int control_w); // bbd: changed arg2 from int to FPU_REG*
 /* reg_convert.c */
-extern int FPU_to_exp16(FPU_REG const *a, FPU_REG *x);
+extern int FPU_to_exp16(FPU_REG const *a, FPU_REG *x) __attribute__((regparm(2)));
 #endif /* _FPU_PROTO_H */
 
Index: fpu/fpu_system.h
===================================================================
RCS file: /cvsroot/bochs/bochs/fpu/fpu_system.h,v
retrieving revision 1.5
diff -u -r1.5 fpu_system.h
--- fpu/fpu_system.h	23 Jan 2003 18:33:35 -0000	1.5
+++ fpu/fpu_system.h	12 Feb 2003 14:12:38 -0000
@@ -115,10 +115,10 @@
 #endif
 
 
-extern unsigned fpu_get_user(void *ptr, unsigned len);
-extern void fpu_put_user(unsigned val, void *ptr, unsigned len);
+extern unsigned fpu_get_user(void *ptr, unsigned len) __attribute__((regparm(2)));
+extern void fpu_put_user(unsigned val, void *ptr, unsigned len) __attribute__((regparm(2)));
 
-extern void fpu_verify_area(unsigned what, void *ptr, unsigned n);
+extern void fpu_verify_area(unsigned what, void *ptr, unsigned n) __attribute__((regparm(3)));
 extern void math_emulate_init(void);
 extern unsigned fpu_get_ds(void);
 extern void fpu_set_ax(u16);
Index: fpu/fpu_tags.c
===================================================================
RCS file: /cvsroot/bochs/bochs/fpu/fpu_tags.c,v
retrieving revision 1.2
diff -u -r1.2 fpu_tags.c
--- fpu/fpu_tags.c	6 Oct 2001 03:53:46 -0000	1.2
+++ fpu/fpu_tags.c	12 Feb 2003 14:12:38 -0000
@@ -29,19 +29,22 @@
 }
 
 
-int FPU_gettagi(int stnr)
+int  __attribute__((regparm(1)))
+FPU_gettagi(int stnr)
 {
   return (fpu_tag_word >> (((top+stnr) & 7)*2)) & 3;
 }
 
 
-int FPU_gettag(int regnr)
+int  __attribute__((regparm(1)))
+FPU_gettag(int regnr)
 {
   return (fpu_tag_word >> ((regnr & 7)*2)) & 3;
 }
 
 
-void FPU_settag0(int tag)
+void  __attribute__((regparm(1)))
+FPU_settag0(int tag)
 {
   int regnr = top;
   regnr &= 7;
@@ -50,7 +53,8 @@
 }
 
 
-void FPU_settagi(int stnr, int tag)
+void  __attribute__((regparm(2)))
+FPU_settagi(int stnr, int tag)
 {
   int regnr = stnr+top;
   regnr &= 7;
@@ -59,7 +63,8 @@
 }
 
 
-void FPU_settag(int regnr, int tag)
+void  __attribute__((regparm(2)))
+FPU_settag(int regnr, int tag)
 {
   regnr &= 7;
   fpu_tag_word &= ~(3 << (regnr*2));
@@ -67,7 +72,8 @@
 }
 
 
-int FPU_Special(FPU_REG const *ptr)
+int  __attribute__((regparm(1)))
+FPU_Special(FPU_REG const *ptr)
 {
   int exp = exponent(ptr);
 
@@ -81,14 +87,16 @@
 }
 
 
-int isNaN(FPU_REG const *ptr)
+int  __attribute__((regparm(1)))
+isNaN(FPU_REG const *ptr)
 {
   return ( (exponent(ptr) == EXP_BIAS+EXP_OVER)
 	   && !((ptr->sigh == 0x80000000) && (ptr->sigl == 0)) );
 }
 
 
-int FPU_empty_i(int stnr)
+int  __attribute__((regparm(1)))
+FPU_empty_i(int stnr)
 {
   int regnr = (top+stnr) & 7;
 
@@ -104,19 +112,22 @@
 }
 
 
-void FPU_copy_to_regi(FPU_REG const *r, u_char tag, int stnr)
+void  __attribute__((regparm(3)))
+FPU_copy_to_regi(FPU_REG const *r, u_char tag, int stnr)
 {
   reg_copy(r, &st(stnr));
   FPU_settagi(stnr, tag);
 }
 
-void FPU_copy_to_reg1(FPU_REG const *r, u_char tag)
+void  __attribute__((regparm(2)))
+FPU_copy_to_reg1(FPU_REG const *r, u_char tag)
 {
   reg_copy(r, &st(1));
   FPU_settagi(1, tag);
 }
 
-void FPU_copy_to_reg0(FPU_REG const *r, u_char tag)
+void  __attribute__((regparm(2)))
+FPU_copy_to_reg0(FPU_REG const *r, u_char tag)
 {
   int regnr = top;
   regnr &= 7;
Index: fpu/reg_convert.c
===================================================================
RCS file: /cvsroot/bochs/bochs/fpu/reg_convert.c,v
retrieving revision 1.2
diff -u -r1.2 reg_convert.c
--- fpu/reg_convert.c	6 Oct 2001 03:53:46 -0000	1.2
+++ fpu/reg_convert.c	12 Feb 2003 14:12:38 -0000
@@ -15,7 +15,8 @@
 #include "fpu_emu.h"
 
 
-int FPU_to_exp16(FPU_REG const *a, FPU_REG *x)
+int  __attribute__((regparm(2)))
+FPU_to_exp16(FPU_REG const *a, FPU_REG *x)
 {
   int sign = getsign(a);
 
Index: fpu/reg_ld_str.c
===================================================================
RCS file: /cvsroot/bochs/bochs/fpu/reg_ld_str.c,v
retrieving revision 1.5
diff -u -r1.5 reg_ld_str.c
--- fpu/reg_ld_str.c	26 Dec 2002 14:47:02 -0000	1.5
+++ fpu/reg_ld_str.c	12 Feb 2003 14:12:38 -0000
@@ -38,7 +38,8 @@
 #define SINGLE_Emin (-126)       /* smallest valid exponent */
 
 
-static u_char normalize_no_excep(FPU_REG *r, int exp, int sign)
+static u_char  __attribute__((regparm(3)))
+normalize_no_excep(FPU_REG *r, int exp, int sign)
 {
   u_char tag;
 
@@ -53,7 +54,8 @@
 }
 
 
-int FPU_tagof(FPU_REG *ptr)
+int  __attribute__((regparm(1)))
+FPU_tagof(FPU_REG *ptr)
 {
   int exp;
 
@@ -87,7 +89,8 @@
 
 
 /* Get a long double from user memory */
-int FPU_load_extended(long double *s, int stnr)
+int  __attribute__((regparm(2)))
+FPU_load_extended(long double *s, int stnr)
 {
   FPU_REG *sti_ptr = &st(stnr);
 
@@ -107,7 +110,8 @@
 
 
 /* Get a double from user memory */
-int FPU_load_double(double *dfloat, FPU_REG *loaded_data)
+int  __attribute__((regparm(2)))
+FPU_load_double(double *dfloat, FPU_REG *loaded_data)
 {
   int exp, tag, negative;
   u32 m64, l64;
@@ -179,7 +183,8 @@
 
 
 /* Get a float from user memory */
-int FPU_load_single(float *single, FPU_REG *loaded_data)
+int  __attribute__((regparm(2)))
+FPU_load_single(float *single, FPU_REG *loaded_data)
 {
   u32 m32;
   int exp, tag, negative;
@@ -243,7 +248,8 @@
 
 
 /* Get a 64bit quantity from user memory */
-int FPU_load_int64(s64 *_s)
+int  __attribute__((regparm(1)))
+FPU_load_int64(s64 *_s)
 {
   s64 s;
   int sign;
@@ -285,7 +291,8 @@
 
 
 /* Get a long from user memory */
-int FPU_load_int32(s32 *_s, FPU_REG *loaded_data)
+int  __attribute__((regparm(2)))
+FPU_load_int32(s32 *_s, FPU_REG *loaded_data)
 {
   s32 s;
   int negative;
@@ -314,7 +321,8 @@
 
 
 /* Get a short from user memory */
-int FPU_load_int16(s16 *_s, FPU_REG *loaded_data)
+int  __attribute__((regparm(1)))
+FPU_load_int16(s16 *_s, FPU_REG *loaded_data)
 {
   s16 s, negative;
 
@@ -343,7 +351,8 @@
 
 
 /* Get a packed bcd array from user memory */
-int FPU_load_bcd(u_char *s)
+int  __attribute__((regparm(1)))
+FPU_load_bcd(u_char *s)
 {
   FPU_REG *st0_ptr = &st(0);
   int pos;
@@ -386,7 +395,8 @@
 /*===========================================================================*/
 
 /* Put a long double into user memory */
-int FPU_store_extended(FPU_REG *st0_ptr, u_char st0_tag, long double *d)
+int  __attribute__((regparm(3)))
+FPU_store_extended(FPU_REG *st0_ptr, u_char st0_tag, long double *d)
 {
   /*
     The only exception raised by an attempt to store to an
@@ -428,7 +438,8 @@
 
 
 /* Put a double into user memory */
-int FPU_store_double(FPU_REG *st0_ptr, u_char st0_tag, double *dfloat)
+int  __attribute__((regparm(3)))
+FPU_store_double(FPU_REG *st0_ptr, u_char st0_tag, double *dfloat)
 {
   u32 l[2];
   u32 increment = 0;	/* avoid gcc warnings */
@@ -647,7 +658,8 @@
 
 
 /* Put a float into user memory */
-int FPU_store_single(FPU_REG *st0_ptr, u_char st0_tag, float *single)
+int  __attribute__((regparm(3)))
+FPU_store_single(FPU_REG *st0_ptr, u_char st0_tag, float *single)
 {
   s32 templ;
   u32 increment = 0;     	/* avoid gcc warnings */
@@ -871,7 +883,8 @@
 
 
 /* Put a 64bit quantity into user memory */
-int FPU_store_int64(FPU_REG *st0_ptr, u_char st0_tag, s64 *d)
+int  __attribute__((regparm(3)))
+FPU_store_int64(FPU_REG *st0_ptr, u_char st0_tag, s64 *d)
 {
   FPU_REG t;
   s64 tll;
@@ -942,7 +955,8 @@
 
 
 /* Put a long into user memory */
-int FPU_store_int32(FPU_REG *st0_ptr, u_char st0_tag, s32 *d)
+int  __attribute__((regparm(3)))
+FPU_store_int32(FPU_REG *st0_ptr, u_char st0_tag, s32 *d)
 {
   FPU_REG t;
   int precision_loss;
@@ -999,7 +1013,8 @@
 
 
 /* Put a short into user memory */
-int FPU_store_int16(FPU_REG *st0_ptr, u_char st0_tag, s16 *d)
+int  __attribute__((regparm(3)))
+FPU_store_int16(FPU_REG *st0_ptr, u_char st0_tag, s16 *d)
 {
   FPU_REG t;
   int precision_loss;
@@ -1056,7 +1071,8 @@
 
 
 /* Put a packed bcd array into user memory */
-int FPU_store_bcd(FPU_REG *st0_ptr, u_char st0_tag, u_char *d)
+int  __attribute__((regparm(3)))
+FPU_store_bcd(FPU_REG *st0_ptr, u_char st0_tag, u_char *d)
 {
   FPU_REG t;
   u64 ll;
@@ -1142,7 +1158,8 @@
 /* Overflow is signalled by a non-zero return value (in eax).
    In the case of overflow, the returned significand always has the
    largest possible value */
-int FPU_round_to_int(FPU_REG *r, u_char tag)
+int  __attribute__((regparm(2)))
+FPU_round_to_int(FPU_REG *r, u_char tag)
 {
   u_char     very_big;
   unsigned eax;
@@ -1206,7 +1223,8 @@
 
 /*===========================================================================*/
 
-u_char *fldenv(fpu_addr_modes addr_modes, u_char *s)
+u_char  __attribute__((regparm(2)))
+*fldenv(fpu_addr_modes addr_modes, u_char *s)
 {
   u16 tag_word = 0;
   u_char tag;
@@ -1297,7 +1315,8 @@
 }
 
 
-void frstor(fpu_addr_modes addr_modes, u_char *data_address)
+void  __attribute__((regparm(2)))
+frstor(fpu_addr_modes addr_modes, u_char *data_address)
 {
   int i, regnr;
   u_char *s = fldenv(addr_modes, data_address);
@@ -1347,7 +1366,8 @@
 }
 
 
-u_char *fstenv(fpu_addr_modes addr_modes, u_char *d)
+u_char  __attribute__((regparm(2)))
+*fstenv(fpu_addr_modes addr_modes, u_char *d)
 {
   if ( (addr_modes.default_mode == VM86) ||
       ((addr_modes.default_mode == PM16)
@@ -1414,7 +1434,8 @@
 }
 
 
-void fsave(fpu_addr_modes addr_modes, u_char *data_address)
+void  __attribute__((regparm(2)))
+fsave(fpu_addr_modes addr_modes, u_char *data_address)
 {
   u_char *d;
   int offset = (top & 7) * sizeof(FPU_REG), other = 8*sizeof(FPU_REG) - offset;
Index: fpu/wmFPUemu_glue.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/fpu/wmFPUemu_glue.cc,v
retrieving revision 1.17
diff -u -r1.17 wmFPUemu_glue.cc
--- fpu/wmFPUemu_glue.cc	6 Jan 2003 02:20:46 -0000	1.17
+++ fpu/wmFPUemu_glue.cc	12 Feb 2003 14:12:39 -0000
@@ -189,7 +189,7 @@
 //BX_DEBUG(( "fpu_set_ax(0x%04x)", (unsigned) val16));
 }
 
-  void
+  void __attribute__((regparm(3)))
 fpu_verify_area(unsigned what, void *ptr, unsigned n)
 {
   bx_segment_reg_t *seg;
@@ -213,7 +213,7 @@
 }
 
 
-  unsigned
+  unsigned __attribute__((regparm(2)))
 fpu_get_user(void *ptr, unsigned len)
 {
   Bit32u val32;
@@ -238,7 +238,7 @@
   return(val32);
 }
 
-  void
+  void __attribute__((regparm(2)))
 fpu_put_user(unsigned val, void *ptr, unsigned len)
 {
   Bit32u val32;
Index: iodev/cdrom.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/iodev/cdrom.cc,v
retrieving revision 1.58
diff -u -r1.58 cdrom.cc
--- iodev/cdrom.cc	30 Jan 2003 20:44:32 -0000	1.58
+++ iodev/cdrom.cc	12 Feb 2003 14:12:39 -0000
@@ -1250,7 +1250,7 @@
 #endif
 }
 
-  void
+  void __attribute__((regparm(2)))
 cdrom_interface::read_block(uint8* buf, int lba)
 {
   // Read a single block from the CD
Index: iodev/cdrom.h
===================================================================
RCS file: /cvsroot/bochs/bochs/iodev/cdrom.h,v
retrieving revision 1.11
diff -u -r1.11 cdrom.h
--- iodev/cdrom.h	25 Oct 2002 11:44:38 -0000	1.11
+++ iodev/cdrom.h	12 Feb 2003 14:12:39 -0000
@@ -47,7 +47,7 @@
   uint32 capacity();
 
   // Read a single block from the CD
-  void read_block(uint8* buf, int lba);
+  void read_block(uint8* buf, int lba) __attribute__((regparm(1)));
 
 private:
   int fd;
Index: iodev/devices.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/iodev/devices.cc,v
retrieving revision 1.50
diff -u -r1.50 devices.cc
--- iodev/devices.cc	28 Jan 2003 16:56:59 -0000	1.50
+++ iodev/devices.cc	12 Feb 2003 14:12:40 -0000
@@ -599,7 +599,7 @@
  * Read a byte of data from the IO memory address space
  */
 
-  Bit32u
+  Bit32u __attribute__((regparm(2)))
 bx_devices_c::inp(Bit16u addr, unsigned io_len)
 {
   Bit8u handle;
@@ -621,7 +621,7 @@
  * Write a byte of data to the IO memory address space.
  */
 
-  void
+  void __attribute__((regparm(3)))
 bx_devices_c::outp(Bit16u addr, Bit32u value, unsigned io_len)
 {
   Bit8u handle;
Index: iodev/dma.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/iodev/dma.cc,v
retrieving revision 1.26
diff -u -r1.26 dma.cc
--- iodev/dma.cc	4 Nov 2002 17:29:12 -0000	1.26
+++ iodev/dma.cc	12 Feb 2003 14:12:40 -0000
@@ -212,7 +212,7 @@
   // static IO port read callback handler
   // redirects to non-static class handler to avoid virtual functions
 
-  Bit32u
+  Bit32u __attribute__((regparm(3)))
 bx_dma_c::read_handler(void *this_ptr, Bit32u address, unsigned io_len)
 {
 #if !BX_USE_DMA_SMF
@@ -222,7 +222,7 @@
 }
 
   /* 8237 DMA controller */
-  Bit32u
+  Bit32u __attribute__((regparm(2)))
 bx_dma_c::read( Bit32u   address, unsigned io_len)
 {
 #else
@@ -343,7 +343,7 @@
   // static IO port write callback handler
   // redirects to non-static class handler to avoid virtual functions
 
-  void
+  void __attribute__((regparm(3)))
 bx_dma_c::write_handler(void *this_ptr, Bit32u address, Bit32u value, unsigned io_len)
 {
 #if !BX_USE_DMA_SMF
@@ -354,7 +354,7 @@
 
 
   /* 8237 DMA controller */
-  void
+  void __attribute__((regparm(3)))
 bx_dma_c::write(Bit32u   address, Bit32u   value, unsigned io_len)
 {
 #else
Index: iodev/dma.h
===================================================================
RCS file: /cvsroot/bochs/bochs/iodev/dma.h,v
retrieving revision 1.12
diff -u -r1.12 dma.h
--- iodev/dma.h	25 Oct 2002 11:44:39 -0000	1.12
+++ iodev/dma.h	12 Feb 2003 14:12:40 -0000
@@ -63,11 +63,11 @@
 
 private:
 
-  static Bit32u read_handler(void *this_ptr, Bit32u address, unsigned io_len);
-  static void   write_handler(void *this_ptr, Bit32u address, Bit32u value, unsigned io_len);
+  static Bit32u read_handler(void *this_ptr, Bit32u address, unsigned io_len) __attribute__((regparm(3)));
+  static void   write_handler(void *this_ptr, Bit32u address, Bit32u value, unsigned io_len) __attribute__((regparm(3)));
 #if !BX_USE_DMA_SMF
-  Bit32u   read( Bit32u   address, unsigned io_len);
-  void     write(Bit32u   address, Bit32u   value, unsigned io_len);
+  Bit32u   read( Bit32u   address, unsigned io_len) __attribute__((regparm(2)));
+  void     write(Bit32u   address, Bit32u   value, unsigned io_len) __attribute__((regparm(1)));
 #endif
   BX_DMA_SMF void control_HRQ(bx_bool ma_sl);
   BX_DMA_SMF void reset_controller(unsigned num);
Index: iodev/harddrv.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/iodev/harddrv.cc,v
retrieving revision 1.95
diff -u -r1.95 harddrv.cc
--- iodev/harddrv.cc	1 Feb 2003 12:21:43 -0000	1.95
+++ iodev/harddrv.cc	12 Feb 2003 14:12:42 -0000
@@ -2388,7 +2388,7 @@
 }
 
 
-  bx_bool
+  bx_bool __attribute__((regparm(2)))
 bx_hard_drive_c::calculate_logical_address(Bit8u channel, off_t *sector)
 {
       off_t logical_sector;
@@ -2418,7 +2418,7 @@
       return true;
 }
 
-  void
+  void __attribute__((regparm(1)))
 bx_hard_drive_c::increment_address(Bit8u channel)
 {
       BX_SELECTED_CONTROLLER(channel).sector_count--;
@@ -2887,7 +2887,7 @@
     }
 }
 
-  void
+  void __attribute__((regparm(3)))
 bx_hard_drive_c::init_send_atapi_command(Bit8u channel, Bit8u command, int req_length, int alloc_length, bool lazy)
 {
       // BX_SELECTED_CONTROLLER(channel).byte_count is a union of BX_SELECTED_CONTROLLER(channel).cylinder_no;
@@ -2961,7 +2961,7 @@
       BX_SELECTED_DRIVE(channel).sense.ascq = 0;
 }
 
-void
+void __attribute__((regparm(1)))
 bx_hard_drive_c::atapi_cmd_nop(Bit8u channel)
 {
       BX_SELECTED_CONTROLLER(channel).interrupt_reason.i_o = 1;
@@ -2990,13 +2990,13 @@
       memcpy(BX_SELECTED_CONTROLLER(channel).buffer + 8, src, size);
 }
 
-  void
+  void __attribute__((regparm(1)))
 bx_hard_drive_c::ready_to_send_atapi(Bit8u channel)
 {
       raise_interrupt(channel);
 }
 
-void
+void __attribute__((regparm(1)))
 bx_hard_drive_c::raise_interrupt(Bit8u channel)
 {
 	BX_DEBUG(("raise_interrupt called, disable_irq = %02x", BX_SELECTED_CONTROLLER(channel).control.disable_irq));
@@ -3387,12 +3387,14 @@
       data[7] = 0x00;
 }
 
-uint16 read_16bit(const uint8* buf)
+uint16  __attribute__((regparm(1))) 
+read_16bit(const uint8* buf)
 {
       return (buf[0] << 8) | buf[1];
 }
 
-uint32 read_32bit(const uint8* buf)
+uint32  __attribute__((regparm(1)))
+read_32bit(const uint8* buf)
 {
       return (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
 }
Index: iodev/harddrv.h
===================================================================
RCS file: /cvsroot/bochs/bochs/iodev/harddrv.h,v
retrieving revision 1.18
diff -u -r1.18 harddrv.h
--- iodev/harddrv.h	25 Oct 2002 11:44:40 -0000	1.18
+++ iodev/harddrv.h	12 Feb 2003 14:12:42 -0000
@@ -241,8 +241,8 @@
   error_recovery_t ();
 };
 
-uint16 read_16bit(const uint8* buf);
-uint32 read_32bit(const uint8* buf);
+uint16 read_16bit(const uint8* buf) __attribute__((regparm(1)));
+uint32 read_32bit(const uint8* buf) __attribute__((regparm(1)));
 
 
 #ifdef LOWLEVEL_CDROM
@@ -315,18 +315,18 @@
 
 private:
 
-  BX_HD_SMF bx_bool calculate_logical_address(Bit8u channel, off_t *sector);
-  BX_HD_SMF void increment_address(Bit8u channel);
+  BX_HD_SMF bx_bool calculate_logical_address(Bit8u channel, off_t *sector) __attribute__((regparm(2)));
+  BX_HD_SMF void increment_address(Bit8u channel) __attribute__((regparm(1)));
   BX_HD_SMF void identify_drive(Bit8u channel);
   BX_HD_SMF void identify_ATAPI_drive(Bit8u channel);
   BX_HD_SMF void command_aborted(Bit8u channel, unsigned command);
 
-  BX_HD_SMF void init_send_atapi_command(Bit8u channel, Bit8u command, int req_length, int alloc_length, bool lazy = false);
-  BX_HD_SMF void ready_to_send_atapi(Bit8u channel);
-  BX_HD_SMF void raise_interrupt(Bit8u channel);
+  BX_HD_SMF void init_send_atapi_command(Bit8u channel, Bit8u command, int req_length, int alloc_length, bool lazy = false) __attribute__((regparm(3)));
+  BX_HD_SMF void ready_to_send_atapi(Bit8u channel) __attribute__((regparm(1)));
+  BX_HD_SMF void raise_interrupt(Bit8u channel) __attribute__((regparm(1)));
   BX_HD_SMF void atapi_cmd_error(Bit8u channel, sense_t sense_key, asc_t asc);
   BX_HD_SMF void init_mode_sense_single(Bit8u channel, const void* src, int size);
-  BX_HD_SMF void atapi_cmd_nop(Bit8u channel);
+  BX_HD_SMF void atapi_cmd_nop(Bit8u channel) __attribute__((regparm(1)));
 
   // FIXME:
   // For each ATA channel we should have one controller struct
Index: iodev/iodev.h
===================================================================
RCS file: /cvsroot/bochs/bochs/iodev/iodev.h,v
retrieving revision 1.29
diff -u -r1.29 iodev.h
--- iodev/iodev.h	28 Jan 2003 16:57:00 -0000	1.29
+++ iodev/iodev.h	12 Feb 2003 14:12:42 -0000
@@ -287,8 +287,8 @@
   bx_bool register_irq(unsigned irq, const char *name);
   bx_bool unregister_irq(unsigned irq, const char *name);
   void iodev_init(void);
-  Bit32u inp(Bit16u addr, unsigned io_len);
-  void   outp(Bit16u addr, Bit32u value, unsigned io_len);
+  Bit32u inp(Bit16u addr, unsigned io_len) __attribute__((regparm(2)));
+  void   outp(Bit16u addr, Bit32u value, unsigned io_len) __attribute__((regparm(3)));
 
   static void timer_handler(void *);
   void timer(void);
Index: iodev/keyboard.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/iodev/keyboard.cc,v
retrieving revision 1.74
diff -u -r1.74 keyboard.cc
--- iodev/keyboard.cc	5 Jan 2003 01:37:21 -0000	1.74
+++ iodev/keyboard.cc	12 Feb 2003 14:12:43 -0000
@@ -785,7 +785,7 @@
 
 
 
-  void
+  void __attribute__((regparm(1)))
 bx_keyb_c::set_kbd_clock_enable(Bit8u   value)
 {
   bx_bool prev_kbd_clock_enabled;
@@ -930,7 +930,7 @@
 //BX_DEBUG(( "#   out_buffer = %u", (unsigned) BX_KEY_THIS s.kbd_controller.kbd_output_buffer);
 }
 
-  bx_bool
+  bx_bool __attribute__((regparm(3)))
 bx_keyb_c::mouse_enQ_packet(Bit8u   b1, Bit8u   b2, Bit8u   b3)
 {
   if ((BX_KEY_THIS s.mouse_internal_buffer.num_elements + 3) >= BX_MOUSE_BUFF_SIZE) {
Index: iodev/keyboard.h
===================================================================
RCS file: /cvsroot/bochs/bochs/iodev/keyboard.h,v
retrieving revision 1.20
diff -u -r1.20 keyboard.h
--- iodev/keyboard.h	26 Dec 2002 22:19:44 -0000	1.20
+++ iodev/keyboard.h	12 Feb 2003 14:12:43 -0000
@@ -215,7 +215,7 @@
   bx_bool stop_paste;  // stop the current paste operation on hardware reset
 
   BX_KEY_SMF void     resetinternals(bx_bool powerup);
-  BX_KEY_SMF void     set_kbd_clock_enable(Bit8u   value);
+  BX_KEY_SMF void     set_kbd_clock_enable(Bit8u   value) __attribute__((regparm(1)));
   BX_KEY_SMF void     set_aux_clock_enable(Bit8u   value);
   BX_KEY_SMF void     kbd_ctrl_to_kbd(Bit8u   value);
   BX_KEY_SMF void     kbd_ctrl_to_mouse(Bit8u   value);
@@ -223,7 +223,7 @@
   BX_KEY_SMF void     kbd_enQ_imm(Bit8u   val);
   BX_KEY_SMF void     activate_timer(void);
   BX_KEY_SMF void     controller_enQ(Bit8u   data, unsigned source);
-  BX_KEY_SMF bx_bool  mouse_enQ_packet(Bit8u   b1, Bit8u   b2, Bit8u   b3);
+  BX_KEY_SMF bx_bool  mouse_enQ_packet(Bit8u   b1, Bit8u   b2, Bit8u   b3) __attribute__((regparm(3)));
   BX_KEY_SMF void     mouse_enQ(Bit8u   mouse_data);
 
   static void   timer_handler(void *);
Index: iodev/ne2k.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/iodev/ne2k.cc,v
retrieving revision 1.47
diff -u -r1.47 ne2k.cc
--- iodev/ne2k.cc	13 Dec 2002 18:27:07 -0000	1.47
+++ iodev/ne2k.cc	12 Feb 2003 14:12:43 -0000
@@ -236,7 +236,7 @@
 // The first 16 bytes contains the MAC address at even locations,
 // and there is 16K of buffer memory starting at 16K
 //
-Bit32u
+Bit32u __attribute__((regparm(2)))
 bx_ne2k_c::chipmem_read(Bit32u address, unsigned int io_len)
 {
   Bit32u retval = 0;
@@ -266,7 +266,7 @@
   return (0xff);
 }
 
-void
+void __attribute__((regparm(3)))
 bx_ne2k_c::chipmem_write(Bit32u address, Bit32u value, unsigned io_len)
 {
   if ((io_len == 2) && (address & 0x1)) 
@@ -290,7 +290,7 @@
 // after that, insw/outsw instructions can be used to move
 // the appropriate number of bytes to/from the device.
 //
-Bit32u
+Bit32u __attribute__((regparm(2)))
 bx_ne2k_c::asic_read(Bit32u offset, unsigned int io_len)
 {
   Bit32u retval = 0;
Index: iodev/ne2k.h
===================================================================
RCS file: /cvsroot/bochs/bochs/iodev/ne2k.h,v
retrieving revision 1.10
diff -u -r1.10 ne2k.h
--- iodev/ne2k.h	19 Nov 2002 18:56:39 -0000	1.10
+++ iodev/ne2k.h	12 Feb 2003 14:12:43 -0000
@@ -209,14 +209,14 @@
   BX_NE2K_SMF Bit32u read_cr(void);
   BX_NE2K_SMF void   write_cr(Bit32u value);
 
-  BX_NE2K_SMF Bit32u chipmem_read(Bit32u address, unsigned io_len);
-  BX_NE2K_SMF Bit32u asic_read(Bit32u offset, unsigned io_len);
+  BX_NE2K_SMF Bit32u chipmem_read(Bit32u address, unsigned io_len) __attribute__((regparm(2)));
+  BX_NE2K_SMF Bit32u asic_read(Bit32u offset, unsigned io_len) __attribute__((regparm(2)));
   BX_NE2K_SMF Bit32u page0_read(Bit32u offset, unsigned io_len);
   BX_NE2K_SMF Bit32u page1_read(Bit32u offset, unsigned io_len);
   BX_NE2K_SMF Bit32u page2_read(Bit32u offset, unsigned io_len);
   BX_NE2K_SMF Bit32u page3_read(Bit32u offset, unsigned io_len);
 
-  BX_NE2K_SMF void chipmem_write(Bit32u address, Bit32u value, unsigned io_len);
+  BX_NE2K_SMF void chipmem_write(Bit32u address, Bit32u value, unsigned io_len) __attribute__((regparm(3)));
   BX_NE2K_SMF void asic_write(Bit32u address, Bit32u value, unsigned io_len);
   BX_NE2K_SMF void page0_write(Bit32u address, Bit32u value, unsigned io_len);
   BX_NE2K_SMF void page1_write(Bit32u address, Bit32u value, unsigned io_len);
Index: iodev/pit82c54.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/iodev/pit82c54.cc,v
retrieving revision 1.20
diff -u -r1.20 pit82c54.cc
--- iodev/pit82c54.cc	27 Aug 2002 19:54:46 -0000	1.20
+++ iodev/pit82c54.cc	12 Feb 2003 14:12:43 -0000
@@ -97,12 +97,14 @@
     thisctr.OUTpin=data;
   }
 
-  void pit_82C54::set_count (counter_type & thisctr, Bit32u data) {
+  void  __attribute__((regparm(2)))
+pit_82C54::set_count (counter_type & thisctr, Bit32u data) {
     thisctr.count=data & 0xFFFF;
     set_binary_to_count(thisctr);
   }
 
-  void pit_82C54::set_count_to_binary(counter_type & thisctr) {
+  void  __attribute__((regparm(1)))
+pit_82C54::set_count_to_binary(counter_type & thisctr) {
     if(thisctr.bcd_mode) {
       thisctr.count=
 	(((thisctr.count_binary/1)%10)<<0) |
@@ -115,7 +117,8 @@
     }
   }
 
-  void pit_82C54::set_binary_to_count(counter_type & thisctr) {
+  void  __attribute__((regparm(1)))
+pit_82C54::set_binary_to_count(counter_type & thisctr) {
     if(thisctr.bcd_mode) {
       thisctr.count_binary=
 	(1*((thisctr.count>>0)&0xF)) +
@@ -128,7 +131,8 @@
     }
   }
 
-  void pit_82C54::decrement (counter_type & thisctr) {
+  void  __attribute__((regparm(1)))
+pit_82C54::decrement (counter_type & thisctr) {
     if(!thisctr.count) {
       if(thisctr.bcd_mode) {
 	thisctr.count=0x9999;
@@ -181,7 +185,8 @@
   void pit_82C54::reset (unsigned type) {
   }
 
-void pit_82C54::decrement_multiple(counter_type & thisctr, Bit32u cycles) {
+void  __attribute__((regparm(2)))
+pit_82C54::decrement_multiple(counter_type & thisctr, Bit32u cycles) {
   while(cycles>0) {
     if(cycles<=thisctr.count_binary) {
       thisctr.count_binary-=cycles;
@@ -276,7 +281,8 @@
   }
 }
 
-  void pit_82C54::clock(Bit8u cnum) {
+  void  __attribute__((regparm(1)))
+pit_82C54::clock(Bit8u cnum) {
     if(cnum>MAX_COUNTER) {
       BX_ERROR(("Counter number too high in clock"));
     } else {
Index: iodev/pit82c54.h
===================================================================
RCS file: /cvsroot/bochs/bochs/iodev/pit82c54.h,v
retrieving revision 1.11
diff -u -r1.11 pit82c54.h
--- iodev/pit82c54.h	27 Aug 2002 19:54:46 -0000	1.11
+++ iodev/pit82c54.h	12 Feb 2003 14:12:43 -0000
@@ -94,17 +94,17 @@
 
   void set_OUT (counter_type & thisctr, bool data);
 
-  void set_count (counter_type & thisctr, Bit32u data);
+  void set_count (counter_type & thisctr, Bit32u data) __attribute__((regparm(2)));
 
-  void set_count_to_binary (counter_type & thisctr);
+  void set_count_to_binary (counter_type & thisctr) __attribute__((regparm(1)));
 
-  void set_binary_to_count (counter_type & thisctr);
+  void set_binary_to_count (counter_type & thisctr) __attribute__((regparm(1)));
 
-  void decrement (counter_type & thisctr);
+  void decrement (counter_type & thisctr) __attribute__((regparm(1)));
 
-  void decrement_multiple(counter_type & thisctr, Bit32u cycles);
+  void decrement_multiple(counter_type & thisctr, Bit32u cycles) __attribute__((regparm(2)));
 
-  void clock(Bit8u cnum);
+  void clock(Bit8u cnum) __attribute__((regparm(1)));
 
   void print_counter(counter_type & thisctr);
 
Index: iodev/vga.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/iodev/vga.cc,v
retrieving revision 1.61
diff -u -r1.61 vga.cc
--- iodev/vga.cc	9 Feb 2003 08:25:22 -0000	1.61
+++ iodev/vga.cc	12 Feb 2003 14:12:44 -0000
@@ -2226,11 +2226,11 @@
 
 
 #if BX_SUPPORT_VBE
-  Bit8u
+  Bit8u  __attribute__((regparm(1)))
 bx_vga_c::vbe_mem_read(Bit32u addr)
 {
-  Bit32u offset;        
-  
+  Bit32u offset;
+
   if (addr >= VBE_DISPI_LFB_PHYSICAL_ADDRESS)
   {
     // LFB read
@@ -2249,12 +2249,12 @@
   return (BX_VGA_THIS s.vbe_memory[offset]);
 }
 
-  void
+  void __attribute__((regparm(2)))
 bx_vga_c::vbe_mem_write(Bit32u addr, Bit8u value)
 {
-  Bit32u offset;        
+  Bit32u offset;
   unsigned x_tileno, y_tileno;
-  
+
   if (addr >= VBE_DISPI_LFB_PHYSICAL_ADDRESS)
   {
     // LFB write
Index: iodev/vga.h
===================================================================
RCS file: /cvsroot/bochs/bochs/iodev/vga.h,v
retrieving revision 1.23
diff -u -r1.23 vga.h
--- iodev/vga.h	9 Feb 2003 08:25:22 -0000	1.23
+++ iodev/vga.h	12 Feb 2003 14:12:45 -0000
@@ -106,11 +106,11 @@
   virtual void   mem_write(Bit32u addr, Bit8u value);
   virtual void   trigger_timer(void *this_ptr);
 
-#if BX_SUPPORT_VBE 
-  BX_VGA_SMF Bit8u  vbe_mem_read(Bit32u addr);
-  BX_VGA_SMF void   vbe_mem_write(Bit32u addr, Bit8u value);  
+#if BX_SUPPORT_VBE
+  BX_VGA_SMF Bit8u  vbe_mem_read(Bit32u addr) __attribute__((regparm(1)));
+  BX_VGA_SMF void   vbe_mem_write(Bit32u addr, Bit8u value) __attribute__((regparm(2)));
 #endif
-  
+
   virtual void   redraw_area(unsigned x0, unsigned y0,
                              unsigned width, unsigned height);
 
Index: memory/memory.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/memory/memory.cc,v
retrieving revision 1.25
diff -u -r1.25 memory.cc
--- memory/memory.cc	3 Nov 2002 17:17:11 -0000	1.25
+++ memory/memory.cc	12 Feb 2003 14:12:45 -0000
@@ -36,7 +36,7 @@
 
 #if BX_PROVIDE_CPU_MEMORY
 
-  void
+  void __attribute__((regparm(3)))
 BX_MEM_C::writePhysicalPage(BX_CPU_C *cpu, Bit32u addr, unsigned len, void *data)
 {
   Bit8u *data_ptr;
@@ -233,7 +233,7 @@
 }
 
 
-  void
+  void __attribute__((regparm(3)))
 BX_MEM_C::readPhysicalPage(BX_CPU_C *cpu, Bit32u addr, unsigned len, void *data)
 {
   Bit8u *data_ptr;
Index: memory/memory.h
===================================================================
RCS file: /cvsroot/bochs/bochs/memory/memory.h,v
retrieving revision 1.13
diff -u -r1.13 memory.h
--- memory/memory.h	25 Oct 2002 11:44:41 -0000	1.13
+++ memory/memory.h	12 Feb 2003 14:12:45 -0000
@@ -60,23 +60,23 @@
   BX_MEM_C(void);
   BX_MEM_C(size_t memsize);
   ~BX_MEM_C(void);
-  BX_MEM_SMF void    alloc_vector_aligned (size_t bytes, size_t alignment);
+  BX_MEM_SMF void    alloc_vector_aligned (size_t bytes, size_t alignment) __attribute__((regparm(2)));
   BX_MEM_SMF void    init_memory(int memsize);
   BX_MEM_SMF void    readPhysicalPage(BX_CPU_C *cpu, Bit32u addr,
-                                      unsigned len, void *data);
+                                      unsigned len, void *data) __attribute__((regparm(3)));
   BX_MEM_SMF void    writePhysicalPage(BX_CPU_C *cpu, Bit32u addr,
-                                       unsigned len, void *data);
+                                       unsigned len, void *data) __attribute__((regparm(3)));
   BX_MEM_SMF void    load_ROM(const char *path, Bit32u romaddress);
   BX_MEM_SMF Bit32u  get_memory_in_k(void);
 #if BX_PCI_SUPPORT
-  BX_MEM_SMF Bit8u*  pci_fetch_ptr(Bit32u addr);
+  BX_MEM_SMF Bit8u*  pci_fetch_ptr(Bit32u addr) __attribute__((regparm(1)));
 #endif
   BX_MEM_SMF bx_bool dbg_fetch_mem(Bit32u addr, unsigned len, Bit8u *buf);
   BX_MEM_SMF bx_bool dbg_set_mem(Bit32u addr, unsigned len, Bit8u *buf);
   BX_MEM_SMF bx_bool dbg_crc32(
     unsigned long (*f)(unsigned char *buf, int len),
     Bit32u addr1, Bit32u addr2, Bit32u *crc);
-  BX_MEM_SMF Bit8u * getHostMemAddr(BX_CPU_C *cpu, Bit32u a20Addr, unsigned op);
+  BX_MEM_SMF Bit8u * getHostMemAddr(BX_CPU_C *cpu, Bit32u a20Addr, unsigned op) __attribute__((regparm(3)));
   };
 
 #if BX_PROVIDE_CPU_MEMORY==1
Index: memory/misc_mem.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/memory/misc_mem.cc,v
retrieving revision 1.35
diff -u -r1.35 misc_mem.cc
--- memory/misc_mem.cc	29 Jan 2003 15:01:16 -0000	1.35
+++ memory/misc_mem.cc	12 Feb 2003 14:12:45 -0000
@@ -63,7 +63,7 @@
 
 
 #if BX_PROVIDE_CPU_MEMORY
-void
+void __attribute__((regparm(2)))
 BX_MEM_C::alloc_vector_aligned (size_t bytes, size_t alignment)
 {
   if (actual_vector != NULL) {
@@ -196,7 +196,7 @@
 #endif // #if BX_PROVIDE_CPU_MEMORY
 
 #if BX_PCI_SUPPORT
-  Bit8u*
+  Bit8u* __attribute__((regparm(1)))
 BX_MEM_C::pci_fetch_ptr(Bit32u addr)
 {
   if (bx_options.Oi440FXSupport->get ()) {
@@ -306,7 +306,7 @@
 }
 
 
-  Bit8u *
+  Bit8u * __attribute__((regparm(3)))
 BX_MEM_C::getHostMemAddr(BX_CPU_C *cpu, Bit32u a20Addr, unsigned op)
   // Return a host address corresponding to the guest physical memory
   // address (with A20 already applied), given that the calling
