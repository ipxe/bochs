----------------------------------------------------------------------
Patch name: patch-bochs-instrumentation
Author: Stanislav Shwartsman
Date: 09/20/2002

Detailed description:

 I totally rehashed an instrumentation stuff, removed unimplemented 
 and added a new callbacks. New instrumentation supports SMP
 configuratuions and x86-64 as well.

Patch was created with:
  cvs diff -u
Apply patch to what version:
  cvs checked out on DATE, release version VER
Instructions:
  To patch, go to main bochs directory.
  Type "patch -p1 < THIS_PATCH_FILE".
----------------------------------------------------------------------
diff -u -r -N bochs/cpu/access.cc bochs-instrumentation/cpu/access.cc
--- bochs/cpu/access.cc	2002-09-19 21:17:19.000000000 +0200
+++ bochs-instrumentation/cpu/access.cc	2002-09-20 18:13:43.000000000 +0200
@@ -280,7 +280,7 @@
       unsigned pl;
 accessOK:
       laddr = seg->cache.u.segment.base + offset;
-      BX_INSTR_MEM_DATA(laddr, 1, BX_WRITE);
+      BX_INSTR_MEM_DATA(CPU_ID, laddr, 1, BX_WRITE);
       pl = (CPL==3);
 
 #if BX_SupportGuest2HostTLB
@@ -343,7 +343,7 @@
       unsigned pl;
 accessOK:
       laddr = seg->cache.u.segment.base + offset;
-      BX_INSTR_MEM_DATA(laddr, 2, BX_WRITE);
+      BX_INSTR_MEM_DATA(CPU_ID, laddr, 2, BX_WRITE);
       pl = (CPL==3);
 
 #if BX_SupportGuest2HostTLB
@@ -408,7 +408,7 @@
       unsigned pl;
 accessOK:
       laddr = seg->cache.u.segment.base + offset;
-      BX_INSTR_MEM_DATA(laddr, 4, BX_WRITE);
+      BX_INSTR_MEM_DATA(CPU_ID, laddr, 4, BX_WRITE);
       pl = (CPL==3);
 
 #if BX_SupportGuest2HostTLB
@@ -473,7 +473,7 @@
       unsigned pl;
 accessOK:
       laddr = seg->cache.u.segment.base + offset;
-      BX_INSTR_MEM_DATA(laddr, 1, BX_READ);
+      BX_INSTR_MEM_DATA(CPU_ID, laddr, 1, BX_READ);
       pl = (CPL==3);
 
 #if BX_SupportGuest2HostTLB
@@ -524,7 +524,7 @@
       unsigned pl;
 accessOK:
       laddr = seg->cache.u.segment.base + offset;
-      BX_INSTR_MEM_DATA(laddr, 2, BX_READ);
+      BX_INSTR_MEM_DATA(CPU_ID, laddr, 2, BX_READ);
       pl = (CPL==3);
 
 #if BX_SupportGuest2HostTLB
@@ -578,7 +578,7 @@
       unsigned pl;
 accessOK:
       laddr = seg->cache.u.segment.base + offset;
-      BX_INSTR_MEM_DATA(laddr, 4, BX_READ);
+      BX_INSTR_MEM_DATA(CPU_ID, laddr, 4, BX_READ);
       pl = (CPL==3);
 
 #if BX_SupportGuest2HostTLB
@@ -637,7 +637,7 @@
       unsigned pl;
 accessOK:
       laddr = seg->cache.u.segment.base + offset;
-      BX_INSTR_MEM_DATA(laddr, 1, BX_READ);
+      BX_INSTR_MEM_DATA(CPU_ID, laddr, 1, BX_READ);
       pl = (CPL==3);
 
 #if BX_SupportGuest2HostTLB
@@ -704,7 +704,7 @@
       unsigned pl;
 accessOK:
       laddr = seg->cache.u.segment.base + offset;
-      BX_INSTR_MEM_DATA(laddr, 2, BX_READ);
+      BX_INSTR_MEM_DATA(CPU_ID, laddr, 2, BX_READ);
       pl = (CPL==3);
 
 #if BX_SupportGuest2HostTLB
@@ -770,7 +770,7 @@
       unsigned pl;
 accessOK:
       laddr = seg->cache.u.segment.base + offset;
-      BX_INSTR_MEM_DATA(laddr, 4, BX_READ);
+      BX_INSTR_MEM_DATA(CPU_ID, laddr, 4, BX_READ);
       pl = (CPL==3);
 
 #if BX_SupportGuest2HostTLB
@@ -827,7 +827,7 @@
   void
 BX_CPU_C::write_RMW_virtual_byte(Bit8u val8)
 {
-  BX_INSTR_MEM_DATA(BX_CPU_THIS_PTR address_xlation.paddress1, 1, BX_WRITE);
+  BX_INSTR_MEM_DATA(CPU_ID, BX_CPU_THIS_PTR address_xlation.paddress1, 1, BX_WRITE);
 
   if (BX_CPU_THIS_PTR address_xlation.pages > 2) {
     // Pages > 2 means it stores a host address for direct access.
@@ -844,7 +844,7 @@
   void
 BX_CPU_C::write_RMW_virtual_word(Bit16u val16)
 {
-  BX_INSTR_MEM_DATA(BX_CPU_THIS_PTR address_xlation.paddress1, 2, BX_WRITE);
+  BX_INSTR_MEM_DATA(CPU_ID, BX_CPU_THIS_PTR address_xlation.paddress1, 2, BX_WRITE);
 
   if (BX_CPU_THIS_PTR address_xlation.pages > 2) {
     // Pages > 2 means it stores a host address for direct access.
@@ -873,7 +873,7 @@
   void
 BX_CPU_C::write_RMW_virtual_dword(Bit32u val32)
 {
-  BX_INSTR_MEM_DATA(BX_CPU_THIS_PTR address_xlation.paddress1, 4, BX_WRITE);
+  BX_INSTR_MEM_DATA(CPU_ID, BX_CPU_THIS_PTR address_xlation.paddress1, 4, BX_WRITE);
 
   if (BX_CPU_THIS_PTR address_xlation.pages > 2) {
     // Pages > 2 means it stores a host address for direct access.
@@ -920,7 +920,7 @@
       unsigned pl;
 accessOK:
       laddr = seg->cache.u.segment.base + offset;
-      BX_INSTR_MEM_DATA(laddr, 8, BX_WRITE);
+      BX_INSTR_MEM_DATA(CPU_ID, laddr, 8, BX_WRITE);
       pl = (CPL==3);
 
 #if BX_SupportGuest2HostTLB
@@ -986,7 +986,7 @@
       unsigned pl;
 accessOK:
       laddr = seg->cache.u.segment.base + offset;
-      BX_INSTR_MEM_DATA(laddr, 8, BX_READ);
+      BX_INSTR_MEM_DATA(CPU_ID, laddr, 8, BX_READ);
       pl = (CPL==3);
 
 #if BX_SupportGuest2HostTLB
@@ -1030,7 +1030,7 @@
   void
 BX_CPU_C::write_RMW_virtual_qword(Bit64u val64)
 {
-  BX_INSTR_MEM_DATA(BX_CPU_THIS_PTR address_xlation.paddress1, 8, BX_WRITE);
+  BX_INSTR_MEM_DATA(CPU_ID, BX_CPU_THIS_PTR address_xlation.paddress1, 8, BX_WRITE);
 
   if (BX_CPU_THIS_PTR address_xlation.pages > 2) {
     // Pages > 2 means it stores a host address for direct access.
@@ -1076,7 +1076,7 @@
       unsigned pl;
 accessOK:
       laddr = seg->cache.u.segment.base + offset;
-      BX_INSTR_MEM_DATA(laddr, 8, BX_READ);
+      BX_INSTR_MEM_DATA(CPU_ID, laddr, 8, BX_READ);
       pl = (CPL==3);
 
 #if BX_SupportGuest2HostTLB
diff -u -r -N bochs/cpu/cpu.cc bochs-instrumentation/cpu/cpu.cc
--- bochs/cpu/cpu.cc	2002-09-20 05:52:58.000000000 +0200
+++ bochs-instrumentation/cpu/cpu.cc	2002-09-20 22:15:45.000000000 +0200
@@ -24,8 +24,6 @@
 //  License along with this library; if not, write to the Free Software
 //  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 
-#define BX_INSTR_SPY 0
-
 
 #define NEED_CPU_REG_SHORTCUTS 1
 #include "bochs.h"
@@ -120,6 +118,7 @@
   bxInstruction_c iStorage BX_CPP_AlignN(32);
   i = &iStorage;
 #endif
+  Boolean is32;
 
 #if BX_DEBUGGER
   BX_CPU_THIS_PTR break_point = 0;
@@ -173,18 +172,6 @@
   }
 #endif  // #if BX_DEBUGGER
 
-#if BX_INSTR_SPY
-  {
-    int n=0;
-    if ((n & 0xffffff) == 0) {
-      Bit32u cs = BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value;
-      Bit32u rip = BX_CPU_THIS_PTR prev_eip;
-      fprintf (stdout, "instr %d, time %lld, pc %04x:%08x, fetch_ptr=%p\n", n, bx_pc_system.time_ticks (), cs, rip, fetch_ptr);
-    }
-    n++;
-  }
-#endif
-
 #if BX_EXTERNAL_DEBUGGER
   if (regs.debug_state != debug_run) {
     bx_external_debugger(this);
@@ -194,7 +181,6 @@
   {
   bx_address eipBiased;
   Bit8u *fetchPtr;
-  Boolean is32;
 
   eipBiased = RIP + BX_CPU_THIS_PTR eipPageBias;
 
@@ -281,6 +267,9 @@
       BX_CPU_THIS_PTR iCache.entry[iCacheHash].writeStamp = pageWriteStamp;
       }
 #endif
+
+    BX_INSTR_OPCODE(CPU_ID, fetchPtr - i->ilen(), i->ilen(), is32);
+
     resolveModRM = i->ResolveModrm; // Get function pointers as early
     execute      = i->execute;      // as possible for speculation.
     if (resolveModRM) {
@@ -292,6 +281,8 @@
 
 fetch_decode_OK:
 
+     BX_INSTR_FETCH_DECODE_COMPLETED(CPU_ID, i);
+
 #if BX_DEBUGGER
     if (BX_CPU_THIS_PTR trace) {
       // print the instruction that is about to be executed.
@@ -389,6 +380,7 @@
       REGISTER_IADDR(RIP + BX_CPU_THIS_PTR sregs[BX_SREG_CS].cache.u.segment.base);
 #endif
 
+      BX_INSTR_REPEAT_ITERATION(CPU_ID);
       BX_TICK1_IF_SINGLE_PROCESSOR();
 
 #if BX_DEBUGGER == 0
@@ -412,11 +404,15 @@
       REGISTER_IADDR(RIP + BX_CPU_THIS_PTR sregs[BX_SREG_CS].cache.u.segment.base);
 #endif
 
+      BX_INSTR_REPEAT_ITERATION(CPU_ID);
       BX_TICK1_IF_SINGLE_PROCESSOR();
       }
 
 debugger_check:
 
+    // inform instrumentation about new instruction
+    BX_INSTR_NEW_INSTRUCTION(CPU_ID);
+
 #if (BX_SMP_PROCESSORS>1 && BX_DEBUGGER==0)
     // The CHECK_MAX_INSTRUCTIONS macro allows cpu_loop to execute a few
     // instructions and then return so that the other processors have a chance
@@ -539,7 +535,9 @@
       BX_PANIC(("fetchDecode: cross boundary: ret==0"));
     if (resolveModRM) {
       BX_CPU_CALL_METHOD(resolveModRM, (i));
-      }
+    }
+
+    BX_INSTR_OPCODE(CPU_ID, fetchBuffer - i->ilen(), i->ilen(), is32);
 
 // Since we cross an instruction boundary, note that we need a prefetch()
 // again on the next instruction.  Perhaps we can optimize this to
@@ -664,7 +662,7 @@
     BX_CPU_THIS_PTR errorno = 0;
     BX_CPU_THIS_PTR EXT   = 1; /* external event */
     interrupt(vector, 0, 0, 0);
-    BX_INSTR_HWINTERRUPT(vector,
+    BX_INSTR_HWINTERRUPT(CPU_ID, vector,
         BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value, EIP);
     // Set up environment, as would be when this main cpu loop gets
     // invoked.  At the end of normal instructions, we always commmit
diff -u -r -N bochs/cpu/cpu.h bochs-instrumentation/cpu/cpu.h
--- bochs/cpu/cpu.h	2002-09-20 05:52:58.000000000 +0200
+++ bochs-instrumentation/cpu/cpu.h	2002-09-20 21:18:50.000000000 +0200
@@ -237,8 +237,7 @@
   }
 #endif
 
-
-
+#define CPU_ID (BX_CPU_THIS_PTR which_cpu())
 
 #ifndef CPL
 #define CPL  (BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.rpl)
@@ -332,23 +331,17 @@
 // object->*(fnptr)(arg, ...);
 // Since this is different from when SMF=1, encapsulate it in a macro.
 #  define BX_CPU_CALL_METHOD(func, args) \
-    do { \
-      BX_INSTR_OPCODE_BEGIN (BX_CPU_THIS_PTR sregs[BX_SREG_CS].cache.u.segment.base + BX_CPU_THIS_PTR prev_eip); \
-      (this->*((BxExecutePtr_t) (func))) args \
-      BX_INSTR_OPCODE_END (BX_CPU_THIS_PTR sregs[BX_SREG_CS].cache.u.segment.base + BX_CPU_THIS_PTR prev_eip); \
-    } while (0)
+        (this->*((BxExecutePtr_t) (func))) args; 
+
 #else
 // static member functions.  With SMF, there is only one CPU by definition.
 #  define BX_CPU_THIS_PTR  BX_CPU(0)->
 #  define BX_CPU_THIS      BX_CPU(0)
 #  define BX_SMF           static
 #  define BX_CPU_C_PREFIX
-#  define BX_CPU_CALL_METHOD(func, args)   \
-    do { \
-      BX_INSTR_OPCODE_BEGIN (BX_CPU_THIS_PTR sregs[BX_SREG_CS].cache.u.segment.base + BX_CPU_THIS_PTR prev_eip); \
-    ((BxExecutePtr_t) (func)) args; \
-      BX_INSTR_OPCODE_END (BX_CPU_THIS_PTR sregs[BX_SREG_CS].cache.u.segment.base + BX_CPU_THIS_PTR prev_eip); \
-    } while (0)
+#  define BX_CPU_CALL_METHOD(func, args) \
+        ((BxExecutePtr_t) (func)) args; 
+
 #endif
 
 #if BX_SMP_PROCESSORS==1
@@ -655,7 +648,7 @@
 class BX_CPU_C;
 
 
-class bxInstruction_c {
+typedef class bxInstruction_c {
 public:
   // Function pointers; a function to resolve the modRM address
   // given the current state of the CPU and the instruction data,
@@ -890,7 +883,7 @@
   BX_CPP_INLINE void setILen(unsigned ilen) {
       metaInfo |= (ilen<<22);
       }
-  };
+  } BxInstruction_t;
 
 
 #if BX_USE_CPU_SMF
diff -u -r -N bochs/cpu/ctrl_xfer16.cc bochs-instrumentation/cpu/ctrl_xfer16.cc
--- bochs/cpu/ctrl_xfer16.cc	2002-09-20 05:52:58.000000000 +0200
+++ bochs-instrumentation/cpu/ctrl_xfer16.cc	2002-09-20 18:19:45.000000000 +0200
@@ -89,7 +89,7 @@
         SP  += imm16;
       }
 
-  BX_INSTR_UCNEAR_BRANCH(BX_INSTR_IS_RET, EIP);
+  BX_INSTR_UCNEAR_BRANCH(CPU_ID, BX_INSTR_IS_RET, EIP);
 }
 
   void
@@ -134,7 +134,7 @@
       EIP = return_IP;
       }
 
-  BX_INSTR_UCNEAR_BRANCH(BX_INSTR_IS_RET, EIP);
+  BX_INSTR_UCNEAR_BRANCH(CPU_ID, BX_INSTR_IS_RET, EIP);
 }
 
   void
@@ -171,7 +171,7 @@
       SP  += imm16;
 
 done:
-  BX_INSTR_FAR_BRANCH(BX_INSTR_IS_RET,
+  BX_INSTR_FAR_BRANCH(CPU_ID, BX_INSTR_IS_RET,
                       BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value, EIP);
 }
 
@@ -199,7 +199,7 @@
     load_seg_reg(&BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS], cs_raw);
 
 done:
-  BX_INSTR_FAR_BRANCH(BX_INSTR_IS_RET,
+  BX_INSTR_FAR_BRANCH(CPU_ID, BX_INSTR_IS_RET,
                       BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value, EIP);
 }
 
@@ -231,7 +231,7 @@
 
   EIP = new_EIP;
 
-  BX_INSTR_UCNEAR_BRANCH(BX_INSTR_IS_CALL, EIP);
+  BX_INSTR_UCNEAR_BRANCH(CPU_ID, BX_INSTR_IS_CALL, EIP);
 }
 
   void
@@ -260,7 +260,7 @@
   load_seg_reg(&BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS], cs_raw);
 
 done:
-  BX_INSTR_FAR_BRANCH(BX_INSTR_IS_CALL,
+  BX_INSTR_FAR_BRANCH(CPU_ID, BX_INSTR_IS_CALL,
                       BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value, EIP);
 }
 
@@ -306,7 +306,7 @@
 
     EIP = op1_16;
 
-  BX_INSTR_UCNEAR_BRANCH(BX_INSTR_IS_CALL, EIP);
+  BX_INSTR_UCNEAR_BRANCH(CPU_ID, BX_INSTR_IS_CALL, EIP);
 }
 
   void
@@ -341,7 +341,7 @@
     load_seg_reg(&BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS], cs_raw);
 
 done:
-  BX_INSTR_FAR_BRANCH(BX_INSTR_IS_CALL,
+  BX_INSTR_FAR_BRANCH(CPU_ID, BX_INSTR_IS_CALL,
                       BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value, EIP);
 }
 
@@ -367,7 +367,7 @@
 #endif
 
   EIP = new_EIP;
-  BX_INSTR_UCNEAR_BRANCH(BX_INSTR_IS_JMP, new_EIP);
+  BX_INSTR_UCNEAR_BRANCH(CPU_ID, BX_INSTR_IS_JMP, new_EIP);
 }
 
   void
@@ -411,12 +411,12 @@
       }
 #endif
     EIP = new_EIP;
-    BX_INSTR_CNEAR_BRANCH_TAKEN(new_EIP);
+    BX_INSTR_CNEAR_BRANCH_TAKEN(CPU_ID, new_EIP);
     revalidate_prefetch_q();
     }
 #if BX_INSTRUMENTATION
   else {
-    BX_INSTR_CNEAR_BRANCH_NOT_TAKEN();
+    BX_INSTR_CNEAR_BRANCH_NOT_TAKEN(CPU_ID);
     }
 #endif
 }
@@ -453,7 +453,7 @@
 
   EIP = new_EIP;
 
-  BX_INSTR_UCNEAR_BRANCH(BX_INSTR_IS_JMP, new_EIP);
+  BX_INSTR_UCNEAR_BRANCH(CPU_ID, BX_INSTR_IS_JMP, new_EIP);
 }
 
   /* Far indirect jump */
@@ -486,7 +486,7 @@
     load_seg_reg(&BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS], cs_raw);
 
 done:
-  BX_INSTR_FAR_BRANCH(BX_INSTR_IS_JMP,
+  BX_INSTR_FAR_BRANCH(CPU_ID, BX_INSTR_IS_JMP,
                       BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value, EIP);
 }
 
@@ -525,6 +525,6 @@
   write_flags(flags, /* change IOPL? */ 1, /* change IF? */ 1);
 
 done:
-  BX_INSTR_FAR_BRANCH(BX_INSTR_IS_IRET,
+  BX_INSTR_FAR_BRANCH(CPU_ID, BX_INSTR_IS_IRET,
                       BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value, EIP);
 }
diff -u -r -N bochs/cpu/ctrl_xfer32.cc bochs-instrumentation/cpu/ctrl_xfer32.cc
--- bochs/cpu/ctrl_xfer32.cc	2002-09-20 05:52:58.000000000 +0200
+++ bochs-instrumentation/cpu/ctrl_xfer32.cc	2002-09-20 18:20:23.000000000 +0200
@@ -92,7 +92,7 @@
         SP  += imm16;
       }
 
-  BX_INSTR_UCNEAR_BRANCH(BX_INSTR_IS_RET, EIP);
+  BX_INSTR_UCNEAR_BRANCH(CPU_ID, BX_INSTR_IS_RET, EIP);
 }
 
   void
@@ -137,7 +137,7 @@
       EIP = return_EIP;
       }
 
-  BX_INSTR_UCNEAR_BRANCH(BX_INSTR_IS_RET, EIP);
+  BX_INSTR_UCNEAR_BRANCH(CPU_ID, BX_INSTR_IS_RET, EIP);
 }
 
   void
@@ -173,7 +173,7 @@
       SP  += imm16;
 
 done:
-  BX_INSTR_FAR_BRANCH(BX_INSTR_IS_RET,
+  BX_INSTR_FAR_BRANCH(CPU_ID, BX_INSTR_IS_RET,
                       BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value, EIP);
 }
 
@@ -202,7 +202,7 @@
     load_seg_reg(&BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS], (Bit16u) ecs_raw);
 
 done:
-  BX_INSTR_FAR_BRANCH(BX_INSTR_IS_RET,
+  BX_INSTR_FAR_BRANCH(CPU_ID, BX_INSTR_IS_RET,
                       BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value, EIP);
 }
 
@@ -234,7 +234,7 @@
   push_32(EIP);
   EIP = new_EIP;
 
-  BX_INSTR_UCNEAR_BRANCH(BX_INSTR_IS_CALL, EIP);
+  BX_INSTR_UCNEAR_BRANCH(CPU_ID, BX_INSTR_IS_CALL, EIP);
 }
 
   void
@@ -261,7 +261,7 @@
   load_seg_reg(&BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS], cs_raw);
 
 done:
-  BX_INSTR_FAR_BRANCH(BX_INSTR_IS_CALL,
+  BX_INSTR_FAR_BRANCH(CPU_ID, BX_INSTR_IS_CALL,
                       BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value, EIP);
 }
 
@@ -304,7 +304,7 @@
 
     EIP = op1_32;
 
-  BX_INSTR_UCNEAR_BRANCH(BX_INSTR_IS_CALL, EIP);
+  BX_INSTR_UCNEAR_BRANCH(CPU_ID, BX_INSTR_IS_CALL, EIP);
 }
 
   void
@@ -339,7 +339,7 @@
     load_seg_reg(&BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS], cs_raw);
 
 done:
-  BX_INSTR_FAR_BRANCH(BX_INSTR_IS_CALL,
+  BX_INSTR_FAR_BRANCH(CPU_ID, BX_INSTR_IS_CALL,
                       BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value, EIP);
 }
 
@@ -363,7 +363,7 @@
 #endif
 
   EIP = new_EIP;
-  BX_INSTR_UCNEAR_BRANCH(BX_INSTR_IS_JMP, new_EIP);
+  BX_INSTR_UCNEAR_BRANCH(CPU_ID, BX_INSTR_IS_JMP, new_EIP);
 }
 
   void
@@ -406,12 +406,12 @@
       }
 #endif
     EIP = new_EIP;
-    BX_INSTR_CNEAR_BRANCH_TAKEN(new_EIP);
+    BX_INSTR_CNEAR_BRANCH_TAKEN(CPU_ID, new_EIP);
     revalidate_prefetch_q();
     }
 #if BX_INSTRUMENTATION
   else {
-    BX_INSTR_CNEAR_BRANCH_NOT_TAKEN();
+    BX_INSTR_CNEAR_BRANCH_NOT_TAKEN(CPU_ID);
     }
 #endif
 }
@@ -443,7 +443,7 @@
   EIP = disp32;
 
 done:
-  BX_INSTR_FAR_BRANCH(BX_INSTR_IS_JMP,
+  BX_INSTR_FAR_BRANCH(CPU_ID, BX_INSTR_IS_JMP,
                       BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value, EIP);
 }
 
@@ -479,7 +479,7 @@
 
   EIP = new_EIP;
 
-  BX_INSTR_UCNEAR_BRANCH(BX_INSTR_IS_JMP, new_EIP);
+  BX_INSTR_UCNEAR_BRANCH(CPU_ID, BX_INSTR_IS_JMP, new_EIP);
 }
 
   /* Far indirect jump */
@@ -510,7 +510,7 @@
     load_seg_reg(&BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS], cs_raw);
 
 done:
-  BX_INSTR_FAR_BRANCH(BX_INSTR_IS_JMP,
+  BX_INSTR_FAR_BRANCH(CPU_ID, BX_INSTR_IS_JMP,
                       BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value, EIP);
 }
 
@@ -553,6 +553,6 @@
     write_eflags(eflags, /* change IOPL? */ 1, /* change IF? */ 1, 0, 1);
 
 done:
-  BX_INSTR_FAR_BRANCH(BX_INSTR_IS_IRET,
+  BX_INSTR_FAR_BRANCH(CPU_ID, BX_INSTR_IS_IRET,
                       BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value, EIP);
 }
diff -u -r -N bochs/cpu/ctrl_xfer64.cc bochs-instrumentation/cpu/ctrl_xfer64.cc
--- bochs/cpu/ctrl_xfer64.cc	2002-09-20 05:52:58.000000000 +0200
+++ bochs-instrumentation/cpu/ctrl_xfer64.cc	2002-09-20 18:21:00.000000000 +0200
@@ -70,7 +70,7 @@
   RIP = return_RIP;
   RSP += 8 + imm16; /* ??? should it be 2*imm16 ? */
 
-  BX_INSTR_UCNEAR_BRANCH(BX_INSTR_IS_RET, BX_CPU_THIS_PTR rip);
+  BX_INSTR_UCNEAR_BRANCH(CPU_ID, BX_INSTR_IS_RET, BX_CPU_THIS_PTR rip);
 }
 
   void
@@ -98,7 +98,7 @@
   RIP = return_RIP;
   RSP += 8;
 
-  BX_INSTR_UCNEAR_BRANCH(BX_INSTR_IS_RET, BX_CPU_THIS_PTR rip);
+  BX_INSTR_UCNEAR_BRANCH(CPU_ID, BX_INSTR_IS_RET, BX_CPU_THIS_PTR rip);
 }
 
   void
@@ -130,7 +130,7 @@
     load_seg_reg(&BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS], (Bit16u) rcs_raw);
     RSP += imm16;
 done:
-  BX_INSTR_FAR_BRANCH(BX_INSTR_IS_RET,
+  BX_INSTR_FAR_BRANCH(CPU_ID, BX_INSTR_IS_RET,
                       BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value, BX_CPU_THIS_PTR rip);
 }
 
@@ -159,7 +159,7 @@
   load_seg_reg(&BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS], (Bit16u) rcs_raw);
 
 done:
-  BX_INSTR_FAR_BRANCH(BX_INSTR_IS_RET,
+  BX_INSTR_FAR_BRANCH(CPU_ID, BX_INSTR_IS_RET,
                       BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value, BX_CPU_THIS_PTR rip);
 }
 
@@ -184,7 +184,7 @@
   push_64(BX_CPU_THIS_PTR rip);
   RIP = new_RIP;
 
-  BX_INSTR_UCNEAR_BRANCH(BX_INSTR_IS_CALL, BX_CPU_THIS_PTR rip);
+  BX_INSTR_UCNEAR_BRANCH(CPU_ID, BX_INSTR_IS_CALL, BX_CPU_THIS_PTR rip);
 }
 
   void
@@ -211,7 +211,7 @@
   load_seg_reg(&BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS], cs_raw);
 
 done:
-  BX_INSTR_FAR_BRANCH(BX_INSTR_IS_CALL,
+  BX_INSTR_FAR_BRANCH(CPU_ID, BX_INSTR_IS_CALL,
                       BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value, BX_CPU_THIS_PTR rip);
 }
 
@@ -245,7 +245,7 @@
 
     RIP = op1_64;
 
-  BX_INSTR_UCNEAR_BRANCH(BX_INSTR_IS_CALL, BX_CPU_THIS_PTR rip);
+  BX_INSTR_UCNEAR_BRANCH(CPU_ID, BX_INSTR_IS_CALL, BX_CPU_THIS_PTR rip);
 }
 
   void
@@ -280,7 +280,7 @@
   load_seg_reg(&BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS], cs_raw);
 
 done:
-  BX_INSTR_FAR_BRANCH(BX_INSTR_IS_CALL,
+  BX_INSTR_FAR_BRANCH(CPU_ID, BX_INSTR_IS_CALL,
                       BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value, BX_CPU_THIS_PTR rip);
 }
 
@@ -293,7 +293,7 @@
   invalidate_prefetch_q();
 
   RIP += (Bit32s) i->Id();
-  BX_INSTR_UCNEAR_BRANCH(BX_INSTR_IS_JMP, new_RIP);
+  BX_INSTR_UCNEAR_BRANCH(CPU_ID, BX_INSTR_IS_JMP, new_RIP);
 }
 
   void
@@ -326,12 +326,12 @@
   if (condition) {
 
     RIP += (Bit32s) i->Id();
-    BX_INSTR_CNEAR_BRANCH_TAKEN(RIP);
+    BX_INSTR_CNEAR_BRANCH_TAKEN(CPU_ID, RIP);
     revalidate_prefetch_q();
     }
 #if BX_INSTRUMENTATION
   else {
-    BX_INSTR_CNEAR_BRANCH_NOT_TAKEN();
+    BX_INSTR_CNEAR_BRANCH_NOT_TAKEN(CPU_ID);
     }
 #endif
 }
@@ -364,7 +364,7 @@
   RIP = disp64;
 
 done:
-  BX_INSTR_FAR_BRANCH(BX_INSTR_IS_JMP,
+  BX_INSTR_FAR_BRANCH(CPU_ID, BX_INSTR_IS_JMP,
                       BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value, BX_CPU_THIS_PTR rip);
 }
 
@@ -391,7 +391,7 @@
 
   RIP = op1_64;
 
-  BX_INSTR_UCNEAR_BRANCH(BX_INSTR_IS_JMP, new_RIP);
+  BX_INSTR_UCNEAR_BRANCH(CPU_ID, BX_INSTR_IS_JMP, new_RIP);
 }
 
   /* Far indirect jump */
@@ -422,7 +422,7 @@
   load_seg_reg(&BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS], cs_raw);
 
 done:
-  BX_INSTR_FAR_BRANCH(BX_INSTR_IS_JMP,
+  BX_INSTR_FAR_BRANCH(CPU_ID, BX_INSTR_IS_JMP,
                       BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value, RIP);
 }
 
@@ -447,6 +447,6 @@
 
 
 done:
-  BX_INSTR_FAR_BRANCH(BX_INSTR_IS_IRET,
+  BX_INSTR_FAR_BRANCH(CPU_ID, BX_INSTR_IS_IRET,
                       BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value, BX_CPU_THIS_PTR rip);
 }
diff -u -r -N bochs/cpu/ctrl_xfer8.cc bochs-instrumentation/cpu/ctrl_xfer8.cc
--- bochs/cpu/ctrl_xfer8.cc	2002-09-18 07:36:47.000000000 +0200
+++ bochs-instrumentation/cpu/ctrl_xfer8.cc	2002-09-20 21:27:19.000000000 +0200
@@ -46,12 +46,12 @@
   if (i->as64L()) {
     if ( RCX == 0 ) {
       RIP += (Bit32s) i->Id();
-      BX_INSTR_CNEAR_BRANCH_TAKEN(new_RIP);
+      BX_INSTR_CNEAR_BRANCH_TAKEN(CPU_ID, RIP);
       revalidate_prefetch_q();
       }
 #if BX_INSTRUMENTATION
     else {
-      BX_INSTR_CNEAR_BRANCH_NOT_TAKEN();
+      BX_INSTR_CNEAR_BRANCH_NOT_TAKEN(CPU_ID);
       }
 #endif
     }
@@ -78,12 +78,12 @@
         }
 #endif
       EIP = new_EIP;
-      BX_INSTR_CNEAR_BRANCH_TAKEN(new_EIP);
+      BX_INSTR_CNEAR_BRANCH_TAKEN(CPU_ID, new_EIP);
       revalidate_prefetch_q();
       }
 #if BX_INSTRUMENTATION
     else {
-      BX_INSTR_CNEAR_BRANCH_NOT_TAKEN();
+      BX_INSTR_CNEAR_BRANCH_NOT_TAKEN(CPU_ID);
       }
 #endif
   }
@@ -99,12 +99,12 @@
     if ( ((--RCX)!=0) && (get_ZF()==0) ) {
 
       RIP += (Bit32s) i->Id();
-      BX_INSTR_CNEAR_BRANCH_TAKEN(RIP);
+      BX_INSTR_CNEAR_BRANCH_TAKEN(CPU_ID, RIP);
       revalidate_prefetch_q();
       }
 #if BX_INSTRUMENTATION
     else {
-      BX_INSTR_CNEAR_BRANCH_NOT_TAKEN();
+      BX_INSTR_CNEAR_BRANCH_NOT_TAKEN(CPU_ID);
       }
 #endif
     }
@@ -131,12 +131,12 @@
           }
         }
       EIP = new_EIP;
-      BX_INSTR_CNEAR_BRANCH_TAKEN(new_EIP);
+      BX_INSTR_CNEAR_BRANCH_TAKEN(CPU_ID, new_EIP);
       revalidate_prefetch_q();
       }
 #if BX_INSTRUMENTATION
     else {
-      BX_INSTR_CNEAR_BRANCH_NOT_TAKEN();
+      BX_INSTR_CNEAR_BRANCH_NOT_TAKEN(CPU_ID);
       }
 #endif
 
@@ -155,12 +155,12 @@
     if ( ((--RCX)!=0) && (get_ZF()) ) {
 
       RIP += (Bit32s) i->Id();
-      BX_INSTR_CNEAR_BRANCH_TAKEN(RIP);
+      BX_INSTR_CNEAR_BRANCH_TAKEN(CPU_ID, RIP);
       revalidate_prefetch_q();
       }
 #if BX_INSTRUMENTATION
     else {
-      BX_INSTR_CNEAR_BRANCH_NOT_TAKEN();
+      BX_INSTR_CNEAR_BRANCH_NOT_TAKEN(CPU_ID);
       }
 #endif
     }
@@ -187,12 +187,12 @@
           }
         }
       EIP = new_EIP;
-      BX_INSTR_CNEAR_BRANCH_TAKEN(new_EIP);
+      BX_INSTR_CNEAR_BRANCH_TAKEN(CPU_ID, new_EIP);
       revalidate_prefetch_q();
       }
 #if BX_INSTRUMENTATION
     else {
-      BX_INSTR_CNEAR_BRANCH_NOT_TAKEN();
+      BX_INSTR_CNEAR_BRANCH_NOT_TAKEN(CPU_ID);
       }
 #endif
 
@@ -211,12 +211,12 @@
     if ( ((--RCX)!=0) ) {
 
       RIP += (Bit32s) i->Id();
-      BX_INSTR_CNEAR_BRANCH_TAKEN(RIP);
+      BX_INSTR_CNEAR_BRANCH_TAKEN(CPU_ID, RIP);
       revalidate_prefetch_q();
       }
 #if BX_INSTRUMENTATION
     else {
-      BX_INSTR_CNEAR_BRANCH_NOT_TAKEN();
+      BX_INSTR_CNEAR_BRANCH_NOT_TAKEN(CPU_ID);
       }
 #endif
     }
@@ -243,12 +243,12 @@
           }
         }
       EIP = new_EIP;
-      BX_INSTR_CNEAR_BRANCH_TAKEN(new_EIP);
+      BX_INSTR_CNEAR_BRANCH_TAKEN(CPU_ID, new_EIP);
       revalidate_prefetch_q();
       }
 #if BX_INSTRUMENTATION
     else {
-      BX_INSTR_CNEAR_BRANCH_NOT_TAKEN();
+      BX_INSTR_CNEAR_BRANCH_NOT_TAKEN(CPU_ID);
       }
 #endif
 
diff -u -r -N bochs/cpu/exception.cc bochs-instrumentation/cpu/exception.cc
--- bochs/cpu/exception.cc	2002-09-14 19:29:47.000000000 +0200
+++ bochs-instrumentation/cpu/exception.cc	2002-09-20 18:22:26.000000000 +0200
@@ -71,7 +71,7 @@
 
 //BX_DEBUG(( "::interrupt(%u)", vector ));
 
-  BX_INSTR_INTERRUPT(vector);
+  BX_INSTR_INTERRUPT(CPU_ID, vector);
   invalidate_prefetch_q();
 
   // Discard any traps and inhibits for new context; traps will
@@ -823,7 +823,7 @@
 #endif
 
 
-  BX_INSTR_EXCEPTION(vector);
+  BX_INSTR_EXCEPTION(CPU_ID, vector);
   invalidate_prefetch_q();
 
   UNUSED(is_INT);
diff -u -r -N bochs/cpu/fetchdecode.cc bochs-instrumentation/cpu/fetchdecode.cc
--- bochs/cpu/fetchdecode.cc	2002-09-20 05:52:58.000000000 +0200
+++ bochs-instrumentation/cpu/fetchdecode.cc	2002-09-20 18:33:01.000000000 +0200
@@ -1477,6 +1477,7 @@
     if (attr & BxPrefix) {
       switch (b1) {
         case 0x66: // OpSize
+          BX_INSTR_PREFIX_OS(CPU_ID);
           os_32 = !is_32;
           instruction->setOs32B(os_32);
           if (ilen < remain) {
@@ -1486,6 +1487,7 @@
           return(0);
 
         case 0x67: // AddrSize
+          BX_INSTR_PREFIX_AS(CPU_ID);
           instruction->setAs32B(!is_32);
           if (ilen < remain) {
             ilen++;
@@ -1494,7 +1496,17 @@
           return(0);
 
         case 0xf2: // REPNE/REPNZ
+          BX_INSTR_PREFIX_REPNE(CPU_ID);
+          instruction->setRepUsed(b1 & 3);
+          if (ilen < remain) {
+            ilen++;
+            goto fetch_b1;
+            }
+          return(0);
+          break;
+
         case 0xf3: // REP/REPE/REPZ
+          BX_INSTR_PREFIX_REP(CPU_ID);
           instruction->setRepUsed(b1 & 3);
           if (ilen < remain) {
             ilen++;
@@ -1504,30 +1516,37 @@
           break;
 
         case 0x2e: // CS:
+          BX_INSTR_PREFIX_CS(CPU_ID);
           instruction->setSeg(BX_SEG_REG_CS);
           ilen++; goto fetch_b1;
           break;
         case 0x26: // ES:
+          BX_INSTR_PREFIX_ES(CPU_ID);
           instruction->setSeg(BX_SEG_REG_ES);
           ilen++; goto fetch_b1;
           break;
         case 0x36: // SS:
+          BX_INSTR_PREFIX_SS(CPU_ID);
           instruction->setSeg(BX_SEG_REG_SS);
           ilen++; goto fetch_b1;
           break;
         case 0x3e: // DS:
+          BX_INSTR_PREFIX_DS(CPU_ID);
           instruction->setSeg(BX_SEG_REG_DS);
           ilen++; goto fetch_b1;
           break;
         case 0x64: // FS:
+          BX_INSTR_PREFIX_FS(CPU_ID);
           instruction->setSeg(BX_SEG_REG_FS);
           ilen++; goto fetch_b1;
           break;
         case 0x65: // GS:
+          BX_INSTR_PREFIX_GS(CPU_ID);
           instruction->setSeg(BX_SEG_REG_GS);
           ilen++; goto fetch_b1;
           break;
         case 0xf0: // LOCK:
+          BX_INSTR_PREFIX_LOCK(CPU_ID);
           ilen++; goto fetch_b1;
           break;
 
diff -u -r -N bochs/cpu/fetchdecode64.cc bochs-instrumentation/cpu/fetchdecode64.cc
--- bochs/cpu/fetchdecode64.cc	2002-09-20 05:52:58.000000000 +0200
+++ bochs-instrumentation/cpu/fetchdecode64.cc	2002-09-20 18:36:17.000000000 +0200
@@ -2050,6 +2050,7 @@
     if (attr & BxPrefix) {
       switch (b1) {
         case 0x66: // OpSize
+          BX_INSTR_PREFIX_OS(CPU_ID);
           if (!instruction->os64L()) {
             instruction->setOs32B(0);
             offset = 0;
@@ -2061,6 +2062,7 @@
           return(0);
 
         case 0x67: // AddrSize
+          BX_INSTR_PREFIX_AS(CPU_ID);
           instruction->setAs64B(0);
           if (ilen < remain) {
             ilen++;
@@ -2085,6 +2087,7 @@
         case 0x4E:
         case 0x4F:
 
+          BX_INSTR_PREFIX_EXTEND8B(CPU_ID);
           instruction->assertExtend8bit();
           //BX_DEBUG (("REX byte = %02x",b1));
           if (b1 & 0x8) {
@@ -2113,7 +2116,17 @@
           return(0);
 
         case 0xf2: // REPNE/REPNZ
+          BX_INSTR_PREFIX_REPNE(CPU_ID);
+          instruction->setRepUsed(b1 & 3);
+          if (ilen < remain) {
+            ilen++;
+            goto fetch_b1;
+            }
+          return(0);
+          break;
+
         case 0xf3: // REP/REPE/REPZ
+          BX_INSTR_PREFIX_REP(CPU_ID);
           instruction->setRepUsed(b1 & 3);
           if (ilen < remain) {
             ilen++;
@@ -2123,30 +2136,37 @@
           break;
 
         case 0x2e: // CS:
+          BX_INSTR_PREFIX_CS(CPU_ID);
           instruction->setSeg(BX_SEG_REG_CS);
           ilen++; goto fetch_b1;
           break;
         case 0x26: // ES:
+          BX_INSTR_PREFIX_ES(CPU_ID);
           instruction->setSeg(BX_SEG_REG_ES);
           ilen++; goto fetch_b1;
           break;
         case 0x36: // SS:
+          BX_INSTR_PREFIX_SS(CPU_ID);
           instruction->setSeg(BX_SEG_REG_SS);
           ilen++; goto fetch_b1;
           break;
         case 0x3e: // DS:
+          BX_INSTR_PREFIX_DS(CPU_ID);
           instruction->setSeg(BX_SEG_REG_DS);
           ilen++; goto fetch_b1;
           break;
         case 0x64: // FS:
+          BX_INSTR_PREFIX_FS(CPU_ID);
           instruction->setSeg(BX_SEG_REG_FS);
           ilen++; goto fetch_b1;
           break;
         case 0x65: // GS:
+          BX_INSTR_PREFIX_GS(CPU_ID);
           instruction->setSeg(BX_SEG_REG_GS);
           ilen++; goto fetch_b1;
           break;
         case 0xf0: // LOCK:
+          BX_INSTR_PREFIX_LOCK(CPU_ID);
           ilen++; goto fetch_b1;
           break;
 
diff -u -r -N bochs/cpu/init.cc bochs-instrumentation/cpu/init.cc
--- bochs/cpu/init.cc	2002-09-19 21:17:20.000000000 +0200
+++ bochs-instrumentation/cpu/init.cc	2002-09-20 18:23:15.000000000 +0200
@@ -325,7 +325,7 @@
   mem = addrspace;
   sprintf (name, "CPU %p", this);
 
-  BX_INSTR_INIT();
+  BX_INSTR_INIT(CPU_ID);
 
 #if BX_WITH_WX
   // Register some of the CPUs variables as shadow parameters so that
@@ -463,7 +463,7 @@
 
 BX_CPU_C::~BX_CPU_C(void)
 {
-  BX_INSTR_SHUTDOWN();
+  BX_INSTR_SHUTDOWN(CPU_ID);
   BX_DEBUG(( "Exit."));
 }
 
@@ -870,6 +870,8 @@
 #else
   BX_CPU_THIS_PTR async_event = 0;
 #endif
+
+  BX_INSTR_RESET(CPU_ID);
 }
 
 
diff -u -r -N bochs/cpu/paging.cc bochs-instrumentation/cpu/paging.cc
--- bochs/cpu/paging.cc	2002-09-20 05:52:58.000000000 +0200
+++ bochs-instrumentation/cpu/paging.cc	2002-09-20 18:37:52.000000000 +0200
@@ -546,7 +546,7 @@
   InstrTLB_Increment(tlbEntryInvlpg);
 
 #endif // BX_USE_TLB
-  BX_INSTR_TLB_CNTRL(BX_INSTR_INVLPG, 0);
+  BX_INSTR_TLB_CNTRL(CPU_ID, BX_INSTR_INVLPG, 0);
 
 #else
   // not supported on < 486
@@ -1090,12 +1090,12 @@
       BX_CPU_THIS_PTR address_xlation.pages     = 1;
 
       if (rw == BX_READ) {
-        BX_INSTR_LIN_READ(laddr, BX_CPU_THIS_PTR address_xlation.paddress1, length);
+        BX_INSTR_LIN_READ(CPU_ID, laddr, BX_CPU_THIS_PTR address_xlation.paddress1, length);
         BX_CPU_THIS_PTR mem->readPhysicalPage(this,
             BX_CPU_THIS_PTR address_xlation.paddress1, length, data);
         }
       else {
-        BX_INSTR_LIN_WRITE(laddr, BX_CPU_THIS_PTR address_xlation.paddress1, length);
+        BX_INSTR_LIN_WRITE(CPU_ID, laddr, BX_CPU_THIS_PTR address_xlation.paddress1, length);
         BX_CPU_THIS_PTR mem->writePhysicalPage(this,
             BX_CPU_THIS_PTR address_xlation.paddress1, length, data);
         }
@@ -1115,12 +1115,12 @@
 
 #ifdef BX_LITTLE_ENDIAN
       if (rw == BX_READ) {
-        BX_INSTR_LIN_READ(laddr,
+        BX_INSTR_LIN_READ(CPU_ID, laddr,
                           BX_CPU_THIS_PTR address_xlation.paddress1,
                           BX_CPU_THIS_PTR address_xlation.len1);
         BX_CPU_THIS_PTR mem->readPhysicalPage(this, BX_CPU_THIS_PTR address_xlation.paddress1,
                              BX_CPU_THIS_PTR address_xlation.len1, data);
-        BX_INSTR_LIN_READ(laddr + BX_CPU_THIS_PTR address_xlation.len1,
+        BX_INSTR_LIN_READ(CPU_ID, laddr + BX_CPU_THIS_PTR address_xlation.len1,
                           BX_CPU_THIS_PTR address_xlation.paddress2,
                           BX_CPU_THIS_PTR address_xlation.len2);
         BX_CPU_THIS_PTR mem->readPhysicalPage(this, BX_CPU_THIS_PTR address_xlation.paddress2,
@@ -1128,12 +1128,12 @@
                              ((Bit8u*)data) + BX_CPU_THIS_PTR address_xlation.len1);
         }
       else {
-        BX_INSTR_LIN_WRITE(laddr,
+        BX_INSTR_LIN_WRITE(CPU_ID, laddr,
                            BX_CPU_THIS_PTR address_xlation.paddress1,
                            BX_CPU_THIS_PTR address_xlation.len1);
         BX_CPU_THIS_PTR mem->writePhysicalPage(this, BX_CPU_THIS_PTR address_xlation.paddress1,
                               BX_CPU_THIS_PTR address_xlation.len1, data);
-        BX_INSTR_LIN_WRITE(laddr + BX_CPU_THIS_PTR address_xlation.len1,
+        BX_INSTR_LIN_WRITE(CPU_ID, laddr + BX_CPU_THIS_PTR address_xlation.len1,
                           BX_CPU_THIS_PTR address_xlation.paddress2,
                           BX_CPU_THIS_PTR address_xlation.len2);
         BX_CPU_THIS_PTR mem->writePhysicalPage(this, BX_CPU_THIS_PTR address_xlation.paddress2,
@@ -1143,26 +1143,26 @@
 
 #else // BX_BIG_ENDIAN
       if (rw == BX_READ) {
-        BX_INSTR_LIN_READ(laddr,
+        BX_INSTR_LIN_READ(CPU_ID, laddr,
                           BX_CPU_THIS_PTR address_xlation.paddress1,
                           BX_CPU_THIS_PTR address_xlation.len1);
         BX_CPU_THIS_PTR mem->readPhysicalPage(this, BX_CPU_THIS_PTR address_xlation.paddress1,
                              BX_CPU_THIS_PTR address_xlation.len1,
                              ((Bit8u*)data) + (length - BX_CPU_THIS_PTR address_xlation.len1));
-        BX_INSTR_LIN_READ(laddr + BX_CPU_THIS_PTR address_xlation.len1,
+        BX_INSTR_LIN_READ(CPU_ID, laddr + BX_CPU_THIS_PTR address_xlation.len1,
                           BX_CPU_THIS_PTR address_xlation.paddress2,
                           BX_CPU_THIS_PTR address_xlation.len2);
         BX_CPU_THIS_PTR mem->readPhysicalPage(this, BX_CPU_THIS_PTR address_xlation.paddress2,
                              BX_CPU_THIS_PTR address_xlation.len2, data);
         }
       else {
-        BX_INSTR_LIN_WRITE(laddr,
+        BX_INSTR_LIN_WRITE(CPU_ID, laddr,
                            BX_CPU_THIS_PTR address_xlation.paddress1,
                            BX_CPU_THIS_PTR address_xlation.len1);
         BX_CPU_THIS_PTR mem->writePhysicalPage(this, BX_CPU_THIS_PTR address_xlation.paddress1,
                               BX_CPU_THIS_PTR address_xlation.len1,
                               ((Bit8u*)data) + (length - BX_CPU_THIS_PTR address_xlation.len1));
-        BX_INSTR_LIN_WRITE(laddr + BX_CPU_THIS_PTR address_xlation.len1,
+        BX_INSTR_LIN_WRITE(CPU_ID, laddr + BX_CPU_THIS_PTR address_xlation.len1,
                           BX_CPU_THIS_PTR address_xlation.paddress2,
                           BX_CPU_THIS_PTR address_xlation.len2);
         BX_CPU_THIS_PTR mem->writePhysicalPage(this, BX_CPU_THIS_PTR address_xlation.paddress2,
@@ -1185,7 +1185,7 @@
         Bit32u lpf, tlbIndex;
 #endif
 
-        BX_INSTR_LIN_READ(laddr, laddr, length);
+        BX_INSTR_LIN_READ(CPU_ID, laddr, laddr, length);
 #if BX_SupportGuest2HostTLB
         tlbIndex = BX_TLB_INDEX_OF(laddr);
         lpf = laddr & 0xfffff000;
@@ -1227,7 +1227,7 @@
         Bit32u lpf, tlbIndex;
 #endif
 
-        BX_INSTR_LIN_WRITE(laddr, laddr, length);
+        BX_INSTR_LIN_WRITE(CPU_ID, laddr, laddr, length);
 #if BX_SupportGuest2HostTLB
         tlbIndex = BX_TLB_INDEX_OF(laddr);
         lpf = laddr & 0xfffff000;
@@ -1267,13 +1267,13 @@
 
 #ifdef BX_LITTLE_ENDIAN
       if (rw == BX_READ) {
-        BX_INSTR_LIN_READ(laddr,
+        BX_INSTR_LIN_READ(CPU_ID, laddr,
                           BX_CPU_THIS_PTR address_xlation.paddress1,
                           BX_CPU_THIS_PTR address_xlation.len1);
         BX_CPU_THIS_PTR mem->readPhysicalPage(this,
             BX_CPU_THIS_PTR address_xlation.paddress1,
             BX_CPU_THIS_PTR address_xlation.len1, data);
-        BX_INSTR_LIN_READ(laddr + BX_CPU_THIS_PTR address_xlation.len1,
+        BX_INSTR_LIN_READ(CPU_ID, laddr + BX_CPU_THIS_PTR address_xlation.len1,
                           BX_CPU_THIS_PTR address_xlation.paddress2,
                           BX_CPU_THIS_PTR address_xlation.len2);
         BX_CPU_THIS_PTR mem->readPhysicalPage(this,
@@ -1282,13 +1282,13 @@
             ((Bit8u*)data) + BX_CPU_THIS_PTR address_xlation.len1);
         }
       else {
-        BX_INSTR_LIN_WRITE(laddr,
+        BX_INSTR_LIN_WRITE(CPU_ID, laddr,
                            BX_CPU_THIS_PTR address_xlation.paddress1,
                            BX_CPU_THIS_PTR address_xlation.len1);
         BX_CPU_THIS_PTR mem->writePhysicalPage(this,
             BX_CPU_THIS_PTR address_xlation.paddress1,
             BX_CPU_THIS_PTR address_xlation.len1, data);
-        BX_INSTR_LIN_WRITE(laddr + BX_CPU_THIS_PTR address_xlation.len1,
+        BX_INSTR_LIN_WRITE(CPU_ID, laddr + BX_CPU_THIS_PTR address_xlation.len1,
             BX_CPU_THIS_PTR address_xlation.paddress2,
             BX_CPU_THIS_PTR address_xlation.len2);
         BX_CPU_THIS_PTR mem->writePhysicalPage(this,
@@ -1299,14 +1299,14 @@
 
 #else // BX_BIG_ENDIAN
       if (rw == BX_READ) {
-        BX_INSTR_LIN_READ(laddr,
+        BX_INSTR_LIN_READ(CPU_ID, laddr,
                           BX_CPU_THIS_PTR address_xlation.paddress1,
                           BX_CPU_THIS_PTR address_xlation.len1);
         BX_CPU_THIS_PTR mem->readPhysicalPage(this,
             BX_CPU_THIS_PTR address_xlation.paddress1,
             BX_CPU_THIS_PTR address_xlation.len1,
             ((Bit8u*)data) + (length - BX_CPU_THIS_PTR address_xlation.len1));
-        BX_INSTR_LIN_READ(laddr + BX_CPU_THIS_PTR address_xlation.len1,
+        BX_INSTR_LIN_READ(CPU_ID, laddr + BX_CPU_THIS_PTR address_xlation.len1,
                           BX_CPU_THIS_PTR address_xlation.paddress2,
                           BX_CPU_THIS_PTR address_xlation.len2);
         BX_CPU_THIS_PTR mem->readPhysicalPage(this,
@@ -1314,14 +1314,14 @@
             BX_CPU_THIS_PTR address_xlation.len2, data);
         }
       else {
-        BX_INSTR_LIN_WRITE(laddr,
+        BX_INSTR_LIN_WRITE(CPU_ID, laddr,
                            BX_CPU_THIS_PTR address_xlation.paddress1,
                            BX_CPU_THIS_PTR address_xlation.len1);
         BX_CPU_THIS_PTR mem->writePhysicalPage(this,
             BX_CPU_THIS_PTR address_xlation.paddress1,
             BX_CPU_THIS_PTR address_xlation.len1,
             ((Bit8u*)data) + (length - BX_CPU_THIS_PTR address_xlation.len1));
-        BX_INSTR_LIN_WRITE(laddr + BX_CPU_THIS_PTR address_xlation.len1,
+        BX_INSTR_LIN_WRITE(CPU_ID, laddr + BX_CPU_THIS_PTR address_xlation.len1,
                           BX_CPU_THIS_PTR address_xlation.paddress2,
                           BX_CPU_THIS_PTR address_xlation.len2);
         BX_CPU_THIS_PTR mem->writePhysicalPage(this,
diff -u -r -N bochs/cpu/proc_ctrl.cc bochs-instrumentation/cpu/proc_ctrl.cc
--- bochs/cpu/proc_ctrl.cc	2002-09-20 05:52:58.000000000 +0200
+++ bochs-instrumentation/cpu/proc_ctrl.cc	2002-09-20 18:24:37.000000000 +0200
@@ -133,7 +133,7 @@
       exception(BX_GP_EXCEPTION, 0, 0);
       }
     }
-  BX_INSTR_CACHE_CNTRL(BX_INSTR_INVD);
+  BX_INSTR_CACHE_CNTRL(CPU_ID, BX_INSTR_INVD);
 #else
   UndefinedOpcode(i);
 #endif
@@ -153,7 +153,7 @@
       exception(BX_GP_EXCEPTION, 0, 0);
       }
     }
-  BX_INSTR_CACHE_CNTRL(BX_INSTR_WBINVD);
+  BX_INSTR_CACHE_CNTRL(CPU_ID, BX_INSTR_WBINVD);
 #else
   UndefinedOpcode(i);
 #endif
@@ -712,7 +712,7 @@
         BX_INFO(("MOV_CdRd:CR3 = %08x", (unsigned) val_32));
       // Reserved bits take on value of MOV instruction
       CR3_change(val_32);
-      BX_INSTR_TLB_CNTRL(BX_INSTR_MOV_CR3, val_32);
+      BX_INSTR_TLB_CNTRL(CPU_ID, BX_INSTR_MOV_CR3, val_32);
       // Reload of CR3 always serializes.
       // invalidate_prefetch_q(); // Already done.
       break;
@@ -865,7 +865,7 @@
         BX_INFO(("MOV_CqRq:CR3 = %08x", (unsigned) val_64));
       // Reserved bits take on value of MOV instruction
       CR3_change(val_64);
-      BX_INSTR_TLB_CNTRL(BX_INSTR_MOV_CR3, val_64);
+      BX_INSTR_TLB_CNTRL(CPU_ID, BX_INSTR_MOV_CR3, val_64);
       break;
     case 4: // CR4
 #if BX_CPU_LEVEL == 3
diff -u -r -N bochs/cpu/soft_int.cc bochs-instrumentation/cpu/soft_int.cc
--- bochs/cpu/soft_int.cc	2002-09-20 05:52:58.000000000 +0200
+++ bochs-instrumentation/cpu/soft_int.cc	2002-09-20 18:27:54.000000000 +0200
@@ -97,7 +97,7 @@
 #endif
 
   interrupt(1, 1, 0, 0);
-  BX_INSTR_FAR_BRANCH(BX_INSTR_IS_INT,
+  BX_INSTR_FAR_BRANCH(CPU_ID, BX_INSTR_IS_INT,
                       BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value,
                       EIP);
 }
@@ -113,7 +113,7 @@
 
 //BX_PANIC(("INT3: bailing"));
   interrupt(3, 1, 0, 0);
-  BX_INSTR_FAR_BRANCH(BX_INSTR_IS_INT,
+  BX_INSTR_FAR_BRANCH(CPU_ID, BX_INSTR_IS_INT,
                       BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value,
                       EIP);
 }
@@ -142,7 +142,7 @@
 #endif
 
   interrupt(imm8, 1, 0, 0);
-  BX_INSTR_FAR_BRANCH(BX_INSTR_IS_INT,
+  BX_INSTR_FAR_BRANCH(CPU_ID, BX_INSTR_IS_INT,
                       BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value,
                       EIP);
 }
@@ -161,7 +161,7 @@
 
   if (get_OF()) {
     interrupt(4, 1, 0, 0);
-    BX_INSTR_FAR_BRANCH(BX_INSTR_IS_INT,
+    BX_INSTR_FAR_BRANCH(CPU_ID, BX_INSTR_IS_INT,
                         BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value,
                         EIP);
     }
diff -u -r -N bochs/cpu/tasking.cc bochs-instrumentation/cpu/tasking.cc
--- bochs/cpu/tasking.cc	2002-09-13 18:23:02.000000000 +0200
+++ bochs-instrumentation/cpu/tasking.cc	2002-09-20 18:28:00.000000000 +0200
@@ -482,7 +482,7 @@
   if ( (tss_descriptor->type >= 9) && BX_CPU_THIS_PTR cr0.pg) {
     CR3_change(newCR3); // Tell paging unit about new cr3 value
     BX_DEBUG (("task_switch changing CR3 to 0x%08x", newCR3));
-    BX_INSTR_TLB_CNTRL(BX_INSTR_TASKSWITCH, newCR3);
+    BX_INSTR_TLB_CNTRL(CPU_ID, BX_INSTR_TASKSWITCH, newCR3);
     }
 
   BX_CPU_THIS_PTR prev_eip = EIP = newEIP;
diff -u -r -N bochs/cpu64/CVS/Entries bochs-instrumentation/cpu64/CVS/Entries
--- bochs/cpu64/CVS/Entries	2002-09-20 14:08:16.000000000 +0200
+++ bochs-instrumentation/cpu64/CVS/Entries	1970-01-01 02:00:00.000000000 +0200
@@ -1 +0,0 @@
-D
diff -u -r -N bochs/cpu64/CVS/Repository bochs-instrumentation/cpu64/CVS/Repository
--- bochs/cpu64/CVS/Repository	2002-09-20 14:08:16.000000000 +0200
+++ bochs-instrumentation/cpu64/CVS/Repository	1970-01-01 02:00:00.000000000 +0200
@@ -1 +0,0 @@
-bochs/cpu64
diff -u -r -N bochs/cpu64/CVS/Root bochs-instrumentation/cpu64/CVS/Root
--- bochs/cpu64/CVS/Root	2002-09-20 14:08:16.000000000 +0200
+++ bochs-instrumentation/cpu64/CVS/Root	1970-01-01 02:00:00.000000000 +0200
@@ -1 +0,0 @@
-:ext:sshwarts@cvs.bochs.sourceforge.net:/cvsroot/bochs
diff -u -r -N bochs/instrument/stubs/instrument.cc bochs-instrumentation/instrument/stubs/instrument.cc
--- bochs/instrument/stubs/instrument.cc	2001-10-03 15:10:38.000000000 +0200
+++ bochs-instrumentation/instrument/stubs/instrument.cc	2002-09-20 21:37:54.000000000 +0200
@@ -28,361 +28,56 @@
 
 #include "bochs.h"
 
+void bx_instr_init(unsigned cpu) {}
+void bx_instr_shutdown(unsigned cpu) {}
+void bx_instr_reset(unsigned cpu) {}
+void bx_instr_new_instruction(unsigned cpu) {}
+
+void bx_instr_debug_promt() {}
+void bx_instr_start() {}
+void bx_instr_stop() {}
+void bx_instr_print() {}
+
+void bx_instr_cnear_branch_taken(unsigned cpu, bx_address new_eip) {}
+void bx_instr_cnear_branch_not_taken(unsigned cpu) {}
+void bx_instr_ucnear_branch(unsigned cpu, unsigned what, bx_address new_eip) {}
+void bx_instr_far_branch(unsigned cpu, unsigned what, Bit16u new_cs, bx_address new_eip) {}
+
+void bx_instr_opcode(unsigned cpu, Bit8u *opcode, unsigned len, Boolean is32) {}
+void bx_instr_fetch_decode_completed(unsigned cpu, bxInstruction *i) {}
+
+void bx_instr_prefix_as(unsigned cpu) {}
+void bx_instr_prefix_os(unsigned cpu) {}
+void bx_instr_prefix_rep(unsigned cpu) {}
+void bx_instr_prefix_repne(unsigned cpu) {}
+void bx_instr_prefix_lock(unsigned cpu) {}
+void bx_instr_prefix_cs(unsigned cpu) {}
+void bx_instr_prefix_ss(unsigned cpu) {}
+void bx_instr_prefix_ds(unsigned cpu) {}
+void bx_instr_prefix_es(unsigned cpu) {}
+void bx_instr_prefix_fs(unsigned cpu) {}
+void bx_instr_prefix_gs(unsigned cpu) {}
+void bx_instr_prefix_extend8b(unsigned cpu) {}
+
+void bx_instr_interrupt(unsigned cpu, unsigned vector) {}
+void bx_instr_exception(unsigned cpu, unsigned vector) {}
+void bx_instr_hwinterrupt(unsigned cpu, unsigned vector, Bit16u cs, bx_address eip) {}
+
+void bx_instr_tlb_cntrl(unsigned cpu, unsigned what, Bit32u newval) {}
+void bx_instr_cache_cntrl(unsigned cpu, unsigned what) {}
+
+void bx_instr_repeat_iteration(unsigned cpu) {}
+
+void bx_instr_inp(Bit16u addr, unsigned len) {}
+void bx_instr_outp(Bit16u addr, unsigned len) {}
+void bx_instr_inp2(Bit16u addr, unsigned len, unsigned val) {}
+void bx_instr_outp2(Bit16u addr, unsigned len, unsigned val) {}
 
-#if 0
-// possible types passed to BX_INSTR_TLB_CNTRL()
-#define BX_INSTR_MOV_CR3     10
-#define BX_INSTR_INVLPG      11
-#define BX_INSTR_TASKSWITCH  12
-
-// possible types passed to BX_INSTR_CACHE_CNTRL()
-#define BX_INSTR_INVD      20
-#define BX_INSTR_WBINVD    21
-#endif
-
-
-// called from the CPU core
-  void
-bx_instr_cnear_branch_taken(Bit32u new_eip)
-{
-  UNUSED(new_eip);
-}
-
-  void
-bx_instr_cnear_branch_not_taken(void)
-{
-}
-
-  void
-bx_instr_ucnear_branch(unsigned what, Bit32u new_eip)
-{
-  UNUSED(what);
-  UNUSED(new_eip);
-}
-
-  void
-bx_instr_far_branch(unsigned what, Bit32u new_cs, Bit32u new_eip)
-{
-  UNUSED(what);
-  UNUSED(new_eip);
-  UNUSED(new_cs);
-}
-
-  void
-bx_instr_opcode_byte1(Bit8u opcode)
-{
-  UNUSED(opcode);
-}
-
-  void
-bx_instr_opcode_byte2(Bit8u opcode)
-{
-  UNUSED(opcode);
-}
-
-  void
-bx_instr_opcode_g1ebib(unsigned nnn)
-{
-  UNUSED(nnn);
-}
-
-  void
-bx_instr_opcode_g1eviv(unsigned nnn)
-{
-  UNUSED(nnn);
-}
-
-  void
-bx_instr_opcode_g1evib(unsigned nnn)
-{
-  UNUSED(nnn);
-}
-
-  void
-bx_instr_opcode_g2ebib(unsigned nnn)
-{
-  UNUSED(nnn);
-}
-
-  void
-bx_instr_opcode_g2evib(unsigned nnn)
-{
-  UNUSED(nnn);
-}
-
-  void
-bx_instr_opcode_g2eb1(unsigned nnn)
-{
-  UNUSED(nnn);
-}
-
-  void
-bx_instr_opcode_g2ev1(unsigned nnn)
-{
-  UNUSED(nnn);
-}
-
-  void
-bx_instr_opcode_g2ebcl(unsigned nnn)
-{
-  UNUSED(nnn);
-}
-
-  void
-bx_instr_opcode_g2evcl(unsigned nnn)
-{
-  UNUSED(nnn);
-}
-
-  void
-bx_instr_opcode_g3eb(unsigned nnn)
-{
-  UNUSED(nnn);
-}
-
-  void
-bx_instr_opcode_g3ev(unsigned nnn)
-{
-  UNUSED(nnn);
-}
-
-  void
-bx_instr_opcode_g4(unsigned nnn)
-{
-  UNUSED(nnn);
-}
-
-  void
-bx_instr_opcode_g5(unsigned nnn)
-{
-  UNUSED(nnn);
-}
-
-  void
-bx_instr_opcode_g6(unsigned nnn)
-{
-  UNUSED(nnn);
-}
-
-  void
-bx_instr_opcode_g7(unsigned nnn)
-{
-  UNUSED(nnn);
-}
-
-  void
-bx_instr_opcode_g8evib(unsigned nnn)
-{
-  UNUSED(nnn);
-}
-
-  void
-bx_instr_mem_code(Bit32u linear, unsigned size)
-{
-  UNUSED(linear);
-  UNUSED(size);
-}
-
-  void
-bx_instr_mem_data(Bit32u linear, unsigned size, unsigned rw)
-{
-  UNUSED(linear);
-  UNUSED(size);
-  UNUSED(rw);
-}
-
-  void
-bx_instr_opcode_begin(Bit32u linear)
-{
-  UNUSED(linear);
-}
-
-  void
-bx_instr_opcode_end(Bit32u linear)
-{
-  UNUSED(linear);
-}
-
-  void
-bx_instr_exception(unsigned vector)
-{
-  UNUSED(vector);
-}
-
-  void
-bx_instr_tlb_cntrl(unsigned what, Bit32u newval)
-{
-  UNUSED(what);
-  UNUSED(newval);
-}
-
-  void
-bx_instr_cache_cntrl(unsigned what)
-{
-  UNUSED(what);
-}
-
-  void
-bx_instr_hwinterrupt(unsigned vector, Bit32u cs, Bit32u eip)
-{
-  UNUSED(vector);
-  UNUSED(cs);
-  UNUSED(eip);
-}
-
-  void
-bx_instr_init(void)
-{
-}
-
-  void
-bx_instr_shutdown(void)
-{
-}
-
-  void
-bx_instr_opcode_repeating(void)
-{
-}
-
-
-// called from the debug prompt
-  void
-bx_instr_start(void)
-{
-}
-
-  void
-bx_instr_stop(void)
-{
-}
-
-  void
-bx_instr_reset(void)
-{
-}
-
-  void
-bx_instr_print(void)
-{
-}
-
-  void
-bx_instr_prefix_as(void)
-{
-}
-  void
-bx_instr_prefix_os(void)
-{
-}
-  void
-bx_instr_prefix_rep(void)
-{
-}
-  void
-bx_instr_prefix_repne(void)
-{
-}
-  void
-bx_instr_prefix_lock(void)
-{
-}
-  void
-bx_instr_prefix_cs(void)
-{
-}
-  void
-bx_instr_prefix_ss(void)
-{
-}
-  void
-bx_instr_prefix_ds(void)
-{
-}
-  void
-bx_instr_prefix_es(void)
-{
-}
-  void
-bx_instr_prefix_fs(void)
-{
-}
-  void
-bx_instr_prefix_gs(void)
-{
-}
-
-  void
-bx_instr_modrm32(unsigned modrm)
-{
-  UNUSED(modrm);
-}
-
-  void
-bx_instr_sib32(unsigned sib)
-{
-  UNUSED(sib);
-}
-
-  void
-bx_instr_modrm16(unsigned modrm)
-{
-  UNUSED(modrm);
-}
-
-  void
-bx_instr_iret(void)
-{
-}
-
-  void
-bx_instr_debug_prompt(void)
-{
-}
-
-  void
-bx_instr_fetch_byte(Bit8u val8)
-{
-}
-  void
-bx_instr_fetch_word(Bit16u val16)
-{
-}
-  void
-bx_instr_fetch_dword(Bit32u val32)
-{
-}
-  void
-bx_instr_phy_write(Bit32u addr, unsigned len)
-{
-}
-  void
-bx_instr_phy_read(Bit32u addr, unsigned len)
-{
-}
-  void
-bx_instr_interrupt(unsigned vector)
-{
-}
-  void
-bx_instr_inp(Bit16u addr, unsigned len)
-{
-}
-  void
-bx_instr_outp(Bit16u addr, unsigned len)
-{
-}
-  void
-bx_instr_inp2(Bit16u addr, unsigned len, unsigned val)
-{
-}
-  void
-bx_instr_outp2(Bit16u addr, unsigned len, unsigned val)
-{
-}
-void bx_instr_lin_read(Bit32u lin, Bit32u phy, unsigned len)
-{
-}
-void bx_instr_lin_write(Bit32u lin, Bit32u phy, unsigned len)
-{
-}
+void bx_instr_mem_code(unsigned cpu, bx_address linear, unsigned size) {}
+void bx_instr_mem_data(unsigned cpu, bx_address linear, unsigned size, unsigned rw) {}
+
+void bx_instr_lin_read(unsigned cpu, bx_address lin, bx_address phy, unsigned len) {}
+void bx_instr_lin_write(unsigned cpu, bx_address lin, bx_address phy, unsigned len) {}
+
+void bx_instr_phy_write(bx_address addr, unsigned len) {}
+void bx_instr_phy_read(bx_address addr, unsigned len) {}
diff -u -r -N bochs/instrument/stubs/instrument.h bochs-instrumentation/instrument/stubs/instrument.h
--- bochs/instrument/stubs/instrument.h	2001-10-03 15:10:38.000000000 +0200
+++ bochs-instrumentation/instrument/stubs/instrument.h	2002-09-20 21:39:21.000000000 +0200
@@ -25,19 +25,19 @@
 //  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 
 
-
 // possible types passed to BX_INSTR_TLB_CNTRL()
-#define BX_INSTR_MOV_CR3     10
-#define BX_INSTR_INVLPG      11
-#define BX_INSTR_TASKSWITCH  12
+#define BX_INSTR_MOV_CR3      10
+#define BX_INSTR_INVLPG       11
+#define BX_INSTR_TASKSWITCH   12
 
 // possible types passed to BX_INSTR_CACHE_CNTRL()
-#define BX_INSTR_INVD      20
-#define BX_INSTR_WBINVD    21
-
-
-
-#if BX_INSTRUMENTATION
+#define BX_INSTR_INVD         20
+#define BX_INSTR_WBINVD       21
+#define BX_INSTR_SFENCE       22
+#define BX_INSTR_PREFETCH_T0  23
+#define BX_INSTR_PREFETCH_T1  24
+#define BX_INSTR_PREFETCH_T2  25
+#define BX_INSTR_PREFETCH_NTA 26
 
 #define BX_INSTR_IS_CALL  10
 #define BX_INSTR_IS_RET   11
@@ -46,224 +46,195 @@
 #define BX_INSTR_IS_INT   14
 
 
+
+#if BX_INSTRUMENTATION
+
 // called from the CPU core
-void bx_instr_cnear_branch_taken(Bit32u new_eip);
-void bx_instr_cnear_branch_not_taken(void);
-void bx_instr_ucnear_branch(unsigned what, Bit32u new_eip);
-void bx_instr_far_branch(unsigned what, Bit32u new_cs, Bit32u new_eip);
-void bx_instr_opcode_byte1(Bit8u);
-void bx_instr_opcode_byte2(Bit8u);
-void bx_instr_opcode_g1ebib(unsigned nnn);
-void bx_instr_opcode_g1eviv(unsigned nnn);
-void bx_instr_opcode_g1evib(unsigned nnn);
-void bx_instr_opcode_g2ebib(unsigned nnn);
-void bx_instr_opcode_g2evib(unsigned nnn);
-void bx_instr_opcode_g2eb1(unsigned nnn);
-void bx_instr_opcode_g2ev1(unsigned nnn);
-void bx_instr_opcode_g2ebcl(unsigned nnn);
-void bx_instr_opcode_g2evcl(unsigned nnn);
-void bx_instr_opcode_g3eb(unsigned nnn);
-void bx_instr_opcode_g3ev(unsigned nnn);
-void bx_instr_opcode_g4(unsigned nnn);
-void bx_instr_opcode_g5(unsigned nnn);
-void bx_instr_opcode_g6(unsigned nnn);
-void bx_instr_opcode_g7(unsigned nnn);
-void bx_instr_opcode_g8evib(unsigned nnn);
-void bx_instr_mem_code(Bit32u linear, unsigned size);
-void bx_instr_mem_data(Bit32u linear, unsigned size, unsigned rw);
-void bx_instr_opcode_begin(Bit32u linear);
-void bx_instr_opcode_end(Bit32u linear);
-void bx_instr_fetch_byte(Bit8u val8);
-void bx_instr_fetch_word(Bit16u val16);
-void bx_instr_fetch_dword(Bit32u val32);
-void bx_instr_phy_write(Bit32u addr, unsigned len);
-void bx_instr_phy_read(Bit32u addr, unsigned len);
-void bx_instr_interrupt(unsigned vector);
-void bx_instr_exception(unsigned vector);
+
+void bx_instr_init(unsigned cpu);
+void bx_instr_shutdown(unsigned cpu);
+void bx_instr_reset(unsigned cpu);
+void bx_instr_new_instruction(unsigned cpu);
+
+void bx_instr_debug_promt();
+void bx_instr_start();
+void bx_instr_stop();
+void bx_instr_print();
+
+void bx_instr_cnear_branch_taken(unsigned cpu, bx_address new_eip);
+void bx_instr_cnear_branch_not_taken(unsigned cpu);
+void bx_instr_ucnear_branch(unsigned cpu, unsigned what, bx_address new_eip);
+void bx_instr_far_branch(unsigned cpu, unsigned what, Bit16u new_cs, bx_address new_eip);
+
+void bx_instr_opcode(unsigned cpu, Bit8u *opcode, unsigned len, Boolean is32);
+void bx_instr_fetch_decode_completed(unsigned cpu, BxInstruction_t *i);
+
+void bx_instr_prefix_as(unsigned cpu);
+void bx_instr_prefix_os(unsigned cpu);
+void bx_instr_prefix_rep(unsigned cpu);
+void bx_instr_prefix_repne(unsigned cpu);
+void bx_instr_prefix_lock(unsigned cpu);
+void bx_instr_prefix_cs(unsigned cpu);
+void bx_instr_prefix_ss(unsigned cpu);
+void bx_instr_prefix_ds(unsigned cpu);
+void bx_instr_prefix_es(unsigned cpu);
+void bx_instr_prefix_fs(unsigned cpu);
+void bx_instr_prefix_gs(unsigned cpu);
+void bx_instr_prefix_extend8b(unsigned cpu);
+
+void bx_instr_interrupt(unsigned cpu, unsigned vector);
+void bx_instr_exception(unsigned cpu, unsigned vector);
+void bx_instr_hwinterrupt(unsigned cpu, unsigned vector, Bit16u cs, bx_address eip);
+
+void bx_instr_tlb_cntrl(unsigned cpu, unsigned what, Bit32u newval);
+void bx_instr_cache_cntrl(unsigned cpu, unsigned what);
+
+void bx_instr_repeat_iteration(unsigned cpu);
+
 void bx_instr_inp(Bit16u addr, unsigned len);
 void bx_instr_outp(Bit16u addr, unsigned len);
 void bx_instr_inp2(Bit16u addr, unsigned len, unsigned val);
 void bx_instr_outp2(Bit16u addr, unsigned len, unsigned val);
-void bx_instr_tlb_cntrl(unsigned what, Bit32u newval);
-void bx_instr_cache_cntrl(unsigned what);
-void bx_instr_hwinterrupt(unsigned vector, Bit32u cs, Bit32u eip);
-void bx_instr_init(void);
-void bx_instr_shutdown(void);
-void bx_instr_opcode_repeating(void);
-void bx_instr_prefix_as(void);
-void bx_instr_prefix_os(void);
-void bx_instr_prefix_rep(void);
-void bx_instr_prefix_repne(void);
-void bx_instr_prefix_lock(void);
-void bx_instr_prefix_cs(void);
-void bx_instr_prefix_ss(void);
-void bx_instr_prefix_ds(void);
-void bx_instr_prefix_es(void);
-void bx_instr_prefix_fs(void);
-void bx_instr_prefix_gs(void);
-void bx_instr_modrm32(unsigned modrm);
-void bx_instr_sib32(unsigned sib);
-void bx_instr_modrm16(unsigned modrm);
-void bx_instr_iret(void);
-void bx_instr_debug_prompt(void);
-void bx_instr_lin_read(Bit32u lin, Bit32u phy, unsigned len);
-void bx_instr_lin_write(Bit32u lin, Bit32u phy, unsigned len);
-
-// called from the debug prompt
-void bx_instr_start(void);
-void bx_instr_stop(void);
-void bx_instr_reset(void);
-void bx_instr_print(void);
-
-#  define BX_INSTR_INIT()                      bx_instr_init()
-#  define BX_INSTR_SHUTDOWN()                  bx_instr_shutdown()
-#  define BX_INSTR_CNEAR_BRANCH_TAKEN(new_eip) bx_instr_cnear_branch_taken(new_eip)
-#  define BX_INSTR_CNEAR_BRANCH_NOT_TAKEN()    bx_instr_cnear_branch_not_taken()
-#  define BX_INSTR_UCNEAR_BRANCH(what, new_eip) bx_instr_ucnear_branch(what, new_eip)
-#  define BX_INSTR_FAR_BRANCH(what, new_cs, new_eip) bx_instr_far_branch(what, new_cs, new_eip)
-#  define BX_INSTR_OPCODE_BEGIN(linear)        bx_instr_opcode_begin(linear)
-#  define BX_INSTR_OPCODE_END(linear)          bx_instr_opcode_end(linear)
-#  define BX_INSTR_OPCODE_BYTE1(b)             bx_instr_opcode_byte1(b)
-#  define BX_INSTR_OPCODE_BYTE2(b)             bx_instr_opcode_byte2(b)
-#  define BX_INSTR_OPCODE_G1EbIb(nnn)          bx_instr_opcode_g1ebib(nnn)
-#  define BX_INSTR_OPCODE_G1EvIv(nnn)          bx_instr_opcode_g1eviv(nnn)
-#  define BX_INSTR_OPCODE_G1EvIb(nnn)          bx_instr_opcode_g1evib(nnn)
-#  define BX_INSTR_OPCODE_G2EbIb(nnn)          bx_instr_opcode_g2ebib(nnn)
-#  define BX_INSTR_OPCODE_G2EvIb(nnn)          bx_instr_opcode_g2evib(nnn)
-#  define BX_INSTR_OPCODE_G2Eb1(nnn)           bx_instr_opcode_g2eb1(nnn)
-#  define BX_INSTR_OPCODE_G2Ev1(nnn)           bx_instr_opcode_g2ev1(nnn)
-#  define BX_INSTR_OPCODE_G2EbCL(nnn)          bx_instr_opcode_g2ebcl(nnn)
-#  define BX_INSTR_OPCODE_G2EvCL(nnn)          bx_instr_opcode_g2evcl(nnn)
-#  define BX_INSTR_OPCODE_G3Eb(nnn)            bx_instr_opcode_g3eb(nnn)
-#  define BX_INSTR_OPCODE_G3Ev(nnn)            bx_instr_opcode_g3ev(nnn)
-#  define BX_INSTR_OPCODE_G4(nnn)              bx_instr_opcode_g4(nnn)
-#  define BX_INSTR_OPCODE_G5(nnn)              bx_instr_opcode_g5(nnn)
-#  define BX_INSTR_OPCODE_G6(nnn)              bx_instr_opcode_g6(nnn)
-#  define BX_INSTR_OPCODE_G7(nnn)              bx_instr_opcode_g7(nnn)
-#  define BX_INSTR_OPCODE_G8EvIb(nnn)          bx_instr_opcode_g8evib(nnn)
-#  define BX_INSTR_MEM_CODE(linear, size)      bx_instr_mem_code(linear, size)
-#  define BX_INSTR_MEM_DATA(linear, size, rw)  bx_instr_mem_data(linear, size, rw)
-#  define BX_INSTR_EXCEPTION(vector)           bx_instr_exception(vector)
-#  define BX_INSTR_INP(addr, len)              bx_instr_inp(addr, len)
-#  define BX_INSTR_INP2(addr, len, val)        bx_instr_inp2(addr, len, val)
-#  define BX_INSTR_OUTP(addr, len)             bx_instr_outp(addr, len)
-#  define BX_INSTR_OUTP2(addr, len, val)       bx_instr_outp2(addr, len, val)
-#  define BX_INSTR_FETCH_BYTE(val8)            bx_instr_fetch_byte(val8)
-#  define BX_INSTR_FETCH_WORD(val16)           bx_instr_fetch_word(val16)
-#  define BX_INSTR_FETCH_DWORD(val32)          bx_instr_fetch_dword(val32)
-#  define BX_INSTR_PHY_WRITE(addr, len)        bx_instr_phy_write(addr, len)
-#  define BX_INSTR_PHY_READ(addr, len)         bx_instr_phy_read(addr, len)
-#  define BX_INSTR_INTERRUPT(vector)           bx_instr_interrupt(vector)
-
-#  define BX_INSTR_TLB_CNTRL(what, newval)     bx_instr_tlb_cntrl(what, newval)
-#  define BX_INSTR_CACHE_CNTRL(what)           bx_instr_cache_cntrl(what)
-#  define BX_INSTR_HWINTERRUPT(vector, cs, eip) bx_instr_hwinterrupt(vector, cs, eip)
-#  define BX_INSTR_OPCODE_REPEATING()           bx_instr_opcode_repeating()
-
-#  define BX_INSTR_PREFIX_AS()                 bx_instr_prefix_as()
-#  define BX_INSTR_PREFIX_OS()                 bx_instr_prefix_os()
-#  define BX_INSTR_PREFIX_REP()                bx_instr_prefix_rep()
-#  define BX_INSTR_PREFIX_REPNE()              bx_instr_prefix_repne()
-#  define BX_INSTR_PREFIX_LOCK()               bx_instr_prefix_lock()
-#  define BX_INSTR_PREFIX_CS()                 bx_instr_prefix_cs()
-#  define BX_INSTR_PREFIX_SS()                 bx_instr_prefix_ss()
-#  define BX_INSTR_PREFIX_DS()                 bx_instr_prefix_ds()
-#  define BX_INSTR_PREFIX_ES()                 bx_instr_prefix_es()
-#  define BX_INSTR_PREFIX_FS()                 bx_instr_prefix_fs()
-#  define BX_INSTR_PREFIX_GS()                 bx_instr_prefix_gs()
-
-#  define BX_INSTR_MODRM32(modrm)              bx_instr_modrm32(modrm)
-#  define BX_INSTR_SIB32(sib)                  bx_instr_sib32(sib)
-#  define BX_INSTR_MODRM16(modrm)              bx_instr_modrm16(modrm)
-#  define BX_INSTR_SIB_mod0_base5(ss)
-#  define BX_INSTR_SIB_MOD0_IND4()
-#  define BX_INSTR_SIB_MOD1_IND4()
-#  define BX_INSTR_SIB_MOD2_IND4()
-
-#  define BX_INSTR_IRET()                      bx_instr_iret()
-#  define BX_INSTR_DEBUG_PROMPT()              bx_instr_debug_prompt()
-
-#  define BX_INSTR_LIN_READ(lin, phy, len)  bx_instr_lin_read(lin, phy, len)
-#  define BX_INSTR_LIN_WRITE(lin, phy, len) bx_instr_lin_write(lin, phy, len)
-#  define BX_INSTR_START()                   bx_instr_start ()
-#  define BX_INSTR_STOP()                    bx_instr_stop ()
-#  define BX_INSTR_RESET()                   bx_instr_reset ()
-#  define BX_INSTR_PRINT()                   bx_instr_print ()
-
-#else  // #if BX_INSTRUMENTATION
-#  define BX_INSTR_INIT()
-#  define BX_INSTR_SHUTDOWN()
-#  define BX_INSTR_CNEAR_BRANCH_TAKEN(new_eip)
-#  define BX_INSTR_CNEAR_BRANCH_NOT_TAKEN()
-#  define BX_INSTR_UCNEAR_BRANCH(what, new_eip)
-#  define BX_INSTR_FAR_BRANCH(what, new_cs, new_eip)
-#  define BX_INSTR_OPCODE_BEGIN(linear)
-#  define BX_INSTR_OPCODE_END(linear)
-#  define BX_INSTR_OPCODE_BYTE1(b)
-#  define BX_INSTR_OPCODE_BYTE2(b)
-#  define BX_INSTR_OPCODE_G1EbIb(nnn)
-#  define BX_INSTR_OPCODE_G1EvIv(nnn)
-#  define BX_INSTR_OPCODE_G1EvIb(nnn)
-#  define BX_INSTR_OPCODE_G2EbIb(nnn)
-#  define BX_INSTR_OPCODE_G2EvIb(nnn)
-#  define BX_INSTR_OPCODE_G2Eb1(nnn)
-#  define BX_INSTR_OPCODE_G2Ev1(nnn)
-#  define BX_INSTR_OPCODE_G2EbCL(nnn)
-#  define BX_INSTR_OPCODE_G2EvCL(nnn)
-#  define BX_INSTR_OPCODE_G3Eb(nnn)
-#  define BX_INSTR_OPCODE_G3Ev(nnn)
-#  define BX_INSTR_OPCODE_G4(nnn)
-#  define BX_INSTR_OPCODE_G5(nnn)
-#  define BX_INSTR_OPCODE_G6(nnn)
-#  define BX_INSTR_OPCODE_G7(nnn)
-#  define BX_INSTR_OPCODE_G8EvIb(nnn)
-#  define BX_INSTR_MEM_CODE(linear, size)
-#  define BX_INSTR_MEM_DATA(linear, size, rw)
-#  define BX_INSTR_EXCEPTION(vector)
-#  define BX_INSTR_INP(addr, len)
-#  define BX_INSTR_INP2(addr, len, val)
-#  define BX_INSTR_OUTP(addr, len)
-#  define BX_INSTR_OUTP2(addr, len, val)
-#  define BX_INSTR_FETCH_BYTE(val8)
-#  define BX_INSTR_FETCH_WORD(val16)
-#  define BX_INSTR_FETCH_DWORD(val32)
-#  define BX_INSTR_PHY_WRITE(addr, len)
-#  define BX_INSTR_PHY_READ(addr, len)
-#  define BX_INSTR_INTERRUPT(vector)
-#  define BX_INSTR_TLB_CNTRL(what, newval)
-#  define BX_INSTR_CACHE_CNTRL(what)
-#  define BX_INSTR_HWINTERRUPT(vector, cs, eip)
-#  define BX_INSTR_OPCODE_REPEATING()
-
-#  define BX_INSTR_PREFIX_AS()
-#  define BX_INSTR_PREFIX_OS()
-#  define BX_INSTR_PREFIX_REP()
-#  define BX_INSTR_PREFIX_REPNE()
-#  define BX_INSTR_PREFIX_LOCK()
-#  define BX_INSTR_PREFIX_CS()
-#  define BX_INSTR_PREFIX_SS()
-#  define BX_INSTR_PREFIX_DS()
-#  define BX_INSTR_PREFIX_ES()
-#  define BX_INSTR_PREFIX_FS()
-#  define BX_INSTR_PREFIX_GS()
-
-#  define BX_INSTR_MODRM32(modrm)
-#  define BX_INSTR_SIB32(sib)
-#  define BX_INSTR_MODRM16(modrm)
-#  define BX_INSTR_SIB_mod0_base5(ss)
-#  define BX_INSTR_SIB_MOD0_IND4()
-#  define BX_INSTR_SIB_MOD1_IND4()
-#  define BX_INSTR_SIB_MOD2_IND4()
 
-#  define BX_INSTR_IRET()
+void bx_instr_mem_code(unsigned cpu, bx_address linear, unsigned size);
+void bx_instr_mem_data(unsigned cpu, bx_address linear, unsigned size, unsigned rw);
+
+void bx_instr_lin_read(unsigned cpu, bx_address lin, bx_address phy, unsigned len);
+void bx_instr_lin_write(unsigned cpu, bx_address lin, bx_address phy, unsigned len);
+
+void bx_instr_phy_write(bx_address addr, unsigned len);
+void bx_instr_phy_read(bx_address addr, unsigned len);
+
+/* simulation init, shutdown, reset */
+#  define BX_INSTR_INIT(cpu_id)            bx_instr_init(cpu_id)
+#  define BX_INSTR_SHUTDOWN(cpu_id)        bx_instr_shutdown(cpu_id)
+#  define BX_INSTR_RESET(cpu_id)           bx_instr_reset(cpu_id)
+#  define BX_INSTR_NEW_INSTRUCTION(cpu_id) bx_instr_new_instruction(cpu_id)
+
+/* called from command line debugger */
+#  define BX_INSTR_DEBUG_PROMPT()          bx_instr_debug_promt()
+#  define BX_INSTR_START()                 bx_instr_start()
+#  define BX_INSTR_STOP()                  bx_instr_stop()
+#  define BX_INSTR_PRINT()                 bx_instr_print()
+
+/* branch resoultion */
+#  define BX_INSTR_CNEAR_BRANCH_TAKEN(cpu_id, new_eip)       bx_instr_cnear_branch_taken(cpu_id, new_eip)
+#  define BX_INSTR_CNEAR_BRANCH_NOT_TAKEN(cpu_id)   bx_instr_cnear_branch_not_taken(cpu_id)
+#  define BX_INSTR_UCNEAR_BRANCH(cpu_id, what, new_eip)      bx_instr_ucnear_branch(cpu_id, what, new_eip)
+#  define BX_INSTR_FAR_BRANCH(cpu_id, what, new_cs, new_eip) bx_instr_far_branch(cpu_id, what, new_cs, new_eip)
+
+/* decoding completed */
+#  define BX_INSTR_OPCODE(cpu_id, opcode, len, is32) \
+                       bx_instr_opcode(cpu_id, opcode, len, is32)
+#  define BX_INSTR_FETCH_DECODE_COMPLETED(cpu_id, i) \
+                       bx_instr_fetch_decode_completed(cpu_id, i)
+     
+/* prefix decoded */
+#  define BX_INSTR_PREFIX_AS(cpu_id)       bx_instr_prefix_as(cpu_id)
+#  define BX_INSTR_PREFIX_OS(cpu_id)       bx_instr_prefix_os(cpu_id)
+#  define BX_INSTR_PREFIX_REP(cpu_id)      bx_instr_prefix_rep(cpu_id)
+#  define BX_INSTR_PREFIX_REPNE(cpu_id)    bx_instr_prefix_repne(cpu_id)
+#  define BX_INSTR_PREFIX_LOCK(cpu_id)     bx_instr_prefix_lock(cpu_id)
+#  define BX_INSTR_PREFIX_CS(cpu_id)       bx_instr_prefix_cs(cpu_id)
+#  define BX_INSTR_PREFIX_SS(cpu_id)       bx_instr_prefix_ss(cpu_id)
+#  define BX_INSTR_PREFIX_DS(cpu_id)       bx_instr_prefix_ds(cpu_id)
+#  define BX_INSTR_PREFIX_ES(cpu_id)       bx_instr_prefix_es(cpu_id)
+#  define BX_INSTR_PREFIX_FS(cpu_id)       bx_instr_prefix_fs(cpu_id)
+#  define BX_INSTR_PREFIX_GS(cpu_id)       bx_instr_prefix_gs(cpu_id)
+#  define BX_INSTR_PREFIX_EXTEND8B(cpu_id) bx_instr_prefix_extend8b(cpu_id)
+
+/* exceptional case and interrupt */
+#  define BX_INSTR_EXCEPTION(cpu_id, vector)            bx_instr_exception(cpu_id, vector)
+#  define BX_INSTR_INTERRUPT(cpu_id, vector)            bx_instr_interrupt(cpu_id, vector)
+#  define BX_INSTR_HWINTERRUPT(cpu_id, vector, cs, eip) bx_instr_hwinterrupt(cpu_id, vector, cs, eip)
+
+/* TLB/CACHE control instruction executed */
+#  define BX_INSTR_CACHE_CNTRL(cpu_id, what)            bx_instr_cache_cntrl(cpu_id, what)
+#  define BX_INSTR_TLB_CNTRL(cpu_id, what, newval)      bx_instr_tlb_cntrl(cpu_id, what, newval)
+
+#  define BX_INSTR_REPEAT_ITERATION(cpu_id)             bx_instr_repeat_iteration(cpu_id, )
+
+/* memory access */
+#  define BX_INSTR_LIN_READ(cpu_id, lin, phy, len)      bx_instr_lin_read(cpu_id, lin, phy, len)
+#  define BX_INSTR_LIN_WRITE(cpu_id, lin, phy, len)     bx_instr_lin_write(cpu_id, lin, phy, len)
+
+#  define BX_INSTR_MEM_CODE(cpu_id, linear, size)       bx_instr_mem_code(cpu_id, linear, size)
+#  define BX_INSTR_MEM_DATA(cpu_id, linear, size, rw)   bx_instr_mem_data(cpu_id, linear, size, rw)
+
+/* called from memory object */
+#  define BX_INSTR_PHY_WRITE(addr, len)         bx_instr_phy_write(addr, len)
+#  define BX_INSTR_PHY_READ(addr, len)          bx_instr_phy_read(addr, len)
+
+/* feedback from device units */
+#  define BX_INSTR_INP(addr, len)               bx_instr_inp(addr, len)
+#  define BX_INSTR_INP2(addr, len, val)         bx_instr_inp2(addr, len, val)
+#  define BX_INSTR_OUTP(addr, len)              bx_instr_outp(addr, len)
+#  define BX_INSTR_OUTP2(addr, len, val)        bx_instr_outp2(addr, len, val)
+
+#else   
+
+/* simulation init, shutdown, reset */
+#  define BX_INSTR_INIT(cpu_id)
+#  define BX_INSTR_SHUTDOWN(cpu_id)
+#  define BX_INSTR_RESET(cpu_id)
+#  define BX_INSTR_NEW_INSTRUCTION(cpu_id)
+
+/* called from command line debugger */
 #  define BX_INSTR_DEBUG_PROMPT()
+#  define BX_INSTR_START()
+#  define BX_INSTR_STOP()
+#  define BX_INSTR_PRINT()
+
+/* branch resoultion */
+#  define BX_INSTR_CNEAR_BRANCH_TAKEN(cpu_id, new_eip)
+#  define BX_INSTR_CNEAR_BRANCH_NOT_TAKEN(cpu_id)
+#  define BX_INSTR_UCNEAR_BRANCH(cpu_id, what, new_eip)
+#  define BX_INSTR_FAR_BRANCH(cpu_id, what, new_cs, new_eip)
+
+/* decoding completed */
+#  define BX_INSTR_OPCODE(cpu_id, opcode, len, is32) 
+#  define BX_INSTR_FETCH_DECODE_COMPLETED(cpu_id, i)
+     
+/* prefix decoded */
+#  define BX_INSTR_PREFIX_AS(cpu_id)
+#  define BX_INSTR_PREFIX_OS(cpu_id)
+#  define BX_INSTR_PREFIX_REP(cpu_id)
+#  define BX_INSTR_PREFIX_REPNE(cpu_id)
+#  define BX_INSTR_PREFIX_LOCK(cpu_id)
+#  define BX_INSTR_PREFIX_CS(cpu_id)
+#  define BX_INSTR_PREFIX_SS(cpu_id)
+#  define BX_INSTR_PREFIX_DS(cpu_id)
+#  define BX_INSTR_PREFIX_ES(cpu_id)
+#  define BX_INSTR_PREFIX_FS(cpu_id)
+#  define BX_INSTR_PREFIX_GS(cpu_id)
+#  define BX_INSTR_PREFIX_EXTEND8B(cpu_id)
+
+/* exceptional case and interrupt */
+#  define BX_INSTR_EXCEPTION(cpu_id, vector)
+#  define BX_INSTR_INTERRUPT(cpu_id, vector)
+#  define BX_INSTR_HWINTERRUPT(cpu_id, vector, cs, eip)
+
+/* TLB/CACHE control instruction executed */
+#  define BX_INSTR_CACHE_CNTRL(cpu_id, what)
+#  define BX_INSTR_TLB_CNTRL(cpu_id, what, newval)
+
+#  define BX_INSTR_REPEAT_ITERATION(cpu_id)
+
+/* memory access */
+#  define BX_INSTR_LIN_READ(cpu_id, lin, phy, len)
+#  define BX_INSTR_LIN_WRITE(cpu_id, lin, phy, len)
 
-#  define BX_INSTR_LIN_READ(lin, phy, len)
-#  define BX_INSTR_LIN_WRITE(lin, phy, len)
-#  define BX_INSTR_START()                   
-#  define BX_INSTR_STOP()                    
-#  define BX_INSTR_RESET()                   
-#  define BX_INSTR_PRINT()                   
+#  define BX_INSTR_MEM_CODE(cpu_id, linear, size)      
+#  define BX_INSTR_MEM_DATA(cpu_id, linear, size, rw)
 
-#endif  // #if BX_INSTRUMENTATION
+/* called from memory object */
+#  define BX_INSTR_PHY_WRITE(addr, len)
+#  define BX_INSTR_PHY_READ(addr, len)
+
+/* feedback from device units */
+#  define BX_INSTR_INP(addr, len)
+#  define BX_INSTR_INP2(addr, len, val)
+#  define BX_INSTR_OUTP(addr, len)
+#  define BX_INSTR_OUTP2(addr, len, val)
 
+#endif  
