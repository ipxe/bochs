----------------------------------------------------------------------
Patch name: patch.blkdevsize
Author: Ph. Marek, updated by cbothamy
Date: 16 Oct 2002

Detailed description:
This is an update to the previous patch. 

There was a potential risk for your harddisks with the previous
patch because it updated the concat_image_t object (BX_SPLIT_HD is on
by default). The behaviour of BX_SPLIT_HD is to open all filenames
incrementing the last letter. Guess what follows /dev/hda ?

You may now access block devices from within bochs, only 
if --disable-split-hd is configured. 

It has only been tested on linux and a WinNT guest. 
There are issues with the current bios CHS translating scheme and 
the guest OS translating scheme. For example my compaq system translates
a physical     38792/16/63 20GiB harddrive to
a logical      2586/240/63, which does not follow the bitshift algorithm.
I had to find a different PCHS that would translate in a compatible LCHS
I still have to investigate further, but I'm afraid everything I can do 
will break some systems or the others.

Those issues should be explained in the documentation.


Original Detailed description:
I'm currently working to get bochs to support block devices (eg. /dev/hda) as 
harddisks.  I downloaded the current release
http://prdownloads.sourceforge.net/bochs/bochs-1.4.tar.gz
and found that size detection doesn't work.

Here's a patch to get the detection working.

Patch was created with:
  cvs diff -u
Apply patch to what version:
  cvs checked out on 16 Oct 2002
Instructions:
  To patch, go to main bochs directory.
  Type "patch -p0 < THIS_PATCH_FILE".
----------------------------------------------------------------------
Index: config.h.in
===================================================================
RCS file: /cvsroot/bochs/bochs/config.h.in,v
retrieving revision 1.87
diff -u -r1.87 config.h.in
--- config.h.in	13 Oct 2002 22:38:16 -0000	1.87
+++ config.h.in	16 Oct 2002 14:07:28 -0000
@@ -196,6 +196,7 @@
 #define BX_HAVE_SOCKLEN_T 0
 #define BX_HAVE_GETTIMEOFDAY 0
 #define BX_HAVE_REALTIME_USEC BX_HAVE_GETTIMEOFDAY
+#define BX_HAVE_BLKGETSIZE 0
 
 // This turns on Roland Mainz's idle hack.  Presently it is specific to the X11
 // gui. If people try to enable it elsewhere, give a compile error after the
Index: configure
===================================================================
RCS file: /cvsroot/bochs/bochs/configure,v
retrieving revision 1.150
diff -u -r1.150 configure
--- configure	11 Oct 2002 13:21:15 -0000	1.150
+++ configure	16 Oct 2002 14:07:33 -0000
@@ -1,5 +1,5 @@
 #! /bin/sh
-# From configure.in Id: configure.in,v 1.149 2002/10/11 01:11:10 kevinlawton Exp .
+# From configure.in Id: configure.in,v 1.150 2002/10/11 13:21:13 bdenney Exp .
 # Guess values for system-dependent variables and create Makefiles.
 # Generated by GNU Autoconf 2.53.
 #
@@ -7675,6 +7675,64 @@
 _ACEOF
 
 fi
+
+
+echo "$as_me:$LINENO: checking whether BLKGETSIZE is declared" >&5
+echo $ECHO_N "checking whether BLKGETSIZE is declared... $ECHO_C" >&6
+if test "${ac_cv_have_decl_BLKGETSIZE+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+#include "confdefs.h"
+#include <sys/mount.h>
+
+#ifdef F77_DUMMY_MAIN
+#  ifdef __cplusplus
+     extern "C"
+#  endif
+   int F77_DUMMY_MAIN() { return 1; }
+#endif
+int
+main ()
+{
+#ifndef BLKGETSIZE
+  char *p = (char *) BLKGETSIZE;
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_have_decl_BLKGETSIZE=yes
+else
+  echo "$as_me: failed program was:" >&5
+cat conftest.$ac_ext >&5
+ac_cv_have_decl_BLKGETSIZE=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_have_decl_BLKGETSIZE" >&5
+echo "${ECHO_T}$ac_cv_have_decl_BLKGETSIZE" >&6
+if test $ac_cv_have_decl_BLKGETSIZE = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define BX_HAVE_BLKGETSIZE 1
+_ACEOF
+
+fi
+
 
 
 # Check whether --enable-largefile or --disable-largefile was given.
Index: configure.in
===================================================================
RCS file: /cvsroot/bochs/bochs/configure.in,v
retrieving revision 1.150
diff -u -r1.150 configure.in
--- configure.in	11 Oct 2002 13:21:13 -0000	1.150
+++ configure.in	16 Oct 2002 14:07:33 -0000
@@ -126,6 +126,9 @@
 AC_CHECK_TYPE(socklen_t, AC_DEFINE(BX_HAVE_SOCKLEN_T), , [#include <sys/types.h>
 #include <sys/socket.h>])
 
+AC_CHECK_DECL(BLKGETSIZE, AC_DEFINE(BX_HAVE_BLKGETSIZE), , [#include <sys/mount.h>])
+
+
 dnl As of autoconf 2.53, the standard largefile test fails for Linux/gcc.
 dnl It does not put the largefiles arguments into CFLAGS, even though Linux/gcc
 dnl does need them.  Since wxWindows had already solved this exact problem,
Index: bochs.h
===================================================================
RCS file: /cvsroot/bochs/bochs/bochs.h,v
retrieving revision 1.100
diff -u -r1.100 bochs.h
--- bochs.h	6 Oct 2002 14:16:13 -0000	1.100
+++ bochs.h	16 Oct 2002 14:07:33 -0000
@@ -70,6 +70,9 @@
 #  include <sys/types.h>
 #  include <sys/stat.h>
 #endif
+#if BX_HAVE_BLKGETSIZE
+#  include <sys/mount.h>
+#endif
 #include <ctype.h>
 #include <string.h>
 #include <fcntl.h>
Index: iodev/harddrv.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/iodev/harddrv.cc,v
retrieving revision 1.80
diff -u -r1.80 harddrv.cc
--- iodev/harddrv.cc	6 Oct 2002 20:19:03 -0000	1.80
+++ iodev/harddrv.cc	16 Oct 2002 14:07:35 -0000
@@ -3032,7 +3032,47 @@
 	    BX_PANIC(("fstat() returns error!"));
       }
 
-      return fd;
+#if BX_HAVE_BLKGETSIZE
+    // On linux we can use block devices as harddrives. Get the size
+    if (S_ISBLK(stat_buf.st_mode)) {
+      // it's a block device. st_size will be 0, so set it to the correct size.
+
+      Bit64u size;
+      Bit32u size_in512k;
+
+      if (ioctl(fd,BLKGETSIZE,&(size_in512k))==-1) {
+        BX_PANIC(("size of block device %s can't be read",pathname));
+	size = 0;
+        }
+      else {
+        size = (Bit64u)(size_in512k) * 512;
+        }
+
+     if (sizeof(off_t) == 4) {
+       if (size > (0x7fffffff)) {
+         stat_buf.st_size = 0x7ffffe00; /* maximum size without overflow */
+         BX_ERROR(("size of disk image is too big, rounded to %d bytes", stat_buf.st_size));
+         }
+       else {
+         stat_buf.st_size = (Bit32u)size;
+         }
+       }
+     else if(sizeof(off_t) == 8) {
+       stat_buf.st_size = size;
+       }
+     else {
+       BX_PANIC(("size of off_t is unknown"));
+       stat_buf.st_size = 0;
+       }
+     }
+
+#endif // #if BX_HAVE_BLKGETSIZE
+
+    if ((stat_buf.st_size) == 0) {
+      BX_PANIC(("size of disk image '%s' is null",pathname));
+    }
+
+    return fd;
 }
 
 void default_image_t::close ()
@@ -3103,8 +3143,12 @@
     if (ret) {
 	  BX_PANIC(("fstat() returns error!"));
     }
+
+    if ((stat_buf.st_size) == 0) {
+      BX_PANIC(("size of disk image '%s' is null",pathname));
+    }
     if ((stat_buf.st_size % 512) != 0) {
-      BX_PANIC(("size of disk image must be multiple of 512 bytes"));
+      BX_PANIC(("size of disk image '%s' must be multiple of 512 bytes",pathname));
     }
     length_table[i] = stat_buf.st_size;
     start_offset_table[i] = start_offset;
