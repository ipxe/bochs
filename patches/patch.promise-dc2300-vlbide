----------------------------------------------------------------------
Patch name: patches/patch.promise-dc2300-vlbide
Author: Christophe Bothamy
Date: Tue Sep 24 2002

Detailed description:

This patch adds Promise DC2300 VLB IDE Support.
You may find msdos and win95 drivers on the net. Look for
P2300W95.ZIP and DC2300VLBIDEver260b.ZIP.

The good news is that now win95 natively sees my cdrom,
and that the disks are not in msdos compatibility mode any more.

The bad news is that it works only for the first ata interface.

I tested that patch on msdos and win95 only.

Some info on VLB IDE can be found at http://ryston.cz/petr/vlb/


Patch was created with:
  cvs diff -u
Apply patch to what version:
  cvs checked out on Tue Sep 24 2002
Instructions:
  To patch, go to main bochs directory.
  Type "patch -p0 < THIS_PATCH_FILE".
----------------------------------------------------------------------
Index: configure.in
===================================================================
RCS file: /cvsroot/bochs/bochs/configure.in,v
retrieving revision 1.124
diff -u -r1.124 configure.in
--- configure.in	24 Sep 2002 08:15:26 -0000	1.124
+++ configure.in	24 Sep 2002 12:46:14 -0000
@@ -513,6 +513,22 @@
   )
 AC_SUBST(PCI_OBJ)
 
+AC_MSG_CHECKING(for Promise DC2300 VLB-IDE support)
+AC_ARG_ENABLE(dc2300-vlb-ide,
+  [  --enable-dc2300-vlb-ide           enable Promise DC2300 VLB-IDE support],
+  [if test "$enableval" = yes; then
+    AC_MSG_RESULT(yes)
+    AC_DEFINE(BX_PDC20230C_VLBIDE_SUPPORT, 1)
+   else
+    AC_MSG_RESULT(no)
+    AC_DEFINE(BX_PDC20230C_VLBIDE_SUPPORT, 0)
+   fi],
+  [
+    AC_MSG_RESULT(no)
+    AC_DEFINE(BX_PDC20230C_VLBIDE_SUPPORT, 0)
+    ]
+  )
+
 
 support_pse=0
 AC_MSG_CHECKING(for 4Meg pages support)
Index: configure
===================================================================
RCS file: /cvsroot/bochs/bochs/configure,v
retrieving revision 1.124
diff -u -r1.124 configure
--- configure	24 Sep 2002 08:15:23 -0000	1.124
+++ configure	24 Sep 2002 12:46:16 -0000
@@ -1,5 +1,5 @@
 #! /bin/sh
-# From configure.in Id: configure.in,v 1.123 2002/09/23 21:41:34 bdenney Exp .
+# From configure.in Id: configure.in,v 1.124 2002/09/24 08:15:26 bdenney Exp .
 # Guess values for system-dependent variables and create Makefiles.
 # Generated by GNU Autoconf 2.53.
 #
@@ -852,6 +852,7 @@
   --enable-split-hd                 allows split hard disk image
   --enable-ne2000                   enable limited ne2000 support
   --enable-pci                      enable limited i440FX PCI support
+  --enable-dc2300-vlb-ide           enable Promise DC2300 VLB-IDE support
   --enable-4meg-pages               support 4Megabyte pages extensions
   --enable-pae                      support Physical Address Extensions
   --enable-guest2host-tlb           support guest to host addr TLB for speed
@@ -8870,6 +8871,38 @@
 
 fi;
 
+
+echo "$as_me:$LINENO: checking for Promise DC2300 VLB-IDE support" >&5
+echo $ECHO_N "checking for Promise DC2300 VLB-IDE support... $ECHO_C" >&6
+# Check whether --enable-dc2300-vlb-ide or --disable-dc2300-vlb-ide was given.
+if test "${enable_dc2300_vlb_ide+set}" = set; then
+  enableval="$enable_dc2300_vlb_ide"
+  if test "$enableval" = yes; then
+    echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+    cat >>confdefs.h <<\_ACEOF
+#define BX_PDC20230C_VLBIDE_SUPPORT 1
+_ACEOF
+
+   else
+    echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+    cat >>confdefs.h <<\_ACEOF
+#define BX_PDC20230C_VLBIDE_SUPPORT 0
+_ACEOF
+
+   fi
+else
+
+    echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+    cat >>confdefs.h <<\_ACEOF
+#define BX_PDC20230C_VLBIDE_SUPPORT 0
+_ACEOF
+
+
+
+fi;
 
 
 support_pse=0
Index: config.h.in
===================================================================
RCS file: /cvsroot/bochs/bochs/config.h.in,v
retrieving revision 1.78
diff -u -r1.78 config.h.in
--- config.h.in	24 Sep 2002 08:15:27 -0000	1.78
+++ config.h.in	24 Sep 2002 12:46:17 -0000
@@ -580,6 +580,9 @@
 // limited i440FX PCI support
 #define BX_PCI_SUPPORT 0
 
+// Promise VLBIDE DC2300 Support
+#define BX_PDC20230C_VLBIDE_SUPPORT 0
+
 // dynamic translation (future: not supported yet)
 #define BX_DYNAMIC_TRANSLATION 0
 #define BX_DYNAMIC_CPU_I386    0
Index: iodev/harddrv.h
===================================================================
RCS file: /cvsroot/bochs/bochs/iodev/harddrv.h,v
retrieving revision 1.14
diff -u -r1.14 harddrv.h
--- iodev/harddrv.h	22 Sep 2002 20:56:12 -0000	1.14
+++ iodev/harddrv.h	24 Sep 2002 12:46:17 -0000
@@ -24,7 +24,6 @@
 //  License along with this library; if not, write to the Free Software
 //  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 
-
 typedef enum _sense {
       SENSE_NONE = 0, SENSE_NOT_READY = 2, SENSE_ILLEGAL_REQUEST = 5,
       SENSE_UNIT_ATTENTION = 6
@@ -348,6 +347,16 @@
     Bit8u  irq;
 
     } channels[BX_MAX_ATA_CHANNEL];
+
+#if BX_PDC20230C_VLBIDE_SUPPORT
+// pdc20630c is only available for 1st ata channel
+  struct pdc20630c_t {
+    Boolean prog_mode;
+    Bit8u   prog_count;
+    Bit32u  p1f3_value;
+    Bit32u  p1f4_value;
+    } pdc20230c;
+#endif
 
   bx_devices_c *devices;
   };
Index: iodev/harddrv.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/iodev/harddrv.cc,v
retrieving revision 1.75
diff -u -r1.75 harddrv.cc
--- iodev/harddrv.cc	23 Sep 2002 21:11:51 -0000	1.75
+++ iodev/harddrv.cc	24 Sep 2002 12:46:18 -0000
@@ -330,6 +330,14 @@
     }
   }
 
+#if BX_PDC20230C_VLBIDE_SUPPORT
+      BX_HD_THIS pdc20230c.prog_mode = 0;
+      BX_HD_THIS pdc20230c.prog_count = 0;
+      BX_HD_THIS pdc20230c.p1f3_value = 0;
+      BX_HD_THIS pdc20230c.p1f4_value = 0;
+#endif
+
+
   // generate CMOS values for hard drive if not using a CMOS image
   if (!bx_options.cmos.OcmosImage->get ()) {
     cmos->s.reg[0x12] = 0x00; // start out with: no drive 0, no drive 1
@@ -481,10 +489,68 @@
     BX_PANIC(("Unable to find ATA channel, ioport=0x%04x", address));
     }
 
+#if BX_PDC20230C_VLBIDE_SUPPORT
+// pdc20230c is only available for first ata channel
+if (channel == 0) {
+
+  // Detect the switch to programming mode
+  if (!BX_HD_THIS pdc20230c.prog_mode) {
+    switch (port) {
+      case 0x02:
+        if ((BX_HD_THIS pdc20230c.prog_count == 0) || (BX_HD_THIS pdc20230c.prog_count > 2)) {
+          BX_HD_THIS pdc20230c.prog_count++;
+        }
+	else {
+          BX_HD_THIS pdc20230c.prog_count=0;
+	}
+	break;
+      case 0x16:
+        if ((BX_HD_THIS pdc20230c.prog_count == 1) || (BX_HD_THIS pdc20230c.prog_count == 2)) {
+	  BX_HD_THIS pdc20230c.prog_count++;
+	}
+	else {
+          BX_HD_THIS pdc20230c.prog_count=0;
+	}
+	break;
+      default:
+	BX_HD_THIS pdc20230c.prog_count=0;
+    }
+
+    if (BX_HD_THIS pdc20230c.prog_count == 5) {
+      BX_HD_THIS pdc20230c.prog_mode = 1;
+      BX_SELECTED_CONTROLLER(channel).sector_count &= 0x7f;
+      BX_INFO(("Promise VLB-IDE DC2300: Switching to Programming mode"));
+    }
+  }
+
+  // Returns value when in programming mode
+  if (BX_HD_THIS pdc20230c.prog_mode) {
+    switch (port) {
+      case 0x05:
+	// Leave programming mode
+        BX_HD_THIS pdc20230c.prog_mode = 0;
+        BX_INFO(("Promise VLB-IDE DC2300: Leaving Programming mode"));
+	// Value will be sent be normal code
+        break;
+      case 0x03:
+	// Special programming register
+        value32 = BX_HD_THIS pdc20230c.p1f3_value;
+        GOTO_RETURN_VALUE ;
+        break;
+      case 0x04:
+	// Special programming register
+        value32 = BX_HD_THIS pdc20230c.p1f4_value;
+        GOTO_RETURN_VALUE ;
+        break;
+    }
+  }
+}
+#endif
+
   if (io_len>1 && port!=0x00) {
     BX_PANIC(("non-byte IO read to %04x", (unsigned) address));
     }
-
+  
   switch (port) {
     case 0x00: // hard disk data (16bit) 0x1f0
       if (BX_SELECTED_CONTROLLER(channel).status.drq == 0) {
@@ -952,6 +1018,26 @@
   if (channel == BX_MAX_ATA_CHANNEL) {
     BX_PANIC(("Unable to find ATA channel, ioport=0x%04x", address));
     }
+
+#if BX_PDC20230C_VLBIDE_SUPPORT
+// pdc20230c is only available for first ata channel
+if (channel == 0) {
+  BX_HD_THIS pdc20230c.prog_count = 0;
+
+  if (BX_HD_THIS pdc20230c.prog_mode != 0) {
+    switch (port) {
+      case 0x03:
+	BX_HD_THIS pdc20230c.p1f3_value = value;
+	return;
+        break;
+      case 0x04:
+	BX_HD_THIS pdc20230c.p1f4_value = value;
+	return;
+        break;
+    }
+  }
+}
+#endif
 
   if (io_len>1 && port!=0x00) {
     BX_PANIC(("non-byte IO write to %04x", (unsigned) address));
