Patch name: portable2
Date: Thu Apr  5 12:21:09 EDT 2001
Author: Bryce Denney <bryce dot denney at bigfoot dot com>
Apply to: bochs-2000_0325a.tar.gz with portable1 patch
How to apply: patch -p1 < THIS_PATCH_FILE

This patch, portable2, refines portable1 a bit.  I moved all the platform
dependent function definitions into osdep.h and osdep.cc.  This includes
macutils.h and macutils.c, which are no longer present.  (Well, if you apply
the patch it may turn them to empty files instead of erasing them.)

The approach to replacing library functions is improved slightly since 
portable1.  Now there is no need to write "bx_snprintf" in the code; just
write the number function name "snprintf".  If config.h says that snprintf
is not present, I do two things:
  1) #define snprintf bx_snprintf in osdep.h
  2) define the bx_snprintf function in osdep.cc
The purpose of the renaming is so that you can test the replacement functions
on a system that has the replacement function in their libc, without
duplicate symbols or confusion.

There were two typecasts in fpu/reg_divide.c that I forgot to turn into
PTR2INT() macro calls.  These are fixed in this patch as well.

-------------patch begins here---------------------------------------------
diff -crN clean-portable1/Makefile.in portable2/Makefile.in
*** clean-portable1/Makefile.in	Wed Apr  4 18:52:18 2001
--- portable2/Makefile.in	Thu Apr  5 12:19:40 2001
***************
*** 75,82 ****
  	load32bitOShack.o \
  	state_file.o \
  	pc_system.o \
! 	snprintf.o \
! 	strtoull.o
  
  EXTERN_ENVIRONMENT_OBJS = \
  	main.o \
--- 75,81 ----
  	load32bitOShack.o \
  	state_file.o \
  	pc_system.o \
! 	osdep.o
  
  EXTERN_ENVIRONMENT_OBJS = \
  	main.o \
diff -crN clean-portable1/bochs.h portable2/bochs.h
*** clean-portable1/bochs.h	Wed Apr  4 18:52:18 2001
--- portable2/bochs.h	Thu Apr  5 12:19:40 2001
***************
*** 20,25 ****
--- 20,31 ----
  //  License along with this library; if not, write to the Free Software
  //  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  
+ //
+ // bochs.h is the master header file for all C++ code.  It includes all 
+ // the system header files needed by bochs, and also includes all the bochs
+ // C++ header files.  Because bochs.h and the files that it includes has 
+ // structure and class definitions, it cannot be called from C code.
+ // 
  
  #ifndef BX_BOCHS_H
  #  define BX_BOCHS_H 1
diff -crN clean-portable1/config.h.in portable2/config.h.in
*** clean-portable1/config.h.in	Wed Apr  4 18:52:18 2001
--- portable2/config.h.in	Thu Apr  5 12:19:40 2001
***************
*** 14,26 ****
  //
  //     EMail:    kevin@bochs.com
  
  
  #ifdef _BX_CONFIG_H_
  #else
  #define _BX_CONFIG_H_ 1
  
- 
- 
  ///////////////////////////////////////////////////////////////////
  // USER CONFIGURABLE OPTIONS : EDIT ONLY OPTIONS IN THIS SECTION //
  ///////////////////////////////////////////////////////////////////
--- 14,35 ----
  //
  //     EMail:    kevin@bochs.com
  
+ //
+ // config.h.in is distributed in the source TAR file.  When you run
+ // the configure script, it generates config.h with some changes
+ // according to your build environment.  For example, in config.h.in,
+ // SIZEOF_UNSIGNED_CHAR is set to 0.  When configure produces config.h
+ // it will change "0" to the detected value for your system.
+ // 
+ // config.h contains ONLY preprocessor #defines and a few typedefs.
+ // It must be included by both C and C++ files, so it must not
+ // contain anything language dependent such as a class declaration.
+ //
  
  #ifdef _BX_CONFIG_H_
  #else
  #define _BX_CONFIG_H_ 1
  
  ///////////////////////////////////////////////////////////////////
  // USER CONFIGURABLE OPTIONS : EDIT ONLY OPTIONS IN THIS SECTION //
  ///////////////////////////////////////////////////////////////////
***************
*** 404,409 ****
--- 413,419 ----
  #define BX_HAVE_SELECT 0
  #define BX_HAVE_SNPRINTF 0
  #define BX_HAVE_STRTOULL 0
+ #define BX_HAVE_STRDUP 0
  
  // set if your compiler does not permit an empty struct
  #define BX_NO_EMPTY_STRUCTS 0
diff -crN clean-portable1/configure portable2/configure
*** clean-portable1/configure	Wed Apr  4 18:52:18 2001
--- portable2/configure	Thu Apr  5 12:19:40 2001
***************
*** 2458,2475 ****
  fi
  done
  
  
  echo $ac_n "checking if compiler allows empty structs""... $ac_c" 1>&6
! echo "configure:2464: checking if compiler allows empty structs" >&5
  cat > conftest.$ac_ext <<EOF
! #line 2466 "configure"
  #include "confdefs.h"
  
  int main() {
  typedef struct { } junk;
  ; return 0; }
  EOF
! if { (eval echo configure:2473: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    echo "$ac_t""yes" 1>&6
  else
--- 2458,2533 ----
  fi
  done
  
+ for ac_func in strdup
+ do
+ echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
+ echo "configure:2465: checking for $ac_func" >&5
+ if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
+   echo $ac_n "(cached) $ac_c" 1>&6
+ else
+   cat > conftest.$ac_ext <<EOF
+ #line 2470 "configure"
+ #include "confdefs.h"
+ /* System header to define __stub macros and hopefully few prototypes,
+     which can conflict with char $ac_func(); below.  */
+ #include <assert.h>
+ /* Override any gcc2 internal prototype to avoid an error.  */
+ /* We use char because int might match the return type of a gcc2
+     builtin and then its argument prototype would still apply.  */
+ char $ac_func();
+ 
+ int main() {
+ 
+ /* The GNU C library defines this for functions which it implements
+     to always fail with ENOSYS.  Some functions are actually named
+     something starting with __ and the normal name is an alias.  */
+ #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+ choke me
+ #else
+ $ac_func();
+ #endif
+ 
+ ; return 0; }
+ EOF
+ if { (eval echo configure:2493: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+   rm -rf conftest*
+   eval "ac_cv_func_$ac_func=yes"
+ else
+   echo "configure: failed program was:" >&5
+   cat conftest.$ac_ext >&5
+   rm -rf conftest*
+   eval "ac_cv_func_$ac_func=no"
+ fi
+ rm -f conftest*
+ fi
+ 
+ if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
+   echo "$ac_t""yes" 1>&6
+     ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+   cat >> confdefs.h <<EOF
+ #define $ac_tr_func 1
+ EOF
+  cat >> confdefs.h <<\EOF
+ #define BX_HAVE_STRDUP 1
+ EOF
+ 
+ else
+   echo "$ac_t""no" 1>&6
+ fi
+ done
+ 
  
  echo $ac_n "checking if compiler allows empty structs""... $ac_c" 1>&6
! echo "configure:2522: checking if compiler allows empty structs" >&5
  cat > conftest.$ac_ext <<EOF
! #line 2524 "configure"
  #include "confdefs.h"
  
  int main() {
  typedef struct { } junk;
  ; return 0; }
  EOF
! if { (eval echo configure:2531: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    echo "$ac_t""yes" 1>&6
  else
***************
*** 2487,2502 ****
  rm -f conftest*
  
  echo $ac_n "checking if compiler allows __attribute__""... $ac_c" 1>&6
! echo "configure:2491: checking if compiler allows __attribute__" >&5
  cat > conftest.$ac_ext <<EOF
! #line 2493 "configure"
  #include "confdefs.h"
  
  int main() {
  typedef struct { } __attribute__ ((packed)) junk;
  ; return 0; }
  EOF
! if { (eval echo configure:2500: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    echo "$ac_t""yes" 1>&6
  else
--- 2545,2560 ----
  rm -f conftest*
  
  echo $ac_n "checking if compiler allows __attribute__""... $ac_c" 1>&6
! echo "configure:2549: checking if compiler allows __attribute__" >&5
  cat > conftest.$ac_ext <<EOF
! #line 2551 "configure"
  #include "confdefs.h"
  
  int main() {
  typedef struct { } __attribute__ ((packed)) junk;
  ; return 0; }
  EOF
! if { (eval echo configure:2558: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    echo "$ac_t""yes" 1>&6
  else
***************
*** 2522,2537 ****
  cross_compiling=$ac_cv_prog_cxx_cross
  
  echo $ac_n "checking for hash_map.h""... $ac_c" 1>&6
! echo "configure:2526: checking for hash_map.h" >&5
  cat > conftest.$ac_ext <<EOF
! #line 2528 "configure"
  #include "confdefs.h"
  #include <hash_map.h>
  int main() {
  
  ; return 0; }
  EOF
! if { (eval echo configure:2535: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    
       echo "$ac_t""yes" 1>&6
--- 2580,2595 ----
  cross_compiling=$ac_cv_prog_cxx_cross
  
  echo $ac_n "checking for hash_map.h""... $ac_c" 1>&6
! echo "configure:2584: checking for hash_map.h" >&5
  cat > conftest.$ac_ext <<EOF
! #line 2586 "configure"
  #include "confdefs.h"
  #include <hash_map.h>
  int main() {
  
  ; return 0; }
  EOF
! if { (eval echo configure:2593: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    
       echo "$ac_t""yes" 1>&6
***************
*** 2549,2564 ****
  rm -f conftest*
  
  echo $ac_n "checking if compiler allows blank labels""... $ac_c" 1>&6
! echo "configure:2553: checking if compiler allows blank labels" >&5
  cat > conftest.$ac_ext <<EOF
! #line 2555 "configure"
  #include "confdefs.h"
  
  int main() {
   { label1: } 
  ; return 0; }
  EOF
! if { (eval echo configure:2562: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    echo "$ac_t""yes" 1>&6
  else
--- 2607,2622 ----
  rm -f conftest*
  
  echo $ac_n "checking if compiler allows blank labels""... $ac_c" 1>&6
! echo "configure:2611: checking if compiler allows blank labels" >&5
  cat > conftest.$ac_ext <<EOF
! #line 2613 "configure"
  #include "confdefs.h"
  
  int main() {
   { label1: } 
  ; return 0; }
  EOF
! if { (eval echo configure:2620: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
    rm -rf conftest*
    echo "$ac_t""yes" 1>&6
  else
***************
*** 2583,2589 ****
  
  
  echo $ac_n "checking for cpu level""... $ac_c" 1>&6
! echo "configure:2587: checking for cpu level" >&5
  # Check whether --enable-cpu-level or --disable-cpu-level was given.
  if test "${enable_cpu_level+set}" = set; then
    enableval="$enable_cpu_level"
--- 2641,2647 ----
  
  
  echo $ac_n "checking for cpu level""... $ac_c" 1>&6
! echo "configure:2645: checking for cpu level" >&5
  # Check whether --enable-cpu-level or --disable-cpu-level was given.
  if test "${enable_cpu_level+set}" = set; then
    enableval="$enable_cpu_level"
***************
*** 2646,2652 ****
  
  
  echo $ac_n "checking for dynamic translation support""... $ac_c" 1>&6
! echo "configure:2650: checking for dynamic translation support" >&5
  # Check whether --enable-dynamic or --disable-dynamic was given.
  if test "${enable_dynamic+set}" = set; then
    enableval="$enable_dynamic"
--- 2704,2710 ----
  
  
  echo $ac_n "checking for dynamic translation support""... $ac_c" 1>&6
! echo "configure:2708: checking for dynamic translation support" >&5
  # Check whether --enable-dynamic or --disable-dynamic was given.
  if test "${enable_dynamic+set}" = set; then
    enableval="$enable_dynamic"
***************
*** 2719,2725 ****
  
  
  echo $ac_n "checking for NE2000 support""... $ac_c" 1>&6
! echo "configure:2723: checking for NE2000 support" >&5
  # Check whether --enable-ne2000 or --disable-ne2000 was given.
  if test "${enable_ne2000+set}" = set; then
    enableval="$enable_ne2000"
--- 2777,2783 ----
  
  
  echo $ac_n "checking for NE2000 support""... $ac_c" 1>&6
! echo "configure:2781: checking for NE2000 support" >&5
  # Check whether --enable-ne2000 or --disable-ne2000 was given.
  if test "${enable_ne2000+set}" = set; then
    enableval="$enable_ne2000"
***************
*** 2754,2760 ****
  
  
  echo $ac_n "checking for i440FX PCI support""... $ac_c" 1>&6
! echo "configure:2758: checking for i440FX PCI support" >&5
  # Check whether --enable-pci or --disable-pci was given.
  if test "${enable_pci+set}" = set; then
    enableval="$enable_pci"
--- 2812,2818 ----
  
  
  echo $ac_n "checking for i440FX PCI support""... $ac_c" 1>&6
! echo "configure:2816: checking for i440FX PCI support" >&5
  # Check whether --enable-pci or --disable-pci was given.
  if test "${enable_pci+set}" = set; then
    enableval="$enable_pci"
***************
*** 2789,2795 ****
  
  
  echo $ac_n "checking for port e9 hack""... $ac_c" 1>&6
! echo "configure:2793: checking for port e9 hack" >&5
  # Check whether --enable-port-e9-hack or --disable-port-e9-hack was given.
  if test "${enable_port_e9_hack+set}" = set; then
    enableval="$enable_port_e9_hack"
--- 2847,2853 ----
  
  
  echo $ac_n "checking for port e9 hack""... $ac_c" 1>&6
! echo "configure:2851: checking for port e9 hack" >&5
  # Check whether --enable-port-e9-hack or --disable-port-e9-hack was given.
  if test "${enable_port_e9_hack+set}" = set; then
    enableval="$enable_port_e9_hack"
***************
*** 2820,2826 ****
  
  
  echo $ac_n "checking for use of .cpp as suffix""... $ac_c" 1>&6
! echo "configure:2824: checking for use of .cpp as suffix" >&5
  # Check whether --enable-cpp or --disable-cpp was given.
  if test "${enable_cpp+set}" = set; then
    enableval="$enable_cpp"
--- 2878,2884 ----
  
  
  echo $ac_n "checking for use of .cpp as suffix""... $ac_c" 1>&6
! echo "configure:2882: checking for use of .cpp as suffix" >&5
  # Check whether --enable-cpp or --disable-cpp was given.
  if test "${enable_cpp+set}" = set; then
    enableval="$enable_cpp"
***************
*** 2862,2868 ****
  
  
  echo $ac_n "checking for Bochs internal debugger support""... $ac_c" 1>&6
! echo "configure:2866: checking for Bochs internal debugger support" >&5
  # Check whether --enable-debugger or --disable-debugger was given.
  if test "${enable_debugger+set}" = set; then
    enableval="$enable_debugger"
--- 2920,2926 ----
  
  
  echo $ac_n "checking for Bochs internal debugger support""... $ac_c" 1>&6
! echo "configure:2924: checking for Bochs internal debugger support" >&5
  # Check whether --enable-debugger or --disable-debugger was given.
  if test "${enable_debugger+set}" = set; then
    enableval="$enable_debugger"
***************
*** 2900,2906 ****
  
  
  echo $ac_n "checking for disassembler support""... $ac_c" 1>&6
! echo "configure:2904: checking for disassembler support" >&5
  # Check whether --enable-disasm or --disable-disasm was given.
  if test "${enable_disasm+set}" = set; then
    enableval="$enable_disasm"
--- 2958,2964 ----
  
  
  echo $ac_n "checking for disassembler support""... $ac_c" 1>&6
! echo "configure:2962: checking for disassembler support" >&5
  # Check whether --enable-disasm or --disable-disasm was given.
  if test "${enable_disasm+set}" = set; then
    enableval="$enable_disasm"
***************
*** 2947,2953 ****
  
  
  echo $ac_n "checking for loader support""... $ac_c" 1>&6
! echo "configure:2951: checking for loader support" >&5
  # Check whether --enable-loader or --disable-loader was given.
  if test "${enable_loader+set}" = set; then
    enableval="$enable_loader"
--- 3005,3011 ----
  
  
  echo $ac_n "checking for loader support""... $ac_c" 1>&6
! echo "configure:3009: checking for loader support" >&5
  # Check whether --enable-loader or --disable-loader was given.
  if test "${enable_loader+set}" = set; then
    enableval="$enable_loader"
***************
*** 2985,2991 ****
  INSTRUMENT_DIR='instrument/stubs'
  
  echo $ac_n "checking for instrumentation support""... $ac_c" 1>&6
! echo "configure:2989: checking for instrumentation support" >&5
  # Check whether --enable-instrumentation or --disable-instrumentation was given.
  if test "${enable_instrumentation+set}" = set; then
    enableval="$enable_instrumentation"
--- 3043,3049 ----
  INSTRUMENT_DIR='instrument/stubs'
  
  echo $ac_n "checking for instrumentation support""... $ac_c" 1>&6
! echo "configure:3047: checking for instrumentation support" >&5
  # Check whether --enable-instrumentation or --disable-instrumentation was given.
  if test "${enable_instrumentation+set}" = set; then
    enableval="$enable_instrumentation"
***************
*** 3120,3126 ****
  
  
  echo $ac_n "checking for VGA emulation""... $ac_c" 1>&6
! echo "configure:3124: checking for VGA emulation" >&5
  # Check whether --enable-vga or --disable-vga was given.
  if test "${enable_vga+set}" = set; then
    enableval="$enable_vga"
--- 3178,3184 ----
  
  
  echo $ac_n "checking for VGA emulation""... $ac_c" 1>&6
! echo "configure:3182: checking for VGA emulation" >&5
  # Check whether --enable-vga or --disable-vga was given.
  if test "${enable_vga+set}" = set; then
    enableval="$enable_vga"
***************
*** 3154,3160 ****
  
  
  echo $ac_n "checking for FPU emulation""... $ac_c" 1>&6
! echo "configure:3158: checking for FPU emulation" >&5
  FPU_VAR=''
  FPU_GLUE_OBJ=''
  # Check whether --enable-fpu or --disable-fpu was given.
--- 3212,3218 ----
  
  
  echo $ac_n "checking for FPU emulation""... $ac_c" 1>&6
! echo "configure:3216: checking for FPU emulation" >&5
  FPU_VAR=''
  FPU_GLUE_OBJ=''
  # Check whether --enable-fpu or --disable-fpu was given.
***************
*** 3196,3202 ****
  
  
  echo $ac_n "checking for x86 debugger support""... $ac_c" 1>&6
! echo "configure:3200: checking for x86 debugger support" >&5
  # Check whether --enable-x86-debugger or --disable-x86-debugger was given.
  if test "${enable_x86_debugger+set}" = set; then
    enableval="$enable_x86_debugger"
--- 3254,3260 ----
  
  
  echo $ac_n "checking for x86 debugger support""... $ac_c" 1>&6
! echo "configure:3258: checking for x86 debugger support" >&5
  # Check whether --enable-x86-debugger or --disable-x86-debugger was given.
  if test "${enable_x86_debugger+set}" = set; then
    enableval="$enable_x86_debugger"
***************
*** 3232,3238 ****
  
  
  echo $ac_n "checking for CDROM support""... $ac_c" 1>&6
! echo "configure:3236: checking for CDROM support" >&5
  # Check whether --enable-cdrom or --disable-cdrom was given.
  if test "${enable_cdrom+set}" = set; then
    enableval="$enable_cdrom"
--- 3290,3296 ----
  
  
  echo $ac_n "checking for CDROM support""... $ac_c" 1>&6
! echo "configure:3294: checking for CDROM support" >&5
  # Check whether --enable-cdrom or --disable-cdrom was given.
  if test "${enable_cdrom+set}" = set; then
    enableval="$enable_cdrom"
***************
*** 3274,3280 ****
  
  
  echo $ac_n "checking for Sound Blaster 16 support""... $ac_c" 1>&6
! echo "configure:3278: checking for Sound Blaster 16 support" >&5
  # Check whether --enable-sb16 or --disable-sb16 was given.
  if test "${enable_sb16+set}" = set; then
    enableval="$enable_sb16"
--- 3332,3338 ----
  
  
  echo $ac_n "checking for Sound Blaster 16 support""... $ac_c" 1>&6
! echo "configure:3336: checking for Sound Blaster 16 support" >&5
  # Check whether --enable-sb16 or --disable-sb16 was given.
  if test "${enable_sb16+set}" = set; then
    enableval="$enable_sb16"
diff -crN clean-portable1/configure.in portable2/configure.in
*** clean-portable1/configure.in	Wed Apr  4 18:52:18 2001
--- portable2/configure.in	Thu Apr  5 12:19:40 2001
***************
*** 25,30 ****
--- 25,31 ----
  AC_CHECK_FUNCS(select, AC_DEFINE(BX_HAVE_SELECT))
  AC_CHECK_FUNCS(snprintf, AC_DEFINE(BX_HAVE_SNPRINTF))
  AC_CHECK_FUNCS(strtoull, AC_DEFINE(BX_HAVE_STRTOULL))
+ AC_CHECK_FUNCS(strdup, AC_DEFINE(BX_HAVE_STRDUP))
  
  AC_MSG_CHECKING(if compiler allows empty structs)
  AC_TRY_COMPILE([], [typedef struct { } junk;], 
diff -crN clean-portable1/debug/dbg_main.cc portable2/debug/dbg_main.cc
*** clean-portable1/debug/dbg_main.cc	Wed Apr  4 18:52:18 2001
--- portable2/debug/dbg_main.cc	Thu Apr  5 12:19:41 2001
***************
*** 1242,1248 ****
  {
        static char buf[80];
        if (base != 0) {
! 	    bx_snprintf (buf, 80, "non-zero base");
  	    return buf;
        }
        // Look up this context
--- 1242,1248 ----
  {
        static char buf[80];
        if (base != 0) {
! 	    snprintf (buf, 80, "non-zero base");
  	    return buf;
        }
        // Look up this context
***************
*** 1251,1267 ****
  	    // Try global context
  	    cntx = context_t::get_context(0);
  	    if (!cntx) {
! 		  bx_snprintf (buf, 80, "unknown context");
  		  return buf;
  	    }
        }
  
        symbol_entry_t* entr = cntx->get_symbol_entry(eip);
        if (!entr) {
! 	    bx_snprintf (buf, 80, "no symbol");
  	    return buf;
        }
!       bx_snprintf (buf, 80, "%s+%x", entr->name, eip - entr->start);
        return buf;
  }
  
--- 1251,1267 ----
  	    // Try global context
  	    cntx = context_t::get_context(0);
  	    if (!cntx) {
! 		  snprintf (buf, 80, "unknown context");
  		  return buf;
  	    }
        }
  
        symbol_entry_t* entr = cntx->get_symbol_entry(eip);
        if (!entr) {
! 	    snprintf (buf, 80, "no symbol");
  	    return buf;
        }
!       snprintf (buf, 80, "%s+%x", entr->name, eip - entr->start);
        return buf;
  }
  
diff -crN clean-portable1/debug/lexer.c portable2/debug/lexer.c
*** clean-portable1/debug/lexer.c	Wed Apr  4 18:52:18 2001
--- portable2/debug/lexer.c	Thu Apr  5 12:19:41 2001
***************
*** 19,25 ****
  /* A lexical scanner generated by flex */
  
  /* Scanner skeleton version:
!  * $Header: /cvsroot/bochs/bochs/patches/Attic/patch.portable2,v 1.1 2001/04/10 02:22:16 bdenney Exp $
   */
  
  #define FLEX_SCANNER
--- 19,25 ----
  /* A lexical scanner generated by flex */
  
  /* Scanner skeleton version:
!  * $Header: /cvsroot/bochs/bochs/patches/Attic/patch.portable2,v 1.1 2001/04/10 02:22:16 bdenney Exp $
   */
  
  #define FLEX_SCANNER
***************
*** 1272,1278 ****
  case 92:
  YY_RULE_SETUP
  #line 108 "lexer.l"
! { bxlval.ulval = bx_strtoull(bxtext, NULL, 10); return(BX_TOKEN_LONG_NUMERIC); }
  	YY_BREAK
  case 93:
  YY_RULE_SETUP
--- 1272,1278 ----
  case 92:
  YY_RULE_SETUP
  #line 108 "lexer.l"
! { bxlval.ulval = strtoull(bxtext, NULL, 10); return(BX_TOKEN_LONG_NUMERIC); }
  	YY_BREAK
  case 93:
  YY_RULE_SETUP
diff -crN clean-portable1/debug/lexer.l portable2/debug/lexer.l
*** clean-portable1/debug/lexer.l	Wed Apr  4 18:52:18 2001
--- portable2/debug/lexer.l	Thu Apr  5 12:19:41 2001
***************
*** 105,111 ****
  \/[0-9]+                           { bxlval.sval = strdup(bxtext); return(BX_TOKEN_XFORMAT); }
  0x[0-9a-fA-F]+  { bxlval.uval = strtoul(bxtext+2, NULL, 16); return(BX_TOKEN_NUMERIC); }
  0[0-7]+         { bxlval.uval = strtoul(bxtext+1, NULL, 8); return(BX_TOKEN_NUMERIC); }
! [0-9]+L         { bxlval.ulval = bx_strtoull(bxtext, NULL, 10); return(BX_TOKEN_LONG_NUMERIC); }
  [0-9]+          { bxlval.uval = strtoul(bxtext, NULL, 10); return(BX_TOKEN_NUMERIC); }
  $[a-zA-Z_][a-zA-Z0-9_]* { bxlval.sval = strdup(bxtext); return(BX_TOKEN_SYMBOLNAME); }
  \n              { return('\n'); }
--- 105,111 ----
  \/[0-9]+                           { bxlval.sval = strdup(bxtext); return(BX_TOKEN_XFORMAT); }
  0x[0-9a-fA-F]+  { bxlval.uval = strtoul(bxtext+2, NULL, 16); return(BX_TOKEN_NUMERIC); }
  0[0-7]+         { bxlval.uval = strtoul(bxtext+1, NULL, 8); return(BX_TOKEN_NUMERIC); }
! [0-9]+L         { bxlval.ulval = strtoull(bxtext, NULL, 10); return(BX_TOKEN_LONG_NUMERIC); }
  [0-9]+          { bxlval.uval = strtoul(bxtext, NULL, 10); return(BX_TOKEN_NUMERIC); }
  $[a-zA-Z_][a-zA-Z0-9_]* { bxlval.sval = strdup(bxtext); return(BX_TOKEN_SYMBOLNAME); }
  \n              { return('\n'); }
diff -crN clean-portable1/fpu/reg_add_sub.c portable2/fpu/reg_add_sub.c
*** clean-portable1/fpu/reg_add_sub.c	Wed Apr  4 18:52:18 2001
--- portable2/fpu/reg_add_sub.c	Thu Apr  5 12:19:41 2001
***************
*** 158,164 ****
      }
    else
      {
!       int rmint = (int)rm;
        b = &st(rmint);
        tagb = FPU_gettagi(rmint);
  
--- 158,164 ----
      }
    else
      {
!       int rmint = PTR2INT(rm);
        b = &st(rmint);
        tagb = FPU_gettagi(rmint);
  
diff -crN clean-portable1/fpu/reg_divide.c portable2/fpu/reg_divide.c
*** clean-portable1/fpu/reg_divide.c	Wed Apr  4 18:52:18 2001
--- portable2/fpu/reg_divide.c	Thu Apr  5 12:19:41 2001
***************
*** 32,38 ****
    FPU_REG *dest;
    u_char taga, tagb, signa, signb, sign, saved_sign;
    int tag, deststnr;
!   int rmint = (int)rm;
  
    if ( flags & DEST_RM )
      deststnr = rmint;
--- 32,38 ----
    FPU_REG *dest;
    u_char taga, tagb, signa, signb, sign, saved_sign;
    int tag, deststnr;
!   int rmint = PTR2INT(rm);
  
    if ( flags & DEST_RM )
      deststnr = rmint;
diff -crN clean-portable1/macintosh.txt portable2/macintosh.txt
*** clean-portable1/macintosh.txt	Mon Mar 19 12:36:43 2001
--- portable2/macintosh.txt	Thu Apr  5 12:19:40 2001
***************
*** 1,3 ****
--- 1,14 ----
+ Changes by Bryce Denney 4/5/2001:
+ I moved the contents of macutils.h into osdep.h, and macutils.c 
+ into osdep.cc.  There are functions missing on other platforms too, 
+ so I wanted to bring them all into the same place.
+ 
+ The original macintosh.txt follows.
+ ------------------------------------------------------------------
+ 
+ 
+ 
+ 
  STATUS OF THE MAC PORT:
  -----------------------
  
diff -crN clean-portable1/macutils.c portable2/macutils.c
*** clean-portable1/macutils.c	Mon Mar 19 12:36:43 2001
--- portable2/macutils.c	Wed Dec 31 19:00:00 1969
***************
*** 1,69 ****
- // macutils.c
- // (only required if you are building the MacOS port of Bochs)
- //
- // This file implements some functions which are required by
- // MacBochs
- 
- #include <stdio.h>
- #include <stdlib.h>
- #include <string.h>
- #include <stat.h>
- #include <Files.h>
- #include <Disks.h>
- #include "macutils.h"
- 
- char *strdup(const char *str)
- {
- 	char *temp;
- 	
- 	temp = malloc(strlen(str));
- 	sprintf(temp, "%s", str);
- 	return temp;
- 	
- 	// Well, I'm sure this isn't how strdup is REALLY implemented,
- 	// but it works...
- }
- 
- int fd_read(char *buffer, Bit32u offset, Bit32u bytes)
- {
- 	OSErr err;
- 	IOParam param;
- 	
- 	param.ioRefNum=-5; // Refnum of the floppy disk driver
- 	param.ioVRefNum=1;
- 	param.ioPosMode=fsFromStart;
- 	param.ioPosOffset=offset;
- 	param.ioBuffer=buffer;
- 	param.ioReqCount=bytes;
- 	err = PBReadSync((union ParamBlockRec *)(&param));
- 	return param.ioActCount;
- }
- 
- int fd_write(char *buffer, Bit32u offset, Bit32u bytes)
- {
- 	OSErr		err;
- 	IOParam	param;
- 	
- 	param.ioRefNum=-5; // Refnum of the floppy disk driver
- 	param.ioVRefNum=1;
- 	param.ioPosMode=fsFromStart;
- 	param.ioPosOffset=offset;
- 	param.ioBuffer=buffer;
- 	param.ioReqCount=bytes;
- 	err = PBWriteSync((union ParamBlockRec *)(&param));
- 	return param.ioActCount;
- }
- 
- int fd_stat(struct stat *buf)
- {
- 	OSErr		err;
- 	DrvSts	status;
- 	int			result;
- 	
- 	result = 0;
- 	err = DriveStatus(1, &status);
- 	if (status.diskInPlace <1 || status.diskInPlace > 2)
- 		result = -1;
- 	buf->st_mode = S_IFCHR;
- 	return result;
- }
\ No newline at end of file
--- 0 ----
diff -crN clean-portable1/macutils.h portable2/macutils.h
*** clean-portable1/macutils.h	Mon Mar 19 12:36:43 2001
--- portable2/macutils.h	Wed Dec 31 19:00:00 1969
***************
*** 1,19 ****
- // macutils.h
- // (only required if you are building the MacOS port of Bochs)
- //
- // Bochs uses some common (but non-ANSI) functions which are not
- // implemented in CodeWarrior for Mac (like strdup()). This file
- // provides some substitutes which produce the same results.
- 
- #include "config.h"
- 
- char *strdup(const char *str);
- 
- int fd_read(char *buffer, Bit32u offset, Bit32u bytes);
- int fd_write(char *buffer, Bit32u offset, Bit32u bytes);
- 
- // fd_read and fd_write are called by floppy.cc to access the Mac
- // floppy drive directly, since the MacOS doesn't have "special"
- // pathnames which map directly to IO devices
- 
- int fd_stat(struct stat *buf);
--- 0 ----
diff -crN clean-portable1/osdep.cc portable2/osdep.cc
*** clean-portable1/osdep.cc	Wed Dec 31 19:00:00 1969
--- portable2/osdep.cc	Thu Apr  5 12:19:40 2001
***************
*** 0 ****
--- 1,268 ----
+ //  Copyright (C) 2000  MandrakeSoft S.A.
+ //
+ //    MandrakeSoft S.A.
+ //    43, rue d'Aboukir
+ //    75002 Paris - France
+ //    http://www.linux-mandrake.com/
+ //    http://www.mandrakesoft.com/
+ //
+ //  This library is free software; you can redistribute it and/or
+ //  modify it under the terms of the GNU Lesser General Public
+ //  License as published by the Free Software Foundation; either
+ //  version 2 of the License, or (at your option) any later version.
+ //
+ //  This library is distributed in the hope that it will be useful,
+ //  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ //  Lesser General Public License for more details.
+ //
+ //  You should have received a copy of the GNU Lesser General Public
+ //  License along with this library; if not, write to the Free Software
+ //  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ 
+ //
+ // osdep.cc
+ // 
+ // Provide definition of library functions that are missing on various
+ // systems.  The only reason this is a .cc file rather than a .c file
+ // is so that it can include bochs.h.  Bochs.h includes all the required
+ // system headers, with appropriate #ifdefs for different compilers and 
+ // platforms.
+ //
+ 
+ #include "bochs.h"
+ 
+ //////////////////////////////////////////////////////////////////////
+ // Missing library functions.  These should work on any platform 
+ // that needs them.
+ //////////////////////////////////////////////////////////////////////
+ 
+ #if !BX_HAVE_SNPRINTF
+ /* if they don't have snprintf, just use sprintf */
+ int bx_snprintf (char *s, size_t maxlen, const char *format, ...)
+ {
+   va_list arg;
+   int done;
+ 
+   va_start (arg, format);
+   done = vsprintf (s, format, arg);
+   va_end (arg);
+ 
+   return done;
+ }
+ #endif  /* !BX_HAVE_SNPRINTF */
+ 
+ 
+ #if !BX_HAVE_STRTOULL
+ /* taken from glibc-2.2.2: strtod.c, and stripped down a lot.  There are 
+    still a few leftover references to decimal points and exponents, 
+    but it works for bases 10 and 16 */
+ 
+ #define RETURN(val,end)							      \
+     do { if (endptr != NULL) *endptr = (char *) (end);		      \
+ 	 return val; } while (0)
+ 
+ Bit64u
+ bx_strtoull (const char *nptr, char **endptr, int baseignore)
+ {
+   int negative;			/* The sign of the number.  */
+   int exponent;			/* Exponent of the number.  */
+ 
+   /* Numbers starting `0X' or `0x' have to be processed with base 16.  */
+   int base = 10;
+ 
+   /* Number of bits currently in result value.  */
+   int bits;
+ 
+   /* Running pointer after the last character processed in the string.  */
+   const char *cp, *tp;
+   /* Start of significant part of the number.  */
+   const char *startp, *start_of_digits;
+   /* Total number of digit and number of digits in integer part.  */
+   int dig_no;
+   /* Contains the last character read.  */
+   char c;
+ 
+   long long n = 0;
+   char const *p;
+ 
+   /* Prepare number representation.  */
+   exponent = 0;
+   negative = 0;
+   bits = 0;
+ 
+   /* Parse string to get maximal legal prefix.  We need the number of
+      characters of the integer part, the fractional part and the exponent.  */
+   cp = nptr - 1;
+   /* Ignore leading white space.  */
+   do
+     c = *++cp;
+   while (isspace (c));
+ 
+   /* Get sign of the result.  */
+   if (c == '-')
+     {
+       negative = 1;
+       c = *++cp;
+     }
+   else if (c == '+')
+     c = *++cp;
+ 
+   if (c < '0' || c > '9')
+     {
+       /* It is really a text we do not recognize.  */
+       RETURN (0, nptr);
+     }
+ 
+   /* First look whether we are faced with a hexadecimal number.  */
+   if (c == '0' && tolower (cp[1]) == 'x')
+     {
+       /* Okay, it is a hexa-decimal number.  Remember this and skip
+ 	 the characters.  BTW: hexadecimal numbers must not be
+ 	 grouped.  */
+       base = 16;
+       cp += 2;
+       c = *cp;
+     }
+ 
+   /* Record the start of the digits, in case we will check their grouping.  */
+   start_of_digits = startp = cp;
+ 
+   /* Ignore leading zeroes.  This helps us to avoid useless computations.  */
+   while (c == '0')
+     c = *++cp;
+ 
+   /* If no other digit but a '0' is found the result is 0.0.
+      Return current read pointer.  */
+   if ((c < '0' || c > '9')
+       && (base == 16 && (c < tolower ('a') || c > tolower ('f')))
+       && (base == 16 && (cp == start_of_digits || tolower (c) != 'p'))
+       && (base != 16 && tolower (c) != 'e'))
+     {
+       tp = start_of_digits;
+       /* If TP is at the start of the digits, there was no correctly
+ 	 grouped prefix of the string; so no number found.  */
+       RETURN (0, tp == start_of_digits ? (base == 16 ? cp - 1 : nptr) : tp);
+     }
+ 
+   /* Remember first significant digit and read following characters until the
+      decimal point, exponent character or any non-FP number character.  */
+   startp = cp;
+   dig_no = 0;
+   while (1)
+     {
+       if ((c >= '0' && c <= '9')
+ 	  || (base == 16 && tolower (c) >= 'a' && tolower (c) <= 'f'))
+ 	++dig_no;
+       else
+ 	break;
+       c = *++cp;
+     }
+ 
+   /* The whole string is parsed.  Store the address of the next character.  */
+   if (endptr)
+     *endptr = (char *) cp;
+ 
+   if (dig_no == 0) 
+     return 0;
+ 
+   for (p=start_of_digits; p!=cp; p++) {
+     n = n * (long long)base;
+     c = tolower (*p);
+     c = (c >= 'a') ? (10+c-'a') : c-'0';
+     n = n + (long long)c;
+     //printf ("after shifting in digit %c, n is %lld\n", *p, n);
+   }
+   return negative? -n : n;
+ }
+ #endif  /* !BX_HAVE_STRTOULL */
+ 
+ #if BX_TEST_STRTOULL_MAIN
+ /* test driver for strtoull.  Do not compile by default. */
+ int main (int argc, char **argv)
+ {
+   char buf[256], *endbuf;
+   long l;
+   long long ll;
+   while (1) {
+     printf ("Enter a long int: ");
+     gets (buf);
+     l = strtoul (buf, &endbuf, 10);
+     printf ("As a long, %ld\n", l);
+     printf ("Endbuf is at buf[%d]\n", endbuf-buf);
+     ll = bx_strtoull (buf, &endbuf, 10);
+     printf ("As a long long, %lld\n", ll);
+     printf ("Endbuf is at buf[%d]\n", endbuf-buf);
+   }
+   return 0;
+ }
+ #endif  /* BX_TEST_STRTOULL_MAIN */
+ 
+ #if !BX_HAVE_STRDUP
+ char *bx_strdup(const char *str)
+ {
+ 	char *temp;
+ 	
+ 	temp = malloc(strlen(str));
+ 	sprintf(temp, "%s", str);
+ 	return temp;
+ 	
+ 	// Well, I'm sure this isn't how strdup is REALLY implemented,
+ 	// but it works...
+ }
+ #endif  /* !BX_HAVE_STRDUP */
+ 
+ //////////////////////////////////////////////////////////////////////
+ // Missing library functions, implemented for MacOS only
+ //////////////////////////////////////////////////////////////////////
+ 
+ #if BX_WITH_MACOS
+ // these functions are part of MacBochs.  They are not intended to be
+ // portable!
+ #include <Files.h>
+ #include <Disks.h>
+ 
+ int fd_read(char *buffer, Bit32u offset, Bit32u bytes)
+ {
+ 	OSErr err;
+ 	IOParam param;
+ 	
+ 	param.ioRefNum=-5; // Refnum of the floppy disk driver
+ 	param.ioVRefNum=1;
+ 	param.ioPosMode=fsFromStart;
+ 	param.ioPosOffset=offset;
+ 	param.ioBuffer=buffer;
+ 	param.ioReqCount=bytes;
+ 	err = PBReadSync((union ParamBlockRec *)(&param));
+ 	return param.ioActCount;
+ }
+ 
+ int fd_write(char *buffer, Bit32u offset, Bit32u bytes)
+ {
+ 	OSErr		err;
+ 	IOParam	param;
+ 	
+ 	param.ioRefNum=-5; // Refnum of the floppy disk driver
+ 	param.ioVRefNum=1;
+ 	param.ioPosMode=fsFromStart;
+ 	param.ioPosOffset=offset;
+ 	param.ioBuffer=buffer;
+ 	param.ioReqCount=bytes;
+ 	err = PBWriteSync((union ParamBlockRec *)(&param));
+ 	return param.ioActCount;
+ }
+ 
+ int fd_stat(struct stat *buf)
+ {
+ 	OSErr		err;
+ 	DrvSts	status;
+ 	int			result;
+ 	
+ 	result = 0;
+ 	err = DriveStatus(1, &status);
+ 	if (status.diskInPlace <1 || status.diskInPlace > 2)
+ 		result = -1;
+ 	buf->st_mode = S_IFCHR;
+ 	return result;
+ }
+ #endif /* BX_WITH_MACOS */
diff -crN clean-portable1/osdep.h portable2/osdep.h
*** clean-portable1/osdep.h	Wed Apr  4 18:52:18 2001
--- portable2/osdep.h	Thu Apr  5 12:19:40 2001
***************
*** 1,41 ****
  //
  // osdep.h
  // 
! // Operating system dependent includes and defines for Bochs.  This file
! // can be included by C or C++., but it requires definition of size_t
! // beforehand.  This makes it difficult to place into either config.h or
! // bochs.h.  If in config.h, size_t is not always available yet.  If in
! // bochs.h, it can't be included by C programs so they lose.
  //
  
  #ifndef BX_OSDEP_H
  #define BX_OSDEP_H
  
- // This code recognizes the following preprocessor symbols for different
- // operating systems:
- //   macintosh
- //   WIN32
- 
  #ifdef __cplusplus
  extern "C" {
  #endif   /* __cplusplus */
  
  
! 
! #if BX_HAVE_SNPRINTF
! #define bx_snprintf snprintf
! #else
    extern int bx_snprintf (char *s, size_t maxlen, const char *format, ...);
  #endif
  
! 
! #if BX_HAVE_STRTOULL
! #define bx_strtoull strtoull
! #else
!   extern unsigned long long bx_strtoull (const char *nptr, char **endptr, int baseignore);
  #endif
  
  
  
  #ifdef __cplusplus
  }
--- 1,85 ----
+ //  Copyright (C) 2000  MandrakeSoft S.A.
+ //
+ //    MandrakeSoft S.A.
+ //    43, rue d'Aboukir
+ //    75002 Paris - France
+ //    http://www.linux-mandrake.com/
+ //    http://www.mandrakesoft.com/
+ //
+ //  This library is free software; you can redistribute it and/or
+ //  modify it under the terms of the GNU Lesser General Public
+ //  License as published by the Free Software Foundation; either
+ //  version 2 of the License, or (at your option) any later version.
+ //
+ //  This library is distributed in the hope that it will be useful,
+ //  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ //  Lesser General Public License for more details.
+ //
+ //  You should have received a copy of the GNU Lesser General Public
+ //  License along with this library; if not, write to the Free Software
+ //  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ 
  //
  // osdep.h
+ //
+ // requires Bit32u/Bit64u from config.h, size_t from stdio.h
  // 
! // Operating system dependent includes and defines for Bochs.  These 
! // declarations can be included by C or C++., but they require definition of
! // size_t beforehand.  This makes it difficult to place them into either
! // config.h or bochs.h.  If in config.h, size_t is not always available yet.
! // If in bochs.h, they can't be included by C programs so they lose.  
  //
  
  #ifndef BX_OSDEP_H
  #define BX_OSDEP_H
  
  #ifdef __cplusplus
  extern "C" {
  #endif   /* __cplusplus */
  
+ //////////////////////////////////////////////////////////////////////
+ // Missing library functions.
+ // These should work on any platform that needs them.
+ // 
+ // A missing library function is renamed to a bx_* function, so that when
+ // debugging and linking there's no confusion over which version is used.
+ // Because of renaming, the bx_* replacement functions can be tested on 
+ // machines which have the real library function without duplicate symbols.
+ //
+ // If you're considering implementing a missing library function, note 
+ // that it might be cleaner to conditionally disable the function call!
+ //////////////////////////////////////////////////////////////////////
  
! #if !BX_HAVE_SNPRINTF
! #define snprintf bx_snprintf
    extern int bx_snprintf (char *s, size_t maxlen, const char *format, ...);
  #endif
  
! #if !BX_HAVE_STRTOULL
! #define strtoull bx_strtoull
!   extern Bit64u bx_strtoull (const char *nptr, char **endptr, int baseignore);
  #endif
  
+ #if !BX_HAVE_STRDUP
+ #define strdup bx_strdup
+   extern char *bx_strdup(const char *str);
+ #endif
  
+ //////////////////////////////////////////////////////////////////////
+ // Missing library functions, implemented for MacOS only
+ //////////////////////////////////////////////////////////////////////
+ 
+ #if BX_WITH_MACOS
+ // fd_read and fd_write are called by floppy.cc to access the Mac
+ // floppy drive directly, since the MacOS doesn't have "special"
+ // pathnames which map directly to IO devices
+ 
+ int fd_read(char *buffer, Bit32u offset, Bit32u bytes);
+ int fd_write(char *buffer, Bit32u offset, Bit32u bytes);
+ int fd_stat(struct stat *buf);
+ #endif
  
  #ifdef __cplusplus
  }
diff -crN clean-portable1/snprintf.cc portable2/snprintf.cc
*** clean-portable1/snprintf.cc	Tue Apr  3 17:32:10 2001
--- portable2/snprintf.cc	Wed Dec 31 19:00:00 1969
***************
*** 1,25 ****
- //
- // snprintf.cc
- // 
- // Provide definition of snprintf, since it's sometimes not in libc.
- // This could have been a .c file, but then you have to do all your
- // includes conditional on each OS having them.  Easier to just let
- // bochs.h do it.
- //
- 
- #include "bochs.h"
- 
- #if !BX_HAVE_SNPRINTF
- /* if they don't have snprintf, just use sprintf */
- int bx_snprintf (char *s, size_t maxlen, const char *format, ...)
- {
-   va_list arg;
-   int done;
- 
-   va_start (arg, format);
-   done = vsprintf (s, format, arg);
-   va_end (arg);
- 
-   return done;
- }
- #endif  /* !BX_HAVE_SNPRINTF */
--- 0 ----
diff -crN clean-portable1/strtoull.cc portable2/strtoull.cc
*** clean-portable1/strtoull.cc	Tue Apr  3 17:32:10 2001
--- portable2/strtoull.cc	Wed Dec 31 19:00:00 1969
***************
*** 1,156 ****
- //
- // strtoull.cc
- // 
- // Provide definition of strtoull, since it's sometimes not in libc.
- // This could have been a .c file, but then you have to do all your
- // includes conditional on each OS having them.  Easier to just let
- // bochs.h do it.
- //
- 
- #include "bochs.h"
- 
- #if !BX_HAVE_STRTOULL
- /* taken from glibc-2.2.2: strtod.c, and stripped down a lot.  There are 
-    still a few leftover references to decimal points and exponents, 
-    but it seems to work for bases 10 and 16 */
- 
- #define RETURN(val,end)							      \
-     do { if (endptr != NULL) *endptr = (char *) (end);		      \
- 	 return val; } while (0)
- 
- unsigned long long bx_strtoull
- (const char *nptr, char **endptr, int baseignore)
- {
-   int negative;			/* The sign of the number.  */
-   int exponent;			/* Exponent of the number.  */
- 
-   /* Numbers starting `0X' or `0x' have to be processed with base 16.  */
-   int base = 10;
- 
-   /* Number of bits currently in result value.  */
-   int bits;
- 
-   /* Running pointer after the last character processed in the string.  */
-   const char *cp, *tp;
-   /* Start of significant part of the number.  */
-   const char *startp, *start_of_digits;
-   /* Total number of digit and number of digits in integer part.  */
-   int dig_no;
-   /* Contains the last character read.  */
-   char c;
- 
-   long long n = 0;
-   char const *p;
- 
-   /* Prepare number representation.  */
-   exponent = 0;
-   negative = 0;
-   bits = 0;
- 
-   /* Parse string to get maximal legal prefix.  We need the number of
-      characters of the integer part, the fractional part and the exponent.  */
-   cp = nptr - 1;
-   /* Ignore leading white space.  */
-   do
-     c = *++cp;
-   while (isspace (c));
- 
-   /* Get sign of the result.  */
-   if (c == '-')
-     {
-       negative = 1;
-       c = *++cp;
-     }
-   else if (c == '+')
-     c = *++cp;
- 
-   if (c < '0' || c > '9')
-     {
-       /* It is really a text we do not recognize.  */
-       RETURN (0, nptr);
-     }
- 
-   /* First look whether we are faced with a hexadecimal number.  */
-   if (c == '0' && tolower (cp[1]) == 'x')
-     {
-       /* Okay, it is a hexa-decimal number.  Remember this and skip
- 	 the characters.  BTW: hexadecimal numbers must not be
- 	 grouped.  */
-       base = 16;
-       cp += 2;
-       c = *cp;
-     }
- 
-   /* Record the start of the digits, in case we will check their grouping.  */
-   start_of_digits = startp = cp;
- 
-   /* Ignore leading zeroes.  This helps us to avoid useless computations.  */
-   while (c == '0')
-     c = *++cp;
- 
-   /* If no other digit but a '0' is found the result is 0.0.
-      Return current read pointer.  */
-   if ((c < '0' || c > '9')
-       && (base == 16 && (c < tolower ('a') || c > tolower ('f')))
-       && (base == 16 && (cp == start_of_digits || tolower (c) != 'p'))
-       && (base != 16 && tolower (c) != 'e'))
-     {
-       tp = start_of_digits;
-       /* If TP is at the start of the digits, there was no correctly
- 	 grouped prefix of the string; so no number found.  */
-       RETURN (0, tp == start_of_digits ? (base == 16 ? cp - 1 : nptr) : tp);
-     }
- 
-   /* Remember first significant digit and read following characters until the
-      decimal point, exponent character or any non-FP number character.  */
-   startp = cp;
-   dig_no = 0;
-   while (1)
-     {
-       if ((c >= '0' && c <= '9')
- 	  || (base == 16 && tolower (c) >= 'a' && tolower (c) <= 'f'))
- 	++dig_no;
-       else
- 	break;
-       c = *++cp;
-     }
- 
-   /* The whole string is parsed.  Store the address of the next character.  */
-   if (endptr)
-     *endptr = (char *) cp;
- 
-   if (dig_no == 0) 
-     return 0;
- 
-   for (p=start_of_digits; p!=cp; p++) {
-     n = n * (long long)base;
-     c = tolower (*p);
-     c = (c >= 'a') ? (10+c-'a') : c-'0';
-     n = n + (long long)c;
-     //printf ("after shifting in digit %c, n is %lld\n", *p, n);
-   }
-   return negative? -n : n;
- }
- 
- #if BX_TEST_STRTOULL
- /* test driver for strtoull */
- int main (int argc, char **argv)
- {
-   char buf[256], *endbuf;
-   long l;
-   long long ll;
-   while (1) {
-     printf ("Enter a long int: ");
-     gets (buf);
-     l = strtoul (buf, &endbuf, 10);
-     printf ("As a long, %ld\n", l);
-     printf ("Endbuf is at buf[%d]\n", endbuf-buf);
-     ll = bx_strtoull (buf, &endbuf, 10);
-     printf ("As a long long, %lld\n", ll);
-     printf ("Endbuf is at buf[%d]\n", endbuf-buf);
-   }
-   return 0;
- }
- #endif  /* defined BX_TEST_STRTOULL */
- 
- #endif  /* !BX_HAVE_STRTOULL */
--- 0 ----
