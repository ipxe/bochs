----------------------------------------------------------------------
Patch name: patch.paste-only-when-empty
Author: Bryce Denney
Date: Tue Mar 19 16:46:16 EST 2002

Detailed description:
This patch may not be necessary, but it should solve any keyboard buffer
overflows during a paste.  Instead of trying to guess how many scancodes
the modifier_down+key_down+key_up+modifier_up sequence will use, with
this patch it only inserts new keys when the buffer is completely empty.
Since Christophe mentioned he had trouble pasting >14 chars, I think
he was having trouble with the scancode buffer overflowing.

Patch was created with:
  cvs diff -u
Apply patch to what version:
  current cvs
Instructions:
  To patch, go to main bochs directory.
  Type "patch -p0 < THIS_PATCH_FILE".
----------------------------------------------------------------------

Index: iodev/keyboard.cc
===================================================================
RCS file: /cvsroot/bochs/bochs/iodev/keyboard.cc,v
retrieving revision 1.48
diff -u -r1.48 keyboard.cc
--- iodev/keyboard.cc	11 Mar 2002 16:25:52 -0000	1.48
+++ iodev/keyboard.cc	19 Mar 2002 22:00:57 -0000
@@ -598,30 +598,31 @@
 {
   BX_DEBUG (("service_paste_buf: ptr at %d out of %d", BX_KEY_THIS pastebuf_ptr, BX_KEY_THIS pastebuf_len));
   if (!BX_KEY_THIS pastebuf) return;
-  int fill_threshold = BX_KBD_ELEMENTS - 8;
-  while (BX_KEY_THIS pastebuf_ptr < BX_KEY_THIS pastebuf_len) {
-    if (BX_KEY_THIS s.kbd_internal_buffer.num_elements >= fill_threshold)
-      return;
-    // there room in the buffer for a keypress and a key release.
-    // send one keypress and a key release.
-    Bit8u byte = BX_KEY_THIS pastebuf[BX_KEY_THIS pastebuf_ptr];
-    BXKeyEntry *entry = bx_keymap.getKeyASCII (byte);
-    if (!entry) {
-      BX_ERROR (("paste character 0x%02x ignored", byte));
-    } else {
-      BX_DEBUG (("pasting character 0x%02x. baseKey is %04x", byte, entry->baseKey));
-      if (entry->modKey != BX_KEYMAP_UNKNOWN)
-        bx_devices.keyboard->gen_scancode(entry->modKey);
-      bx_devices.keyboard->gen_scancode(entry->baseKey);
-      bx_devices.keyboard->gen_scancode(entry->baseKey | BX_KEY_RELEASED);
-      if (entry->modKey != BX_KEYMAP_UNKNOWN)
-        bx_devices.keyboard->gen_scancode(entry->modKey | BX_KEY_RELEASED);
-    }
-    BX_KEY_THIS pastebuf_ptr++;
+  if (BX_KEY_THIS pastebuf_ptr >= BX_KEY_THIS pastebuf_len) {
+    // we reached end of pastebuf, so free the memory it was using.
+    free (BX_KEY_THIS pastebuf);
+    BX_KEY_THIS pastebuf = NULL;
+    return;
   }
-  // reached end of pastebuf.  free the memory it was using.
-  free (BX_KEY_THIS pastebuf);
-  BX_KEY_THIS pastebuf = NULL;
+  // Only paste when destination buffer is empty
+  if (BX_KEY_THIS s.kbd_internal_buffer.num_elements > 0)
+    return;
+  // Paste in a series of key events that produce the desired ASCII code.
+  // This assumes caps lock is off, all modifier keys are released, etc.
+  Bit8u byte = BX_KEY_THIS pastebuf[BX_KEY_THIS pastebuf_ptr];
+  BXKeyEntry *entry = bx_keymap.getKeyASCII (byte);
+  if (!entry) {
+    BX_ERROR (("paste character 0x%02x ignored", byte));
+  } else {
+    BX_DEBUG (("pasting character 0x%02x. baseKey is %04x", byte, entry->baseKey));
+    if (entry->modKey != BX_KEYMAP_UNKNOWN)
+      bx_devices.keyboard->gen_scancode(entry->modKey);
+    bx_devices.keyboard->gen_scancode(entry->baseKey);
+    bx_devices.keyboard->gen_scancode(entry->baseKey | BX_KEY_RELEASED);
+    if (entry->modKey != BX_KEYMAP_UNKNOWN)
+      bx_devices.keyboard->gen_scancode(entry->modKey | BX_KEY_RELEASED);
+  }
+  BX_KEY_THIS pastebuf_ptr++;
 }
 
 // paste_bytes schedules an arbitrary number of ASCII characters to be
