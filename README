BRANCH_PLUGINS

This branch is a place to experiment with Bochs plugins.  Bryce created
the branch on October 4, 2002 and checked in patch.plugins3 with
minor changes to get it to compile.  Plugins3 was a patch from 
December 2001 that copied in some of the plugin architecture from
plex86.  Here are the comments from that patch:

> Patch name: patch.plugins3
> Author: Bryce Denney
> Date: Wed Dec 12 17:56:11 EST 2001
> 
> This patch replaces the Bochs keyboard with a slightly modified version
> of the plex86 keyboard device, which is implemented as a plugin.  This
> is sort of a proof of concept, rather than anything that I'm about to
> check in.  It uses GNU libtool to compile the plex86 keyboard code into
> a shared library, and installs that shared library in
> /tmp/bochslib/libplex-keyboard.so.  Then the new code in plugin.cc (which
> is adapted from the plex86 plugin code) loads the libplex-keyboard library
> during initialization and installs the plex86 keyboard instead of the
> bochs keyboard.
> 
> I chose the keyboard because it takes about 2 seconds to test that it's
> basically working, and because the bochs and plex86 implementations hadn't
> changed very much since they split.
> 
> If you look at plex-keyboard.cc and plex-keyboard.h, it is fundamentally the
> same as the current plex86 code.  I have changed lots of names from bx_* to
> plex_* just to reduce confusion and mayhem when I was compiling with both
> kbd implementations.  I didn't change anything except to get it to compile.

plugins5 is based on plugins3, with the following changes :
 - plex86 keyboard device was marged with Bochs keyboard, as a plugin
 - plugin.cc was cleaned up
 - a device registration mechanism was set up
 - the biosdev and unmapped device were plugin-ized

The branch is called BRANCH_PLUGINS.  There is a normal tag called
BRANCH_PLUGINS_BASE that marks the point where the branch began.  This
will help at merge time.

TO DO:
- wxWindows gui as a plugin will not start up.  Normally wxWindows
  takes over your main() function and inserts its own app init code.
  We'll have to figure out what that app init code does and put it
  in plugin_init.

  - wxWindows and text config menu are working in the nonplugin case.
  - now I need to compile libwx.la and libcontrol.la, add a bochsrc
    option (config_interface: [text|wx]), and I think it will work.
  - what needs to be tested?
    - noplug: no plugins, just X11 selected
      - it starts up ok, quickstart works
    - noplug-wx: no plugins, wxWindows selected
      - I had to add BX_DEFAULT_CONFIG_INTERFACE and BX_DEFAULT_VGA_LIBRARY
        because now I'm trying to support many BX_WITH_* variables being
	on.
      - it starts up ok, quickstart works
    - plug: plugins, X11 is default
      - it starts up ok, quickstart works
      - config interface selection: ok for control, wx
      - gui selection: ok for x, sdl, rfb
      - this works: bochs 'config_interface: control' 'vga_library: sdl'
      - this works: bochs 'config_interface: control' 'vga_library: x'
      - this works: bochs 'config_interface: wx' 'vga_library: wx'
      - this works: bochs 'config_interface: wx' 'vga_library: sdl'
        But you get a wxWindows warning and it changes the vga_library to wx.
      - this fails: bochs 'config_interface: control' 'vga_library: wx'
        I made this panic because I had trouble getting wxWindows started 
	up and shut down properly in this configuration.
    - plug-wx: plugins, wxWindows is default
      - it starts up ok, quickstart works
      - exactly the same behavior as "plug" above.  These are not that
        different anymore, since there are multiple BX_WITH_* variables set.

How can I let the user set the preferred gui, if many guis are possible now?
#define BX_DEFAULT_CONFIG_INTERFACE "wx"
#define BX_DEFAULT_VGA_LIBRARY "wx"
this could be set by the first --with-NAME on the configure line



- convert remaining devices
- make dist-clean doesn't delete the .libs directories and the *.lo files
- --enable-all-optimizations fails at harddrv.cc
- platform specific issues
  - make sure LTDL works on VC++
  - to support plugins on win32, we must add special tags on any function or
    class in the executable that the plugins need to know about.  See
    plugin-test code for examples, e.g. definition of MAINAPI in
    bochs-testing/plugin-test/test8-execlass/main.h.
  - to support plugins on MacOSX, we must ensure that no plugins have
    any global symbol names in common, including plugin_init!  An
    easy solution to this is to say that all plugin functions which can
    be looked up with dlsym must follow a pattern like "%s_BXPLUG_%s",
    where the first %s is the module name and the second is the plain
    symbol name, e.g. pic_BXPLUG_plugin_init.  Symbols that are used 
    internally can be declared static (file scope only).
  - to support plugins on MacOSX, the user must install dlcompat.  Otherwise
    libtool's configure script will discovert that no dlopen() or equivalent
    function is found, and it will not be able to build/load plugins.
    The configure script should bomb in this case, with an error that says
    where to find dlcompat.  dlcompat IS installed on SF compile farm in
    /sw/include and /sw/lib.
  - to support plugins on Solaris, we must not rely on the use of
    global object constructors.  In fact every global variable in a module
    MUST BE set to a compile-time constant.  We must declare object pointers
    as globals, not actual objects.

- configure script work
  - LTDL has a feature called dlpreload which sort of emulates dlopen
    by linking all the modules statically and then emulating dlopen calls.
    I don't see any value in this for plugins.  If the platform cannot
    support dlopen or some equivalent, let the configure script crash and
    tell the user to configure without plugins instead.
  - Now we can compile multiple guis and devices, when before we had
    to choose just one.  So now we need a few configure lines to decide
    whether to compile each optional or platform specific plugin.
    Basically, we should be able compile everything that CAN compile on a
    platform.  A decent amount of configure script work will be required
    to build a list of which plugins we think CAN be compiled.

- we need to clarify the connection between plugins and devices.  
  - a plugin is a shared object that you load that has a plugin_init() and
    plugin_fini() function inside.  The plugin_init() can create any number of
    "devices" and register them.  Devices are added to a global list so that we
    can do operations on every registered device.
  - There is (now) a pointer from each device to the plugin that created it.
  - Devices created by core plugins are called core devices.  These will not be
    added to the device list because they are managed by existing code in
    devices.cc and elsewhere.  Instead of referring to them by their device_t
    structure, we will use a global pointer to them, similar to the
    bx_devices.pluginKeyboard pointer.  (Alternative: maybe we should add
    them to device list anyway, but exclude them in init_all and reset_all 
    functions.)
  - what code do I want to be able to write?
      ensure_plugin_loaded (PLUGIN_KEYBOARD);
      pluginKeyboard->init ();



- how do we know what plugins should be available when we start Bochs?
  - we can have core plugins, optional plugins, and user plugins.
    - (V2.0) core plugin: These are so fundamental that Bochs won't even
      initialize  without them, for example the CMOS.  The user can substitute
      his own equivalent plugin to replace the CMOS, but he cannot say "Don't
      load the CMOS at all."  Core plugins are initialized and reset explictly
      by code in iodev/devices.cc, since the initialization order for some of
      them is critical.  They are currently NOT added to the device list in
      pluginRegisterDevice and pluginRegisterDeviceDevmodel, so that the plugin
      system does not call init() and reset().  If a core plugin cannot
      be found, Bochs will panic.
      In the bochsrc we can provide a way for the user to REPLACE a core plugin
      with a different plugin that implements the same C++ interface, but there
      is no way to ask bochs to NOT load a core plugin.  I'm not sure how to
      configure the replacement plugin--this may have to be added later.
      Bochsrc line: 
        replace_core_plugin: old=pic, new=mypic
    - (V2.0) optional plugin: These can be loaded or not without affecting
      Bochs's ability to start up and simulate.  Initialization and reset for
      all optional plugins are handled by bx_init_plugins() and
      bx_reset_plugins(), which are now called from bx_devices_c::init() and
      bx_devices_c::reset().  Bochs knows how to configure optional plugins at
      compile time, and they   are loaded only if the configuration settings
      enables the device.  Examples: serial, parallel, ne2k.  See the call to
      is_serial_enabled() in iodev/devices.cc.  There are some plugins that you
      wouldn't ever want to leave out, like vga.  Maybe the term "optional" is
      not clear and I need to think of a better name.  Bochs will panic if an
      optional plugin cannot be found.  If the plugin was compiled, then
      it should be available at runtime too!
    - (Later?) user plugin: These are plugins that Bochs does not know anything
      about at compile time.  The user asks Bochs to load a plugin using just
      its filename.  It loads the plugin and (somehow) gets information about
      what settings the user can configure.  The settings are adjusted by
      either bochsrc lines or the user interface, and then the device can be
      used.  I'm missing some details here because I haven't thought through it
      all the way.  User plugins may not be supported until after v2.0.
  - some devices, such as the GUI, PIT, SB, and NE2000, have several different
    possible implementations.  In this case, all implementations should be
    children of a single stub class.  The stub's methods produce errors or
    panics if they are called, depending on the importance of the device.
    There is always one instance of the stub class lying around, which will be
    used if none of the implementation plugins is loaded.  Either an optional
    plugin or a user plugin can fill in these slots.
  - make a list of plugins sorted into categories (FIRST TRY)
    - core plugins: unmapped, biosdev, cmos, dma, pic, vga
    - optional: floppy, harddrv, keyboard, serial, parallel
    - user: none yet

- how do we locate plugins on the disk?
  - fortunately, the LTDL library takes care of searching a list of paths.
  - We can tell people how to set the LTDL_LIBRARY_PATH variable.  
  - we can implement a bochsrc command like
      plugin_search_directory: /path/to/libs
    which would call lt_dlsetsearchpath() to add the path to LTDL's list of
    directories it will search.

- (assigned to Bryce) how does the user select which gui to use?  Add a bochsrc
  parameter "gui_select: sdl".  This variable can also be edited in
  configuration menus.  If there is no user-specified value when it's time to
  initialize the gui, it will choose the first gui in the list of available
  ones.  We just need to put the list in a reasonable order, for example don't 
  put nogui first.

- parameters of plugins... It would be nice to move the creation of the
  parameters into the code for the device that they affect.  However this
  would mean that you could not configure any plugin (except for whether to
  enable it or not) until you have loaded it.  I don't really want to display a
  dialog that says "Enable this device? [ ]" and load the plugin and fill in
  the rest of the dialog only if they check the box.
  - one solution, which I'm not sure that I like: separate the plugin into
    two shared objects. libDEVNAME_param that sets up the configuration
    parameters only, and libDEVNAME implements the whole thing.  The idea would
    be that you would load EVERY lib*_param on startup so that you can allow
    the user to configure the plugin.  Then only the ones that are enabled
    would load the remainder of their code.
  - alternative: distinguish between plugins known at compile time, and plugins
    which the user adds manually through the config interface or bochsrc.
    For standard plugins that are compiled in, we can put all the parameter
    code into the executable as it is now.  For plugins that are added
    by the user, there is no doubt about whether to load them or not.  They
    wouldn't have asked for it, if they didn't want to load it!  In that
    case, the config parameters can be initialized as soon as the module 
    is loaded.  Once it is loaded, the config interface can display the
    parameters so that the device can be configured.

- make plugin CPU???

DONE:
- applied patch.plugins5
- updated makefile dependencies now that plugin.h is in there
- all guis converted to plugins
- 8 I/O devices are converted to plugins
- make the Makefile use libtool to build dynamic libraries
- use libtool's ltdl library to open and read dynamic libraries, since it
  has cross platform support
- the Boolean/bx_bool thing will be resolved in the main branch.  I have
  made patch.replace-Boolean.gz which I will apply later, after the
  plugins branch has been merged.  This become more urgent because it
  caused bug #623152 MacOSX: Triple Exception Booting win95
- take a look at the code generated by calls to virtual functions, to 
  check if there's huge overhead that I don't know about.

  Answer: I don't believe there is that much extra overhead.  If you call
  a nonvirtual function, it must push all the args onto the stack, then
  push the THIS pointer, then call the method using a known constant address.
  With a virtual function, y you push all the args onto the stack, then push
  the THIS pointer, then do one extra memory reference to THIS+constant to read
  the pointer to the virtual method, and call it.  This is just what I
  expected to find--no strange and magicial code was inserted by the 
  compiler in this case.
-----------------------------------------------
random notes:

how to make a gui into a plugin?
virtual functions versus lots of function pointers.
Make bx_gui_c a class with virtual methods to be supplied by the
plugins.  Each gui will be a child class of bx_gui_c which supplies
the required methods.

How will the plugin loader know how to create new objects?
It doesn't.  The .so file has a "global" variable like "bx_cmos"
so the constructor must be called as the module loads.  For any
device that needs to be initialized with new operator, I may need
to add a static method to the class that can call the constructor.

class heirarchy:
 logfunctions
 - bx_devmodel_c
   - bx_keyb_stub_c
     - bx_keyb_c

bx_devmodel_c is an abstract class that defines standard functions that all
devices should define, like init and reset.  Each method is defined as empty
in bx_devmodel_c so that child classes can choose to implement them or not.

bx_keyb_stub_c declares the methods that code outside the keyboard would need
to call, such as mouse_motion, gen_scancode, etc.  It declares these methods
virtual, and provides a minimal definition for each that just does a panic.   A
global variable pluginKeyboard initially points to an instance of
bx_keyb_stub_c so that if you forget/fail to load the load the keyboard plugin,
you will see these panics when the methods are called.

bx_keyb_c is the real keyboard code.  In its constructor, it changes 
pluginKeyboard to point to "this".  This is equivalent to installing all
the plugin callbacks associated with the keyboard.  It also works in
nonplugin code, which is a plus. 


hard drive read_handler.  Right now the read_handler
is a static method so it must get its object pointer from somewhere.
  1) It can get it from global variable bx_hard_drive
  2) The hard drive object can be passed in to it
We've always used #2, so every device has methods that look like this:

  static Bit32u read_handler(void *this_ptr, Bit32u address, unsigned io_len);
  static void   write_handler(void *this_ptr, Bit32u address, Bit32u value, unsi

If/when we switch over to using virtual methods, there will no longer be
any problem finding the this pointer.  If we go that route, the this_ptr
can be eliminated.  For now, we must use the this_ptr.  Otherwise we could
never support more than one device of a given type.



------------------------------------------
References

From: Tero Pulkkinen (p150650@zori.cs.tut.fi)
 Subject: Re: undefined reference to `pm virtual table' 
 Newsgroups: gnu.g++.help
 Date: 1996/11/15 


> The compile goes off OK, but I get this error at link time:
>   pm.o(.text+0xa8): undefined reference to `pm virtual table'

This error comes from that the compiler didnt make virtual function
table for object even though there's implemented functions that use
objects of that type(constructor for example). Probably your pm-class
has all implemented member functions *inline* and you still have
(pure) virtual functions inside the class.

The creation point of virtual function table usually (dunno if g++ does that)
is at position of first seen noninline function body of that class.
Now if every of your function is inline, there's no place where compiler
could make virtual function table.

Fix is to move body of for example constructor(any member is fine) to the .cc 
file instead of keeping it in .h-file and linking that .o file to your 
executable.

Other sollution is to remove *all* implementations of functions from header
file. If all functions of a class are pure virtual, there's no need for
virtual function table. (Constructor must set pointer to virtual function
table to the object, so, if you have constructor, you'll need virtual
function table too, even in abstract classes...)

> Can someone help me?  Thanks in advance.

Hope this helps....

------------------------------------------------
Bochs x86 Pentium Emulator
Updated: Wed Mar 27 20:02:41  2002
Version: 1.4

WHAT IS BOCHS?

Bochs is a highly portable open source IA-32 (x86) PC emulator
written in C++, that runs on most popular platforms.  It includes
emulation of the Intel x86 CPU, common I/O devices, and a custom
BIOS.  Currently, bochs can be compiled to emulate a 386, 486 or
Pentium CPU.  Bochs is capable of running most Operating Systems
inside the emulation including Linux, Windows 95, DOS, and 
Windows NT 4.  Bochs was written by Kevin Lawton and is currently 
maintained by the Bochs project at "http://bochs.sourceforge.net".

Bochs can be compiled and used in a variety of modes, some which are
still in development.  The 'typical' use of bochs is to provide
complete x86 PC emulation, including the x86 processor, hardware
devices, and memory.  This allows you to run OS's and software within
the emulator on your workstation, much like you have a machine
inside of a machine.  Bochs will allow you to run Win '95
applications on a Solaris machine with X11, for example.

Bochs is distributed under the GNU LGPL.  See COPYING for details.

GETTING CURRENT SOURCE CODE 

Source code for Bochs is available from the Bochs home page at
http://bochs.sourceforge.net.  You can download the most recent
release, use CVS to get the latest sources, or grab a CVS
snapshot which is updated nightly.  The releases contain the most
stable code, but if you want the very newest features try the
CVS version instead. 

WHERE ARE THE DOCS?

The Bochs documentation has been overhauled, and it is now
distributed in a separate package called bochsdoc-VERSION.tar.gz.
A copy is also online at 
  http://bochs.sf.net/doc/docbook/alldocs.html
For now, the old documentation can still be found at
  http://bochs.sf.net/docs-html

WHERE CAN I GET MORE INFORMATION?  HOW DO I REPORT PROBLEMS?

Both the documentation and the Bochs website have instructions on how 
to join the bochs-developers mailing list, which is the primary
forum for discussion of Bochs.  The main page of the website also
has links to bug reports and feature requests.  You can browse and
add to the content in these areas even if you do not have a (free)
SourceForge account.  We need your feedback so that we know what
parts of Bochs to improve.  

There is a patches section on the web site too, if you have made
some changes to Bochs that you want to share.

HOW CAN I HELP?

If you would like contribute to the Bochs project, a good first step
is to join the bochs-developers mailing list, and read the archive
of recent messages to see what's going on.  

If you are a technical person (can follow hardware specs, can write
C/C++) take a look at the list of open bug reports and feature
requests to see if you are interested in working on any of the
problems that are mentioned in them.  If you check out the CVS
sources, make some changes, and create a patch, one of the
developers will be very happy to apply it for you.  Developers who
frequently submit patches, or who embark on major changes in the
source can get write access to CVS.  Be sure to communicate with the
bochs-developers list to avoid several people working on the same
thing without realizing it.

If you are a Bochs user, not a hardware/C++ guru, there are still
many ways you could help out.  For example:
  - improving win32 binary releases
  - building up a set of useful tools to include in those releases
  - writing/cleaning up documentation
  - testing out Bochs on every imaginable operating system and 
    reporting how it goes.
