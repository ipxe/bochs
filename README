--------------------------------------------------------------------
SMP-bochs
Bochs pentium simulator, with multiprocessor support
Updated Tue Apr  3 12:39:56 EDT 2001
Bryce Denney  (bryce.denney@bigfoot.com)
--------------------------------------------------------------------

What is this?
- SMP-bochs is Kevin Lawton's Bochs pentium simulator, with modifications to
  simulate several processors.  The starting point was the 3/25/2000 snapshot
  from ftp.bochs.com.
- Bochs is released under LGPL, so this version is the same.
- I have tried to keep this code "mainstream" in that the default configure
  file uses the same settings as the last official Bochs snapshot.
- I have implemented the features required for Linux SMP, including RDTSC
  instruction, local APIC on each processor (with timer), and one I/O APIC.
  Other operating systems may work, but I haven't tried them.  
- I modified the rombios.c file to add a data structure called the Intel
  Multiprocessor Configuration.  An SMP-aware operating system such as Linux
  probes BIOS memory to find the structure, which contains information about
  how many processors, their IDs, interrupt sources, etc.
- Minor additions to the debugger, such as an "info idt" command that prints
  the Interrupt Descriptor Table in a readable form.  The debugger will also
  use the GNU readline library if configure can locate it.
- This release should be much more portable than the bochs snapshot, since
  a number of new checks have been added to the configure script:
    checking size of int *... 4
    checking for snprintf... yes
    checking for strtoull... yes
    checking if compiler allows empty structs... yes
    checking if compiler allows __attribute__... yes
    checking for hash_map.h... yes
  as well as sanity-checks such as "if the debugger is enabled, then
  disassembly must be enabled."
- With some help of www.testdrive.compaq.com, I was able to compile this
  version on the platforms listed below.  This doesn't mean extensive 
  testing(!) but at least it will compile.  All platforms used gcc except
  for Tru64 Unix, which used Compaq C++ V6.2-024.
    Intel   Caldera OpenLinux eDesktop 2.4
    Intel   Debian 2.2 Linux
    Intel   RedHat 7.0 Linux
    Intel   Kondara 2000 Linux
    Intel   TurboLinux 6.0
    Intel   Mandrake 7.0 Linux
    Intel   FreeBSD 4.2
    Intel   SuSE 7.0 Linux
    Sun4    Solaris (SunOS 5.6)
    Alpha   Compaq Tru64 Unix 5.1
    Alpha   Compaq Tru64 Unix 4.0g
    Alpha   Kondara 2000 Linux
    Alpha   Debian 2.2 Linux
    Alpha   SuSE 7.0 Linux
    Alpha   FreeBSD 4.2
    Alpha   NetBSD 1.5   (had to rm fpu/*.S first, due to wierd make behavior)
    IA64    Linux64

What is this NOT?
- Do not expect that configuring bochs for 4 processors will make your
  single-threaded applications run faster in general.  On the contrary, it has
  to spend time simulating idle processors as well as the ones doing your task.
  My point was to simulate an SMP system, not to speed up a uniprocessor
  application.
- A number of people have suggested using threads to simulate each CPU in
  a different thread.  Then on a real SMP machine, the threads can execute
  in parallel.  This is a great idea, but it's not done at present.
- I have not tested any SMP-aware operating systems other that Linux 2.2.14.
  There are no Linux-specific hacks in the models, but other OSes may depend
  on features that haven't been implemented yet.
- Multiprocessor support requires multiple instances of BX_CPU, so it
  is NOT compatible with Bochs's preprocessor controlled
  static-member-function idea.  I have turned off SMF for the CPU
  object, and this may lead to a reduction in performance.  C++ vs C
  speed arguments apply.  Probably with sufficient macro tricks, one
  could make SMF work again when it's configured for one processor,
  but I haven't seen this as a high priority.

CONFIGURATION

To configure a single-processor system, just run configure as you would 
with the bochs snapshot.  The defaults are still cpu level=5, all devices
except for VGA off.

   ./configure
   fix errors if necessary
   make
   edit .bochsrc to point to your disk images, etc.
   ./bochs

If you want to try multiple processors, use the --enable-processors=<N>
option to configure.  For Linux (maybe others) you will probably want
--enable-fpu.  Much faster to let bochs C code emulate the floating
point than bochs-emulated kernel instructions!

  ./configure --enable-processors=<N> --enable-fpu              (<N>=2 or 4)
  fix errors if necessary
  make
  edit .bochsrc.  the romimage should point to bios/BIOS-bochs-<N>-processors
  ./bochs

Now there's no reason you can't have 3 or 7 processors, but you'll
need to hack bios/rombios.c to change MP configuration data structure.
This takes me about 10 minutes per configuration, since you have to get
the data checksums right.  There may be a maximum of 15, but I haven't
tried.  I have provided bios/BIOS-bochs-2-processors and
bios/BIOS-bochs-4-processors in the TAR files.

You can enable the debugger using --enable-debugger.  This option will
turn on --enbable-disassembler automatically.

Refer to docs-html/* for normal Bochs setup questions.  For anything
else related to Bochs or SMP, please write to bryce.denney@bigfoot.com.  
I'll be interested to hear if anyone gets it going.

And the biggest question of all: WHY SMP bochs?

First it must be said that Bochs is an amazing achievement as-is.  The IA32 
architecture has grown into such a tangled mess and I'm MOST IMPRESSED with
Kevin's and the bochs developers' accuracy in simulating it, and coming up
with device models that allow you to boot DOS, Win, Unix, etc.

I have been interested in learning about how the Linux kernel works: memory
management, task switching, system calls, interrupt handlers, etc.  For this,
the ability to single-step through the kernel without bringing down your host
machine and refer to the kernel source is a powerful tool.  Then, for some
work projects I'm learning all I can about multiprocessor techniques.  I don't
have a SMP machine to play with, and even if I did it wouldn't be possible to
watch the APICs, spin locks, and task switching in real time.  

So now we have an SMP machine to tinker with.  I hope to compile some
multi-threaded benchmark code to see how tasks are assigned to different CPUs.
The APIC models still need some work (timer doesn't count, no task priority,
etc.) and it doesn't compile with BX_APIC_SUPPORT turned off.  There's
certainly room for improvement.

I keep my changes in a local CVS tree, which I will make public if
requested.  A log of my changes is in CHANGES.bbd.  

Have fun!
Bryce Denney


-----------What follows is the original README-----------
Bochs x86 Pentium Emulator
Upated: Wed May 16 22:03:11 EDT 2001
Version: 1.1.2  (bugfix3)

WHAT IS BOCHS?

Bochs is a highly portable open source IA-32 (x86) PC emulator
written in C++, that runs on most popular platforms.  It includes
emulation of the Intel x86 CPU, common I/O devices, and a custom
BIOS.  Currently, bochs can be compiled to emulate a 386, 486 or
Pentium CPU.  Bochs is capable of running most Operating Systems
inside the emulation including Linux, Windows 95, DOS, and 
Windows NT 4.  Bochs was written by Kevin Lawton and is currently 
maintained by the Bochs project at "http://bochs.sourceforge.net".

Bochs can be compiled and used in a variety of modes, some which are
still in development.  The 'typical' use of bochs is to provide
complete x86 PC emulation, including the x86 processor, hardware
devices, and memory.  This allows you to run OS's and software within
the emulator on your workstation, much like you have a machine
inside of a machine.  Bochs will allow you to run Win '95
applications on a Solaris machine with X11, for example.

Bochs is distributed under the GNU LGPL.  See COPYING for details.

GETTING CURRENT SOURCE CODE 

Source code for Bochs is available from the Bochs home page at
http://bochs.sourceforge.net.  You can download the most recent
release, use CVS to get the latest sources, or grab a CVS
snapshot which is updated nightly.  The releases contain the most
stable code, but if you want the very newest features try the
CVS version instead. 

COMPILING BOCHS FROM SOURCES

All releases are gzip'd tar files.  That means the whole Bochs source
code directory has been consolidated into one file using the Unix
command 'tar', then compressed to save space with GNU 'gzip'.  To
extract the source code, you'll need both 'tar' and 'gzip/gunzip'.
All files are contained within one subdirectory named 'bochs-[VERSION]'. 

cd /path/parent-directory
gzip -dc bochs-[VERSION].tar.gz | tar -xvf -
cd bochs-[VERSION]

Before compiling, you'll need to run the configure script, which
will configure source code to run on your system, and with your
chosen options.  There are many options to 'configure', and you
probably don't need any of them.  If you run BeOS, specify
'--with-beos' to configure.  To see a complete list: 

unix-> ./configure --help

For more complete documentation of options available to configure,
look at docs-html/configure.html in your browser.

If configure cannot guess your compiler and compiler arguments,
you will also need to set environment variables to tell configure
what compiler and options to use.  The relevant environment variables 
are CC and CXX (C and C++ compiler), CFLAGS and CXXFLAGS (options
for the C and C++ compiler).

Now run configure, be it manually or by way of a script file. 

unix-> ./configure
-or-
unix-> ./.conf.x86

If the configure script bombs, check 'config.log'. Specifically,
look for errors returned by the compiler.  You may have options
incompatible with your compiler.  See the link on setting the
environment variables above. 

Assuming at this point all went well with the configure command,
edit the file 'config.h', which was generated by ./configure.  Look
for the USER CONFIGURABLE OPTIONS section.  Each parameter available
for editing is documented.  Generally the defaults are fine for
typical users.  Please read about each parameter and edit carefully.
NOTE: This file is generated, and will be deleted if you run 'make
dist-clean'. 

You may now compile the source. 

unix-> make

WHERE ARE THE DOCS?

You have a local copy of the Bochs documentation in docs-html that
came out of the TAR file.  (Point your browser to
docs-html/index.html.)  These same docs are also on the web at
http://bochs.sourceforge.net/docs-html.  If you followed the compile
directions above, the next step is "Setting up the environment
before running" under Compile/Install.

WHERE CAN I GET MORE INFORMATION?  HOW DO I REPORT PROBLEMS?

Both the docs-html and the Bochs website have instructions on how 
to join the bochs-developers mailing list, which is the primary
forum for discussion of Bochs.  The main page of the website also
has links to bug reports and feature requests.  You can browse and
add to the content in these areas even if you do not have a (free)
SourceForge account.  We need your feedback so that we know what
parts of Bochs to improve.  

There is a patches section on the web site too, if you have made
some changes to Bochs that you want to share.

HOW CAN I HELP?

If you would like contribute to the Bochs project, a good first step
is to join the bochs-developers mailing list, and read the archive
of recent messages to see what's going on.  

If you are a technical person (can follow hardware specs, can write
C/C++) take a look at the list of open bug reports and feature
requests to see if you are interested in working on any of the
problems that are mentioned in them.  If you check out the CVS
sources, make some changes, and create a patch, one of the
developers will be very happy to apply it for you.  Developers who
frequently submit patches, or who embark on major changes in the
source can get write access to CVS.  Be sure to communicate with the
bochs-developers list to avoid several people working on the same
thing without realizing it.

If you are a Bochs user, not a hardware/C++ guru, there are still
many ways you could help out.  We have a group of people working on
making win32 binary releases, and building up a set of useful tools
to include in those releases.  Others are writing documentation or
cleaning up the existing documentation.  Others are testing out
Bochs on every imaginable operating system and writing about how
they did it.
