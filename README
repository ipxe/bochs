BRANCH_PLUGINS

This branch is a place to experiment with Bochs plugins.  Bryce created
the branch on October 4, 2002 and checked in patch.plugins3 with
minor changes to get it to compile.  Plugins3 was a patch from 
December 2001 that copied in some of the plugin architecture from
plex86.  Here are the comments from that patch:

> Patch name: patch.plugins3
> Author: Bryce Denney
> Date: Wed Dec 12 17:56:11 EST 2001
> 
> This patch replaces the Bochs keyboard with a slightly modified version
> of the plex86 keyboard device, which is implemented as a plugin.  This
> is sort of a proof of concept, rather than anything that I'm about to
> check in.  It uses GNU libtool to compile the plex86 keyboard code into
> a shared library, and installs that shared library in
> /tmp/bochslib/libplex-keyboard.so.  Then the new code in plugin.cc (which
> is adapted from the plex86 plugin code) loads the libplex-keyboard library
> during initialization and installs the plex86 keyboard instead of the
> bochs keyboard.
> 
> I chose the keyboard because it takes about 2 seconds to test that it's
> basically working, and because the bochs and plex86 implementations hadn't
> changed very much since they split.
> 
> If you look at plex-keyboard.cc and plex-keyboard.h, it is fundamentally the
> same as the current plex86 code.  I have changed lots of names from bx_* to
> plex_* just to reduce confusion and mayhem when I was compiling with both
> kbd implementations.  I didn't change anything except to get it to compile.

plugins5 is based on plugins3, with the following changes :
 - plex86 keyboard device was marged with Bochs keyboard, as a plugin
 - plugin.cc was cleaned up
 - a device registration mechanism was set up
 - the biosdev and unmapped device were plugin-ized

The branch is called BRANCH_PLUGINS.  There is a normal tag called
BRANCH_PLUGINS_BASE that marks the point where the branch began.  This
will help at merge time.

TO DO:
- wxWindows gui as a plugin will not start up.  Normally wxWindows
  takes over your main() function and inserts its own app init code.
  We'll have to figure out what that app init code does and put it
  in plugin_init.
- Bryce is experimenting with using classes with virtual functions
  to make the plugin interface cleaner.  The keyboard plugin has been
  implemented this way, and all the gui modules are implemented in a
  very similar way.
- convert remaining devices
- MacOS X: with patch.ltdl, it builds ok but when I try to load plugins it
  says no symbols defined.
  00000000000p[     ] >>PANIC<< dlopen failed for module 'libunmapped.la': no symbols defined
  I think lt_dlinit() is setting only one loader, the one for ldpreload.
  It must have failed all these conditions and gone right to the 
  dlpreload loader.

    #if HAVE_LIBDL && !defined(__CYGWIN__)
    errors += lt_dlloader_add (lt_dlloader_next (0), &sys_dl, "dlopen");
    #endif
    #if HAVE_SHL_LOAD
    errors += lt_dlloader_add (lt_dlloader_next (0), &sys_shl, "dlopen");
    #endif
    #ifdef __WINDOWS__
    errors += lt_dlloader_add (lt_dlloader_next (0), &sys_wll, "dlopen");
    #endif
    #ifdef __BEOS__
    errors += lt_dlloader_add (lt_dlloader_next (0), &sys_bedl, "dlopen");
    #endif
    #if HAVE_DLD
    errors += lt_dlloader_add (lt_dlloader_next (0), &sys_dld, "dld");
    #endir
    errors += lt_dlloader_add (lt_dlloader_next (0), &presym, "dlpreload");

  GOOD info on MacOS X bug fixes for libtool 1.4.2
  http://fink.sourceforge.net/doc/porting/libtool.php
  this may solve the problems I have been seeing.

  Also see side note: The libltdl library included with all libtool versions
  will only work on Darwin when dlcompat is installed. 

  dlcompat IS installed on SF compile farm in /sw/include and /sw/lib.
  the next problem is this:
  lt_dlsym error: dlcompat: dyld: uselib multiple definitions of symbol _module_init
  but the libtool manual has some ideas about changing the symbol names
  to avoid exactly this problem.

- Solaris: it does not appear to call constructors of global objects that
  are loaded in a plugin.  I expect that if we link the plugins with the
  correct C++ library and linker options, it will call them.  However I'm
  not sure we should rely on this.  Maybe we should structure our plugins
  so that they do not require any global constructors?
- LTDL has a feature called dlpreload which sort of emulates dlopen
  by linking all the modules statically and then emulating dlopen calls.
  I don't see any value in this at the moment.  If the platform cannot
  support dlopen or some equivalent, let's just forget it and disable
  plugins entirely.  But how are we going to detect when it's going to
  resort to dlpreload?  Hopefully at configure time we can figure it out.


- how do we know what plugins should be available when we start Bochs?
  - idea: have a list of plugin names that is linked into the binary that
    tells which guis and which devices are guaranteed to be available.
    In a static binary, they are 100% guaranteed.  In a plugin binary,
    it will assume that all the plugins on the list can be loaded if 
    necessary.
  - if you want bochs to load a plugin that was not known at compile time,
    we can allow a bochsrc line such as "plugin_gui: sdl" or
    "plugin_device: mypit".  I'm distinguishing between gui and device 
    plugins, because they are used in quite different ways.

- how do we locate plugins on the disk?
  - bochsrc could say "plugin_search_directory: /path/to/libs".  If possible
    the user specified directory should be tried first.  If there are multiple
    copies installed, surely the user wants the one that he specifically asked
    for.
  - try a list of other directories that are compiled into the binary, such as
    the place that bochs is installed, e.g. $prefix/$version/plugins.
  - just attempt to load it and see if it works, using the system's default
    search routine.  On some systems the LD_LIBRARY_PATH variable will control
    what directories are checked.

- (assigned to Bryce) how does the user select which gui to use?  Add a bochsrc
  parameter "gui_select: sdl".  This variable can also be edited in
  configuration menus.  If there is no user-specified value when it's time to
  initialize the gui, it will choose the first gui in the list of available
  ones.  We just need to put the list in a reasonable order, for example don't 
  put nogui first.
- parameters of plugins... It would be nice to move the creation of the
  parameters into the code for the device that they affect.  However this
  would mean that you could not configure any plugin (except for whether to
  enable it or not) until you have loaded it.  I don't really want to display a
  dialog that says "Enable this device? [ ]" and load the plugin and fill in
  the rest of the dialog only if they check the box.
  - one solution, which I'm not sure that I like: separate the plugin into
    two shared objects. libDEVNAME_param that sets up the configuration
    parameters only, and libDEVNAME implements the whole thing.  The idea would
    be that you would load EVERY lib*_param on startup so that you can allow
    the user to configure the plugin.  Then only the ones that are enabled
    would load the remainder of their code.
  - alternative: distinguish between plugins known at compile time, and plugins
    which the user adds manually through the config interface or bochsrc.
    For standard plugins that are compiled in, we can put all the parameter
    code into the executable as it is now.  For plugins that are added
    by the user, there is no doubt about whether to load them or not.  They
    wouldn't have asked for it, if they didn't want to load it!  In that
    case, the config parameters can be initialized as soon as the module 
    is loaded.  Once it is loaded, the config interface can display the
    parameters so that the device can be configured.

- take a look at the code generated by calls to virtual functions, to 
  check if there's huge overhead that I don't know about.
- make plugin CPU???
- s/Boolean/bx_bool/g.  The problem is that Boolean conflicts with MacOS X's
  Carbon headers.  In the past, we had worked around this by doing
    #if BX_WITH_CARBON
    typedef unsigned char Boolean;
    #else
    typedef unsigned int Boolean;
    #endif
  However this is not good enough.  To compile the Carbon GUI I need 
  Boolean to be 8bits, but all others expect it to be 32bits.
  It will be must safer if we just define our own boolean to be Bit8u or
  Bit32u.


DONE:
- applied patch.plugins5
- updated makefile dependencies now that plugin.h is in there
- all guis converted to plugins
- 8 I/O devices are converted to plugins
- make the Makefile use libtool to build dynamic libraries
- use libtool's ltdl library to open and read dynamic libraries, since it
  has cross platform support
-----------------------------------------------
random notes:

how to make a gui into a plugin?
virtual functions versus lots of function pointers.
Make bx_gui_c a class with virtual methods to be supplied by the
plugins.  Each gui will be a child class of bx_gui_c which supplies
the required methods.

How will the plugin loader know how to create new objects?
It doesn't.  The .so file has a "global" variable like "bx_cmos"
so the constructor must be called as the module loads.  For any
device that needs to be initialized with new operator, I may need
to add a static method to the class that can call the constructor.

class heirarchy:
 logfunctions
 - bx_devmodel_c
   - bx_keyb_stub_c
     - bx_keyb_c

bx_devmodel_c is an abstract class that defines standard functions that all
devices should define, like init and reset.  Each method is defined as empty
in bx_devmodel_c so that child classes can choose to implement them or not.

bx_keyb_stub_c declares the methods that code outside the keyboard would need
to call, such as mouse_motion, gen_scancode, etc.  It declares these methods
virtual, and provides a minimal definition for each that just does a panic.   A
global variable pluginKeyboard initially points to an instance of
bx_keyb_stub_c so that if you forget/fail to load the load the keyboard plugin,
you will see these panics when the methods are called.

bx_keyb_c is the real keyboard code.  In its constructor, it changes 
pluginKeyboard to point to "this".  This is equivalent to installing all
the plugin callbacks associated with the keyboard.  It also works in
nonplugin code, which is a plus. 


hard drive read_handler.  Right now the read_handler
is a static method so it must get its object pointer from somewhere.
  1) It can get it from global variable bx_hard_drive
  2) The hard drive object can be passed in to it
We've always used #2, so every device has methods that look like this:

  static Bit32u read_handler(void *this_ptr, Bit32u address, unsigned io_len);
  static void   write_handler(void *this_ptr, Bit32u address, Bit32u value, unsi

If/when we switch over to using virtual methods, there will no longer be
any problem finding the this pointer.  If we go that route, the this_ptr
can be eliminated.  For now, we must use the this_ptr.  Otherwise we could
never support more than one device of a given type.

------------------------------------------
References

From: Tero Pulkkinen (p150650@zori.cs.tut.fi)
 Subject: Re: undefined reference to `pm virtual table' 
 Newsgroups: gnu.g++.help
 Date: 1996/11/15 


> The compile goes off OK, but I get this error at link time:
>   pm.o(.text+0xa8): undefined reference to `pm virtual table'

This error comes from that the compiler didnt make virtual function
table for object even though there's implemented functions that use
objects of that type(constructor for example). Probably your pm-class
has all implemented member functions *inline* and you still have
(pure) virtual functions inside the class.

The creation point of virtual function table usually (dunno if g++ does that)
is at position of first seen noninline function body of that class.
Now if every of your function is inline, there's no place where compiler
could make virtual function table.

Fix is to move body of for example constructor(any member is fine) to the .cc 
file instead of keeping it in .h-file and linking that .o file to your 
executable.

Other sollution is to remove *all* implementations of functions from header
file. If all functions of a class are pure virtual, there's no need for
virtual function table. (Constructor must set pointer to virtual function
table to the object, so, if you have constructor, you'll need virtual
function table too, even in abstract classes...)

> Can someone help me?  Thanks in advance.

Hope this helps....

------------------------------------------------
Bochs x86 Pentium Emulator
Updated: Wed Mar 27 20:02:41  2002
Version: 1.4

WHAT IS BOCHS?

Bochs is a highly portable open source IA-32 (x86) PC emulator
written in C++, that runs on most popular platforms.  It includes
emulation of the Intel x86 CPU, common I/O devices, and a custom
BIOS.  Currently, bochs can be compiled to emulate a 386, 486 or
Pentium CPU.  Bochs is capable of running most Operating Systems
inside the emulation including Linux, Windows 95, DOS, and 
Windows NT 4.  Bochs was written by Kevin Lawton and is currently 
maintained by the Bochs project at "http://bochs.sourceforge.net".

Bochs can be compiled and used in a variety of modes, some which are
still in development.  The 'typical' use of bochs is to provide
complete x86 PC emulation, including the x86 processor, hardware
devices, and memory.  This allows you to run OS's and software within
the emulator on your workstation, much like you have a machine
inside of a machine.  Bochs will allow you to run Win '95
applications on a Solaris machine with X11, for example.

Bochs is distributed under the GNU LGPL.  See COPYING for details.

GETTING CURRENT SOURCE CODE 

Source code for Bochs is available from the Bochs home page at
http://bochs.sourceforge.net.  You can download the most recent
release, use CVS to get the latest sources, or grab a CVS
snapshot which is updated nightly.  The releases contain the most
stable code, but if you want the very newest features try the
CVS version instead. 

WHERE ARE THE DOCS?

The Bochs documentation has been overhauled, and it is now
distributed in a separate package called bochsdoc-VERSION.tar.gz.
A copy is also online at 
  http://bochs.sf.net/doc/docbook/alldocs.html
For now, the old documentation can still be found at
  http://bochs.sf.net/docs-html

WHERE CAN I GET MORE INFORMATION?  HOW DO I REPORT PROBLEMS?

Both the documentation and the Bochs website have instructions on how 
to join the bochs-developers mailing list, which is the primary
forum for discussion of Bochs.  The main page of the website also
has links to bug reports and feature requests.  You can browse and
add to the content in these areas even if you do not have a (free)
SourceForge account.  We need your feedback so that we know what
parts of Bochs to improve.  

There is a patches section on the web site too, if you have made
some changes to Bochs that you want to share.

HOW CAN I HELP?

If you would like contribute to the Bochs project, a good first step
is to join the bochs-developers mailing list, and read the archive
of recent messages to see what's going on.  

If you are a technical person (can follow hardware specs, can write
C/C++) take a look at the list of open bug reports and feature
requests to see if you are interested in working on any of the
problems that are mentioned in them.  If you check out the CVS
sources, make some changes, and create a patch, one of the
developers will be very happy to apply it for you.  Developers who
frequently submit patches, or who embark on major changes in the
source can get write access to CVS.  Be sure to communicate with the
bochs-developers list to avoid several people working on the same
thing without realizing it.

If you are a Bochs user, not a hardware/C++ guru, there are still
many ways you could help out.  For example:
  - improving win32 binary releases
  - building up a set of useful tools to include in those releases
  - writing/cleaning up documentation
  - testing out Bochs on every imaginable operating system and 
    reporting how it goes.
